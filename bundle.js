(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
const InstiMap=require("instimapweb"),autocomplete=require("autocomplete.js"),Fuse=require("fuse.js"),Hammer=require("hammerjs");var fuse,locations=[];const fuse_options={shouldSort:!0,threshold:.3,tokenize:!0,location:0,distance:7,maxPatternLength:10,minMatchCharLength:1,keys:["name","short_name"]};function locSearch(e,t){results=fuse.search(e).slice(0,10),t(results)}function locationSelected(e){null==e?(document.getElementById("infobox").style.opacity=0,document.getElementById("locfab").classList.remove("translate"),setTimeout(function(){document.getElementById("infobox").style.display="none",document.getElementById("locname").innerText="",document.getElementById("locdesc").innerText=""},300)):(document.getElementById("infobox").style.display="block",document.getElementById("locfab").classList.add("translate"),setTimeout(function(){document.getElementById("infobox").style.opacity=1},100),document.getElementById("locname").innerText=e.name,document.getElementById("locdesc").innerText=e.description)}autocomplete("#search",{hint:!0},[{source:locSearch,displayKey:"short_name",templates:{suggestion:function(e){return e.short_name}}}]).on("autocomplete:selected",function(e,t,n,a){InstiMap.moveToLocation(t),locationSelected(t)}),fetch("https://api.insti.app/api/locations").then(function(e){return e.json()}).then(function(e){fuse=new Fuse(locations=e,fuse_options),InstiMap.getMap({mapPath:"assets/map.jpg",mapMinPath:"assets/map-min.jpg",markersBase:"/assets/map/",attributions:'<a href="http://mrane.com/" target="_blank">Prof. Mandar Rane</a>',map_id:"map",marker_id:"marker",user_marker_id:"user-marker"},locations,e=>{locationSelected(e)},()=>{console.log("map loaded")})});var square=document.querySelector("#infobox"),manager=new Hammer.Manager(square),Swipe=new Hammer.Swipe;manager.add(Swipe),manager.on("swipe",function(e){var t=e.offsetDirection;8===t?e.target.classList.add("expanded"):16==t&&e.target.classList.remove("expanded")}),document.getElementById("locfab").addEventListener("click",function(){InstiMap.getGPS()});

},{"autocomplete.js":3,"fuse.js":21,"hammerjs":22,"instimapweb":29}],3:[function(require,module,exports){
'use strict';

module.exports = require('./src/standalone/');

},{"./src/standalone/":18}],4:[function(require,module,exports){
'use strict';

var _ = require('../common/utils.js');

var css = {
  wrapper: {
    position: 'relative',
    display: 'inline-block'
  },
  hint: {
    position: 'absolute',
    top: '0',
    left: '0',
    borderColor: 'transparent',
    boxShadow: 'none',
    // #741: fix hint opacity issue on iOS
    opacity: '1'
  },
  input: {
    position: 'relative',
    verticalAlign: 'top',
    backgroundColor: 'transparent'
  },
  inputWithNoHint: {
    position: 'relative',
    verticalAlign: 'top'
  },
  dropdown: {
    position: 'absolute',
    top: '100%',
    left: '0',
    zIndex: '100',
    display: 'none'
  },
  suggestions: {
    display: 'block'
  },
  suggestion: {
    whiteSpace: 'nowrap',
    cursor: 'pointer'
  },
  suggestionChild: {
    whiteSpace: 'normal'
  },
  ltr: {
    left: '0',
    right: 'auto'
  },
  rtl: {
    left: 'auto',
    right: '0'
  },
  defaultClasses: {
    root: 'algolia-autocomplete',
    prefix: 'aa',
    noPrefix: false,
    dropdownMenu: 'dropdown-menu',
    input: 'input',
    hint: 'hint',
    suggestions: 'suggestions',
    suggestion: 'suggestion',
    cursor: 'cursor',
    dataset: 'dataset',
    empty: 'empty'
  },
  // will be merged with the default ones if appendTo is used
  appendTo: {
    wrapper: {
      position: 'absolute',
      zIndex: '100',
      display: 'none'
    },
    input: {},
    inputWithNoHint: {},
    dropdown: {
      display: 'block'
    }
  }
};

// ie specific styling
if (_.isMsie()) {
  // ie6-8 (and 9?) doesn't fire hover and click events for elements with
  // transparent backgrounds, for a workaround, use 1x1 transparent gif
  _.mixin(css.input, {
    backgroundImage: 'url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)'
  });
}

// ie7 and under specific styling
if (_.isMsie() && _.isMsie() <= 7) {
  // if someone can tell me why this is necessary to align
  // the hint with the query in ie7, i'll send you $5 - @JakeHarding
  _.mixin(css.input, {marginTop: '-1px'});
}

module.exports = css;

},{"../common/utils.js":14}],5:[function(require,module,exports){
'use strict';

var datasetKey = 'aaDataset';
var valueKey = 'aaValue';
var datumKey = 'aaDatum';

var _ = require('../common/utils.js');
var DOM = require('../common/dom.js');
var html = require('./html.js');
var css = require('./css.js');
var EventEmitter = require('./event_emitter.js');

// constructor
// -----------

function Dataset(o) {
  o = o || {};
  o.templates = o.templates || {};

  if (!o.source) {
    _.error('missing source');
  }

  if (o.name && !isValidName(o.name)) {
    _.error('invalid dataset name: ' + o.name);
  }

  // tracks the last query the dataset was updated for
  this.query = null;
  this._isEmpty = true;

  this.highlight = !!o.highlight;
  this.name = typeof o.name === 'undefined' || o.name === null ? _.getUniqueId() : o.name;

  this.source = o.source;
  this.displayFn = getDisplayFn(o.display || o.displayKey);

  this.debounce = o.debounce;

  this.cache = o.cache !== false;

  this.templates = getTemplates(o.templates, this.displayFn);

  this.css = _.mixin({}, css, o.appendTo ? css.appendTo : {});
  this.cssClasses = o.cssClasses = _.mixin({}, css.defaultClasses, o.cssClasses || {});
  this.cssClasses.prefix =
    o.cssClasses.formattedPrefix || _.formatPrefix(this.cssClasses.prefix, this.cssClasses.noPrefix);

  var clazz = _.className(this.cssClasses.prefix, this.cssClasses.dataset);
  this.$el = o.$menu && o.$menu.find(clazz + '-' + this.name).length > 0 ?
    DOM.element(o.$menu.find(clazz + '-' + this.name)[0]) :
    DOM.element(
      html.dataset.replace('%CLASS%', this.name)
        .replace('%PREFIX%', this.cssClasses.prefix)
        .replace('%DATASET%', this.cssClasses.dataset)
    );

  this.$menu = o.$menu;
  this.clearCachedSuggestions();
}

// static methods
// --------------

Dataset.extractDatasetName = function extractDatasetName(el) {
  return DOM.element(el).data(datasetKey);
};

Dataset.extractValue = function extractValue(el) {
  return DOM.element(el).data(valueKey);
};

Dataset.extractDatum = function extractDatum(el) {
  var datum = DOM.element(el).data(datumKey);
  if (typeof datum === 'string') {
    // Zepto has an automatic deserialization of the
    // JSON encoded data attribute
    datum = JSON.parse(datum);
  }
  return datum;
};

// instance methods
// ----------------

_.mixin(Dataset.prototype, EventEmitter, {

  // ### private

  _render: function render(query, suggestions) {
    if (!this.$el) {
      return;
    }
    var that = this;

    var hasSuggestions;
    var renderArgs = [].slice.call(arguments, 2);
    this.$el.empty();

    hasSuggestions = suggestions && suggestions.length;
    this._isEmpty = !hasSuggestions;

    if (!hasSuggestions && this.templates.empty) {
      this.$el
        .html(getEmptyHtml.apply(this, renderArgs))
        .prepend(that.templates.header ? getHeaderHtml.apply(this, renderArgs) : null)
        .append(that.templates.footer ? getFooterHtml.apply(this, renderArgs) : null);
    } else if (hasSuggestions) {
      this.$el
        .html(getSuggestionsHtml.apply(this, renderArgs))
        .prepend(that.templates.header ? getHeaderHtml.apply(this, renderArgs) : null)
        .append(that.templates.footer ? getFooterHtml.apply(this, renderArgs) : null);
    } else if (suggestions && !Array.isArray(suggestions)) {
      throw new TypeError('suggestions must be an array');
    }

    if (this.$menu) {
      this.$menu.addClass(
        this.cssClasses.prefix + (hasSuggestions ? 'with' : 'without') + '-' + this.name
      ).removeClass(
        this.cssClasses.prefix + (hasSuggestions ? 'without' : 'with') + '-' + this.name
      );
    }

    this.trigger('rendered', query);

    function getEmptyHtml() {
      var args = [].slice.call(arguments, 0);
      args = [{query: query, isEmpty: true}].concat(args);
      return that.templates.empty.apply(this, args);
    }

    function getSuggestionsHtml() {
      var args = [].slice.call(arguments, 0);
      var $suggestions;
      var nodes;
      var self = this;

      var suggestionsHtml = html.suggestions.
        replace('%PREFIX%', this.cssClasses.prefix).
        replace('%SUGGESTIONS%', this.cssClasses.suggestions);
      $suggestions = DOM
        .element(suggestionsHtml)
        .css(this.css.suggestions);

      // jQuery#append doesn't support arrays as the first argument
      // until version 1.8, see http://bugs.jquery.com/ticket/11231
      nodes = _.map(suggestions, getSuggestionNode);
      $suggestions.append.apply($suggestions, nodes);

      return $suggestions;

      function getSuggestionNode(suggestion) {
        var $el;

        var suggestionHtml = html.suggestion.
          replace('%PREFIX%', self.cssClasses.prefix).
          replace('%SUGGESTION%', self.cssClasses.suggestion);
        $el = DOM.element(suggestionHtml)
          .attr({
            role: 'option',
            id: ['option', Math.floor(Math.random() * 100000000)].join('-')
          })
          .append(that.templates.suggestion.apply(this, [suggestion].concat(args)));

        $el.data(datasetKey, that.name);
        $el.data(valueKey, that.displayFn(suggestion) || undefined); // this led to undefined return value
        $el.data(datumKey, JSON.stringify(suggestion));
        $el.children().each(function() { DOM.element(this).css(self.css.suggestionChild); });

        return $el;
      }
    }

    function getHeaderHtml() {
      var args = [].slice.call(arguments, 0);
      args = [{query: query, isEmpty: !hasSuggestions}].concat(args);
      return that.templates.header.apply(this, args);
    }

    function getFooterHtml() {
      var args = [].slice.call(arguments, 0);
      args = [{query: query, isEmpty: !hasSuggestions}].concat(args);
      return that.templates.footer.apply(this, args);
    }
  },

  // ### public

  getRoot: function getRoot() {
    return this.$el;
  },

  update: function update(query) {
    function handleSuggestions(suggestions) {
      // if the update has been canceled or if the query has changed
      // do not render the suggestions as they've become outdated
      if (!this.canceled && query === this.query) {
        // concat all the other arguments that could have been passed
        // to the render function, and forward them to _render
        var extraArgs = [].slice.call(arguments, 1);
        this.cacheSuggestions(query, suggestions, extraArgs);
        this._render.apply(this, [query, suggestions].concat(extraArgs));
      }
    }

    this.query = query;
    this.canceled = false;

    if (this.shouldFetchFromCache(query)) {
      handleSuggestions.apply(this, [this.cachedSuggestions].concat(this.cachedRenderExtraArgs));
    } else {
      var that = this;
      var execSource = function() {
        // When the call is debounced the condition avoid to do a useless
        // request with the last character when the input has been cleared
        if (!that.canceled) {
          that.source(query, handleSuggestions.bind(that));
        }
      };

      if (this.debounce) {
        var later = function() {
          that.debounceTimeout = null;
          execSource();
        };
        clearTimeout(this.debounceTimeout);
        this.debounceTimeout = setTimeout(later, this.debounce);
      } else {
        execSource();
      }
    }
  },

  cacheSuggestions: function cacheSuggestions(query, suggestions, extraArgs) {
    this.cachedQuery = query;
    this.cachedSuggestions = suggestions;
    this.cachedRenderExtraArgs = extraArgs;
  },

  shouldFetchFromCache: function shouldFetchFromCache(query) {
    return this.cache &&
      this.cachedQuery === query &&
      this.cachedSuggestions &&
      this.cachedSuggestions.length;
  },

  clearCachedSuggestions: function clearCachedSuggestions() {
    delete this.cachedQuery;
    delete this.cachedSuggestions;
    delete this.cachedRenderExtraArgs;
  },

  cancel: function cancel() {
    this.canceled = true;
  },

  clear: function clear() {
    this.cancel();
    this.$el.empty();
    this.trigger('rendered', '');
  },

  isEmpty: function isEmpty() {
    return this._isEmpty;
  },

  destroy: function destroy() {
    this.clearCachedSuggestions();
    this.$el = null;
  }
});

// helper functions
// ----------------

function getDisplayFn(display) {
  display = display || 'value';

  return _.isFunction(display) ? display : displayFn;

  function displayFn(obj) {
    return obj[display];
  }
}

function getTemplates(templates, displayFn) {
  return {
    empty: templates.empty && _.templatify(templates.empty),
    header: templates.header && _.templatify(templates.header),
    footer: templates.footer && _.templatify(templates.footer),
    suggestion: templates.suggestion || suggestionTemplate
  };

  function suggestionTemplate(context) {
    return '<p>' + displayFn(context) + '</p>';
  }
}

function isValidName(str) {
  // dashes, underscores, letters, and numbers
  return (/^[_a-zA-Z0-9-]+$/).test(str);
}

module.exports = Dataset;

},{"../common/dom.js":12,"../common/utils.js":14,"./css.js":4,"./event_emitter.js":8,"./html.js":9}],6:[function(require,module,exports){
'use strict';

var _ = require('../common/utils.js');
var DOM = require('../common/dom.js');
var EventEmitter = require('./event_emitter.js');
var Dataset = require('./dataset.js');
var css = require('./css.js');

// constructor
// -----------

function Dropdown(o) {
  var that = this;
  var onSuggestionClick;
  var onSuggestionMouseEnter;
  var onSuggestionMouseLeave;

  o = o || {};

  if (!o.menu) {
    _.error('menu is required');
  }

  if (!_.isArray(o.datasets) && !_.isObject(o.datasets)) {
    _.error('1 or more datasets required');
  }
  if (!o.datasets) {
    _.error('datasets is required');
  }

  this.isOpen = false;
  this.isEmpty = true;
  this.minLength = o.minLength || 0;
  this.templates = {};
  this.appendTo = o.appendTo || false;
  this.css = _.mixin({}, css, o.appendTo ? css.appendTo : {});
  this.cssClasses = o.cssClasses = _.mixin({}, css.defaultClasses, o.cssClasses || {});
  this.cssClasses.prefix =
    o.cssClasses.formattedPrefix || _.formatPrefix(this.cssClasses.prefix, this.cssClasses.noPrefix);

  // bound functions
  onSuggestionClick = _.bind(this._onSuggestionClick, this);
  onSuggestionMouseEnter = _.bind(this._onSuggestionMouseEnter, this);
  onSuggestionMouseLeave = _.bind(this._onSuggestionMouseLeave, this);

  var cssClass = _.className(this.cssClasses.prefix, this.cssClasses.suggestion);
  this.$menu = DOM.element(o.menu)
    .on('mouseenter.aa', cssClass, onSuggestionMouseEnter)
    .on('mouseleave.aa', cssClass, onSuggestionMouseLeave)
    .on('click.aa', cssClass, onSuggestionClick);

  this.$container = o.appendTo ? o.wrapper : this.$menu;

  if (o.templates && o.templates.header) {
    this.templates.header = _.templatify(o.templates.header);
    this.$menu.prepend(this.templates.header());
  }

  if (o.templates && o.templates.empty) {
    this.templates.empty = _.templatify(o.templates.empty);
    this.$empty = DOM.element('<div class="' +
      _.className(this.cssClasses.prefix, this.cssClasses.empty, true) + '">' +
      '</div>');
    this.$menu.append(this.$empty);
    this.$empty.hide();
  }

  this.datasets = _.map(o.datasets, function(oDataset) {
    return initializeDataset(that.$menu, oDataset, o.cssClasses);
  });
  _.each(this.datasets, function(dataset) {
    var root = dataset.getRoot();
    if (root && root.parent().length === 0) {
      that.$menu.append(root);
    }
    dataset.onSync('rendered', that._onRendered, that);
  });

  if (o.templates && o.templates.footer) {
    this.templates.footer = _.templatify(o.templates.footer);
    this.$menu.append(this.templates.footer());
  }

  var self = this;
  DOM.element(window).resize(function() {
    self._redraw();
  });
}

// instance methods
// ----------------

_.mixin(Dropdown.prototype, EventEmitter, {

  // ### private

  _onSuggestionClick: function onSuggestionClick($e) {
    this.trigger('suggestionClicked', DOM.element($e.currentTarget));
  },

  _onSuggestionMouseEnter: function onSuggestionMouseEnter($e) {
    var elt = DOM.element($e.currentTarget);
    if (elt.hasClass(_.className(this.cssClasses.prefix, this.cssClasses.cursor, true))) {
      // we're already on the cursor
      // => we're probably entering it again after leaving it for a nested div
      return;
    }
    this._removeCursor();

    // Fixes iOS double tap behaviour, by modifying the DOM right before the
    // native href clicks happens, iOS will requires another tap to follow
    // a suggestion that has an <a href> element inside
    // https://www.google.com/search?q=ios+double+tap+bug+href
    var suggestion = this;
    setTimeout(function() {
      // this exact line, when inside the main loop, will trigger a double tap bug
      // on iOS devices
      suggestion._setCursor(elt, false);
    }, 0);
  },

  _onSuggestionMouseLeave: function onSuggestionMouseLeave($e) {
    // $e.relatedTarget is the `EventTarget` the pointing device entered to
    if ($e.relatedTarget) {
      var elt = DOM.element($e.relatedTarget);
      if (elt.closest('.' + _.className(this.cssClasses.prefix, this.cssClasses.cursor, true)).length > 0) {
        // our father is a cursor
        // => it means we're just leaving the suggestion for a nested div
        return;
      }
    }
    this._removeCursor();
    this.trigger('cursorRemoved');
  },

  _onRendered: function onRendered(e, query) {
    this.isEmpty = _.every(this.datasets, isDatasetEmpty);

    if (this.isEmpty) {
      if (query.length >= this.minLength) {
        this.trigger('empty');
      }

      if (this.$empty) {
        if (query.length < this.minLength) {
          this._hide();
        } else {
          var html = this.templates.empty({
            query: this.datasets[0] && this.datasets[0].query
          });
          this.$empty.html(html);
          this.$empty.show();
          this._show();
        }
      } else if (_.any(this.datasets, hasEmptyTemplate)) {
        if (query.length < this.minLength) {
          this._hide();
        } else {
          this._show();
        }
      } else {
        this._hide();
      }
    } else if (this.isOpen) {
      if (this.$empty) {
        this.$empty.empty();
        this.$empty.hide();
      }

      if (query.length >= this.minLength) {
        this._show();
      } else {
        this._hide();
      }
    }

    this.trigger('datasetRendered');

    function isDatasetEmpty(dataset) {
      return dataset.isEmpty();
    }

    function hasEmptyTemplate(dataset) {
      return dataset.templates && dataset.templates.empty;
    }
  },

  _hide: function() {
    this.$container.hide();
  },

  _show: function() {
    // can't use jQuery#show because $menu is a span element we want
    // display: block; not dislay: inline;
    this.$container.css('display', 'block');

    this._redraw();

    this.trigger('shown');
  },

  _redraw: function redraw() {
    if (!this.isOpen || !this.appendTo) return;

    this.trigger('redrawn');
  },

  _getSuggestions: function getSuggestions() {
    return this.$menu.find(_.className(this.cssClasses.prefix, this.cssClasses.suggestion));
  },

  _getCursor: function getCursor() {
    return this.$menu.find(_.className(this.cssClasses.prefix, this.cssClasses.cursor)).first();
  },

  _setCursor: function setCursor($el, updateInput) {
    $el.first()
      .addClass(_.className(this.cssClasses.prefix, this.cssClasses.cursor, true))
      .attr('aria-selected', 'true');
    this.trigger('cursorMoved', updateInput);
  },

  _removeCursor: function removeCursor() {
    this._getCursor()
      .removeClass(_.className(this.cssClasses.prefix, this.cssClasses.cursor, true))
      .removeAttr('aria-selected');
  },

  _moveCursor: function moveCursor(increment) {
    var $suggestions;
    var $oldCursor;
    var newCursorIndex;
    var $newCursor;

    if (!this.isOpen) {
      return;
    }

    $oldCursor = this._getCursor();
    $suggestions = this._getSuggestions();

    this._removeCursor();

    // shifting before and after modulo to deal with -1 index
    newCursorIndex = $suggestions.index($oldCursor) + increment;
    newCursorIndex = (newCursorIndex + 1) % ($suggestions.length + 1) - 1;

    if (newCursorIndex === -1) {
      this.trigger('cursorRemoved');

      return;
    } else if (newCursorIndex < -1) {
      newCursorIndex = $suggestions.length - 1;
    }

    this._setCursor($newCursor = $suggestions.eq(newCursorIndex), true);

    // in the case of scrollable overflow
    // make sure the cursor is visible in the menu
    this._ensureVisible($newCursor);
  },

  _ensureVisible: function ensureVisible($el) {
    var elTop;
    var elBottom;
    var menuScrollTop;
    var menuHeight;

    elTop = $el.position().top;
    elBottom = elTop + $el.height() +
      parseInt($el.css('margin-top'), 10) +
      parseInt($el.css('margin-bottom'), 10);
    menuScrollTop = this.$menu.scrollTop();
    menuHeight = this.$menu.height() +
      parseInt(this.$menu.css('padding-top'), 10) +
      parseInt(this.$menu.css('padding-bottom'), 10);

    if (elTop < 0) {
      this.$menu.scrollTop(menuScrollTop + elTop);
    } else if (menuHeight < elBottom) {
      this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));
    }
  },

  // ### public

  close: function close() {
    if (this.isOpen) {
      this.isOpen = false;

      this._removeCursor();
      this._hide();

      this.trigger('closed');
    }
  },

  open: function open() {
    if (!this.isOpen) {
      this.isOpen = true;

      if (!this.isEmpty) {
        this._show();
      }

      this.trigger('opened');
    }
  },

  setLanguageDirection: function setLanguageDirection(dir) {
    this.$menu.css(dir === 'ltr' ? this.css.ltr : this.css.rtl);
  },

  moveCursorUp: function moveCursorUp() {
    this._moveCursor(-1);
  },

  moveCursorDown: function moveCursorDown() {
    this._moveCursor(+1);
  },

  getDatumForSuggestion: function getDatumForSuggestion($el) {
    var datum = null;

    if ($el.length) {
      datum = {
        raw: Dataset.extractDatum($el),
        value: Dataset.extractValue($el),
        datasetName: Dataset.extractDatasetName($el)
      };
    }

    return datum;
  },

  getCurrentCursor: function getCurrentCursor() {
    return this._getCursor().first();
  },

  getDatumForCursor: function getDatumForCursor() {
    return this.getDatumForSuggestion(this._getCursor().first());
  },

  getDatumForTopSuggestion: function getDatumForTopSuggestion() {
    return this.getDatumForSuggestion(this._getSuggestions().first());
  },

  cursorTopSuggestion: function cursorTopSuggestion() {
    this._setCursor(this._getSuggestions().first(), false);
  },

  update: function update(query) {
    _.each(this.datasets, updateDataset);

    function updateDataset(dataset) {
      dataset.update(query);
    }
  },

  empty: function empty() {
    _.each(this.datasets, clearDataset);
    this.isEmpty = true;

    function clearDataset(dataset) {
      dataset.clear();
    }
  },

  isVisible: function isVisible() {
    return this.isOpen && !this.isEmpty;
  },

  destroy: function destroy() {
    this.$menu.off('.aa');

    this.$menu = null;

    _.each(this.datasets, destroyDataset);

    function destroyDataset(dataset) {
      dataset.destroy();
    }
  }
});

// helper functions
// ----------------
Dropdown.Dataset = Dataset;

function initializeDataset($menu, oDataset, cssClasses) {
  return new Dropdown.Dataset(_.mixin({$menu: $menu, cssClasses: cssClasses}, oDataset));
}

module.exports = Dropdown;

},{"../common/dom.js":12,"../common/utils.js":14,"./css.js":4,"./dataset.js":5,"./event_emitter.js":8}],7:[function(require,module,exports){
'use strict';

var namespace = 'autocomplete:';

var _ = require('../common/utils.js');
var DOM = require('../common/dom.js');

// constructor
// -----------

function EventBus(o) {
  if (!o || !o.el) {
    _.error('EventBus initialized without el');
  }

  this.$el = DOM.element(o.el);
}

// instance methods
// ----------------

_.mixin(EventBus.prototype, {

  // ### public

  trigger: function(type, suggestion, dataset, context) {
    var event = _.Event(namespace + type);
    this.$el.trigger(event, [suggestion, dataset, context]);
    return event;
  }
});

module.exports = EventBus;

},{"../common/dom.js":12,"../common/utils.js":14}],8:[function(require,module,exports){
'use strict';

var immediate = require('immediate');
var splitter = /\s+/;

module.exports = {
  onSync: onSync,
  onAsync: onAsync,
  off: off,
  trigger: trigger
};

function on(method, types, cb, context) {
  var type;

  if (!cb) {
    return this;
  }

  types = types.split(splitter);
  cb = context ? bindContext(cb, context) : cb;

  this._callbacks = this._callbacks || {};

  while (type = types.shift()) {
    this._callbacks[type] = this._callbacks[type] || {sync: [], async: []};
    this._callbacks[type][method].push(cb);
  }

  return this;
}

function onAsync(types, cb, context) {
  return on.call(this, 'async', types, cb, context);
}

function onSync(types, cb, context) {
  return on.call(this, 'sync', types, cb, context);
}

function off(types) {
  var type;

  if (!this._callbacks) {
    return this;
  }

  types = types.split(splitter);

  while (type = types.shift()) {
    delete this._callbacks[type];
  }

  return this;
}

function trigger(types) {
  var type;
  var callbacks;
  var args;
  var syncFlush;
  var asyncFlush;

  if (!this._callbacks) {
    return this;
  }

  types = types.split(splitter);
  args = [].slice.call(arguments, 1);

  while ((type = types.shift()) && (callbacks = this._callbacks[type])) { // eslint-disable-line
    syncFlush = getFlush(callbacks.sync, this, [type].concat(args));
    asyncFlush = getFlush(callbacks.async, this, [type].concat(args));

    if (syncFlush()) {
      immediate(asyncFlush);
    }
  }

  return this;
}

function getFlush(callbacks, context, args) {
  return flush;

  function flush() {
    var cancelled;

    for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
      // only cancel if the callback explicitly returns false
      cancelled = callbacks[i].apply(context, args) === false;
    }

    return !cancelled;
  }
}

function bindContext(fn, context) {
  return fn.bind ?
    fn.bind(context) :
    function() { fn.apply(context, [].slice.call(arguments, 0)); };
}

},{"immediate":23}],9:[function(require,module,exports){
'use strict';

module.exports = {
  wrapper: '<span class="%ROOT%"></span>',
  dropdown: '<span class="%PREFIX%%DROPDOWN_MENU%"></span>',
  dataset: '<div class="%PREFIX%%DATASET%-%CLASS%"></div>',
  suggestions: '<span class="%PREFIX%%SUGGESTIONS%"></span>',
  suggestion: '<div class="%PREFIX%%SUGGESTION%"></div>'
};

},{}],10:[function(require,module,exports){
'use strict';

var specialKeyCodeMap;

specialKeyCodeMap = {
  9: 'tab',
  27: 'esc',
  37: 'left',
  39: 'right',
  13: 'enter',
  38: 'up',
  40: 'down'
};

var _ = require('../common/utils.js');
var DOM = require('../common/dom.js');
var EventEmitter = require('./event_emitter.js');

// constructor
// -----------

function Input(o) {
  var that = this;
  var onBlur;
  var onFocus;
  var onKeydown;
  var onInput;

  o = o || {};

  if (!o.input) {
    _.error('input is missing');
  }

  // bound functions
  onBlur = _.bind(this._onBlur, this);
  onFocus = _.bind(this._onFocus, this);
  onKeydown = _.bind(this._onKeydown, this);
  onInput = _.bind(this._onInput, this);

  this.$hint = DOM.element(o.hint);
  this.$input = DOM.element(o.input)
    .on('blur.aa', onBlur)
    .on('focus.aa', onFocus)
    .on('keydown.aa', onKeydown);

  // if no hint, noop all the hint related functions
  if (this.$hint.length === 0) {
    this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
  }

  // ie7 and ie8 don't support the input event
  // ie9 doesn't fire the input event when characters are removed
  // not sure if ie10 is compatible
  if (!_.isMsie()) {
    this.$input.on('input.aa', onInput);
  } else {
    this.$input.on('keydown.aa keypress.aa cut.aa paste.aa', function($e) {
      // if a special key triggered this, ignore it
      if (specialKeyCodeMap[$e.which || $e.keyCode]) {
        return;
      }

      // give the browser a chance to update the value of the input
      // before checking to see if the query changed
      _.defer(_.bind(that._onInput, that, $e));
    });
  }

  // the query defaults to whatever the value of the input is
  // on initialization, it'll most likely be an empty string
  this.query = this.$input.val();

  // helps with calculating the width of the input's value
  this.$overflowHelper = buildOverflowHelper(this.$input);
}

// static methods
// --------------

Input.normalizeQuery = function(str) {
  // strips leading whitespace and condenses all whitespace
  return (str || '').replace(/^\s*/g, '').replace(/\s{2,}/g, ' ');
};

// instance methods
// ----------------

_.mixin(Input.prototype, EventEmitter, {

  // ### private

  _onBlur: function onBlur() {
    this.resetInputValue();
    this.$input.removeAttr('aria-activedescendant');
    this.trigger('blurred');
  },

  _onFocus: function onFocus() {
    this.trigger('focused');
  },

  _onKeydown: function onKeydown($e) {
    // which is normalized and consistent (but not for ie)
    var keyName = specialKeyCodeMap[$e.which || $e.keyCode];

    this._managePreventDefault(keyName, $e);
    if (keyName && this._shouldTrigger(keyName, $e)) {
      this.trigger(keyName + 'Keyed', $e);
    }
  },

  _onInput: function onInput() {
    this._checkInputValue();
  },

  _managePreventDefault: function managePreventDefault(keyName, $e) {
    var preventDefault;
    var hintValue;
    var inputValue;

    switch (keyName) {
    case 'tab':
      hintValue = this.getHint();
      inputValue = this.getInputValue();

      preventDefault = hintValue &&
        hintValue !== inputValue &&
        !withModifier($e);
      break;

    case 'up':
    case 'down':
      preventDefault = !withModifier($e);
      break;

    default:
      preventDefault = false;
    }

    if (preventDefault) {
      $e.preventDefault();
    }
  },

  _shouldTrigger: function shouldTrigger(keyName, $e) {
    var trigger;

    switch (keyName) {
    case 'tab':
      trigger = !withModifier($e);
      break;

    default:
      trigger = true;
    }

    return trigger;
  },

  _checkInputValue: function checkInputValue() {
    var inputValue;
    var areEquivalent;
    var hasDifferentWhitespace;

    inputValue = this.getInputValue();
    areEquivalent = areQueriesEquivalent(inputValue, this.query);
    hasDifferentWhitespace = areEquivalent && this.query ?
      this.query.length !== inputValue.length : false;

    this.query = inputValue;

    if (!areEquivalent) {
      this.trigger('queryChanged', this.query);
    } else if (hasDifferentWhitespace) {
      this.trigger('whitespaceChanged', this.query);
    }
  },

  // ### public

  focus: function focus() {
    this.$input.focus();
  },

  blur: function blur() {
    this.$input.blur();
  },

  getQuery: function getQuery() {
    return this.query;
  },

  setQuery: function setQuery(query) {
    this.query = query;
  },

  getInputValue: function getInputValue() {
    return this.$input.val();
  },

  setInputValue: function setInputValue(value, silent) {
    if (typeof value === 'undefined') {
      value = this.query;
    }
    this.$input.val(value);

    // silent prevents any additional events from being triggered
    if (silent) {
      this.clearHint();
    } else {
      this._checkInputValue();
    }
  },

  expand: function expand() {
    this.$input.attr('aria-expanded', 'true');
  },

  collapse: function collapse() {
    this.$input.attr('aria-expanded', 'false');
  },

  setActiveDescendant: function setActiveDescendant(activedescendantId) {
    this.$input.attr('aria-activedescendant', activedescendantId);
  },

  removeActiveDescendant: function removeActiveDescendant() {
    this.$input.removeAttr('aria-activedescendant');
  },

  resetInputValue: function resetInputValue() {
    this.setInputValue(this.query, true);
  },

  getHint: function getHint() {
    return this.$hint.val();
  },

  setHint: function setHint(value) {
    this.$hint.val(value);
  },

  clearHint: function clearHint() {
    this.setHint('');
  },

  clearHintIfInvalid: function clearHintIfInvalid() {
    var val;
    var hint;
    var valIsPrefixOfHint;
    var isValid;

    val = this.getInputValue();
    hint = this.getHint();
    valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
    isValid = val !== '' && valIsPrefixOfHint && !this.hasOverflow();

    if (!isValid) {
      this.clearHint();
    }
  },

  getLanguageDirection: function getLanguageDirection() {
    return (this.$input.css('direction') || 'ltr').toLowerCase();
  },

  hasOverflow: function hasOverflow() {
    // 2 is arbitrary, just picking a small number to handle edge cases
    var constraint = this.$input.width() - 2;

    this.$overflowHelper.text(this.getInputValue());

    return this.$overflowHelper.width() >= constraint;
  },

  isCursorAtEnd: function() {
    var valueLength;
    var selectionStart;
    var range;

    valueLength = this.$input.val().length;
    selectionStart = this.$input[0].selectionStart;

    if (_.isNumber(selectionStart)) {
      return selectionStart === valueLength;
    } else if (document.selection) {
      // NOTE: this won't work unless the input has focus, the good news
      // is this code should only get called when the input has focus
      range = document.selection.createRange();
      range.moveStart('character', -valueLength);

      return valueLength === range.text.length;
    }

    return true;
  },

  destroy: function destroy() {
    this.$hint.off('.aa');
    this.$input.off('.aa');

    this.$hint = this.$input = this.$overflowHelper = null;
  }
});

// helper functions
// ----------------

function buildOverflowHelper($input) {
  return DOM.element('<pre aria-hidden="true"></pre>')
    .css({
      // position helper off-screen
      position: 'absolute',
      visibility: 'hidden',
      // avoid line breaks and whitespace collapsing
      whiteSpace: 'pre',
      // use same font css as input to calculate accurate width
      fontFamily: $input.css('font-family'),
      fontSize: $input.css('font-size'),
      fontStyle: $input.css('font-style'),
      fontVariant: $input.css('font-variant'),
      fontWeight: $input.css('font-weight'),
      wordSpacing: $input.css('word-spacing'),
      letterSpacing: $input.css('letter-spacing'),
      textIndent: $input.css('text-indent'),
      textRendering: $input.css('text-rendering'),
      textTransform: $input.css('text-transform')
    })
    .insertAfter($input);
}

function areQueriesEquivalent(a, b) {
  return Input.normalizeQuery(a) === Input.normalizeQuery(b);
}

function withModifier($e) {
  return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
}

module.exports = Input;

},{"../common/dom.js":12,"../common/utils.js":14,"./event_emitter.js":8}],11:[function(require,module,exports){
'use strict';

var attrsKey = 'aaAttrs';

var _ = require('../common/utils.js');
var DOM = require('../common/dom.js');
var EventBus = require('./event_bus.js');
var Input = require('./input.js');
var Dropdown = require('./dropdown.js');
var html = require('./html.js');
var css = require('./css.js');

// constructor
// -----------

// THOUGHT: what if datasets could dynamically be added/removed?
function Typeahead(o) {
  var $menu;
  var $hint;

  o = o || {};

  if (!o.input) {
    _.error('missing input');
  }

  this.isActivated = false;
  this.debug = !!o.debug;
  this.autoselect = !!o.autoselect;
  this.autoselectOnBlur = !!o.autoselectOnBlur;
  this.openOnFocus = !!o.openOnFocus;
  this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
  this.autoWidth = (o.autoWidth === undefined) ? true : !!o.autoWidth;
  this.clearOnSelected = !!o.clearOnSelected;
  this.tabAutocomplete = (o.tabAutocomplete === undefined) ? true : !!o.tabAutocomplete;

  o.hint = !!o.hint;

  if (o.hint && o.appendTo) {
    throw new Error('[autocomplete.js] hint and appendTo options can\'t be used at the same time');
  }

  this.css = o.css = _.mixin({}, css, o.appendTo ? css.appendTo : {});
  this.cssClasses = o.cssClasses = _.mixin({}, css.defaultClasses, o.cssClasses || {});
  this.cssClasses.prefix =
    o.cssClasses.formattedPrefix = _.formatPrefix(this.cssClasses.prefix, this.cssClasses.noPrefix);
  this.listboxId = o.listboxId = [this.cssClasses.root, 'listbox', _.getUniqueId()].join('-');

  var domElts = buildDom(o);

  this.$node = domElts.wrapper;
  var $input = this.$input = domElts.input;
  $menu = domElts.menu;
  $hint = domElts.hint;

  if (o.dropdownMenuContainer) {
    DOM.element(o.dropdownMenuContainer)
      .css('position', 'relative') // ensure the container has a relative position
      .append($menu.css('top', '0')); // override the top: 100%
  }

  // #705: if there's scrollable overflow, ie doesn't support
  // blur cancellations when the scrollbar is clicked
  //
  // #351: preventDefault won't cancel blurs in ie <= 8
  $input.on('blur.aa', function($e) {
    var active = document.activeElement;
    if (_.isMsie() && ($menu[0] === active || $menu[0].contains(active))) {
      $e.preventDefault();
      // stop immediate in order to prevent Input#_onBlur from
      // getting exectued
      $e.stopImmediatePropagation();
      _.defer(function() { $input.focus(); });
    }
  });

  // #351: prevents input blur due to clicks within dropdown menu
  $menu.on('mousedown.aa', function($e) { $e.preventDefault(); });

  this.eventBus = o.eventBus || new EventBus({el: $input});

  this.dropdown = new Typeahead.Dropdown({
    appendTo: o.appendTo,
    wrapper: this.$node,
    menu: $menu,
    datasets: o.datasets,
    templates: o.templates,
    cssClasses: o.cssClasses,
    minLength: this.minLength
  })
    .onSync('suggestionClicked', this._onSuggestionClicked, this)
    .onSync('cursorMoved', this._onCursorMoved, this)
    .onSync('cursorRemoved', this._onCursorRemoved, this)
    .onSync('opened', this._onOpened, this)
    .onSync('closed', this._onClosed, this)
    .onSync('shown', this._onShown, this)
    .onSync('empty', this._onEmpty, this)
    .onSync('redrawn', this._onRedrawn, this)
    .onAsync('datasetRendered', this._onDatasetRendered, this);

  this.input = new Typeahead.Input({input: $input, hint: $hint})
    .onSync('focused', this._onFocused, this)
    .onSync('blurred', this._onBlurred, this)
    .onSync('enterKeyed', this._onEnterKeyed, this)
    .onSync('tabKeyed', this._onTabKeyed, this)
    .onSync('escKeyed', this._onEscKeyed, this)
    .onSync('upKeyed', this._onUpKeyed, this)
    .onSync('downKeyed', this._onDownKeyed, this)
    .onSync('leftKeyed', this._onLeftKeyed, this)
    .onSync('rightKeyed', this._onRightKeyed, this)
    .onSync('queryChanged', this._onQueryChanged, this)
    .onSync('whitespaceChanged', this._onWhitespaceChanged, this);

  this._bindKeyboardShortcuts(o);

  this._setLanguageDirection();
}

// instance methods
// ----------------

_.mixin(Typeahead.prototype, {
  // ### private

  _bindKeyboardShortcuts: function(options) {
    if (!options.keyboardShortcuts) {
      return;
    }
    var $input = this.$input;
    var keyboardShortcuts = [];
    _.each(options.keyboardShortcuts, function(key) {
      if (typeof key === 'string') {
        key = key.toUpperCase().charCodeAt(0);
      }
      keyboardShortcuts.push(key);
    });
    DOM.element(document).keydown(function(event) {
      var elt = (event.target || event.srcElement);
      var tagName = elt.tagName;
      if (elt.isContentEditable || tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA') {
        // already in an input
        return;
      }

      var which = event.which || event.keyCode;
      if (keyboardShortcuts.indexOf(which) === -1) {
        // not the right shortcut
        return;
      }

      $input.focus();
      event.stopPropagation();
      event.preventDefault();
    });
  },

  _onSuggestionClicked: function onSuggestionClicked(type, $el) {
    var datum;
    var context = {selectionMethod: 'click'};

    if (datum = this.dropdown.getDatumForSuggestion($el)) {
      this._select(datum, context);
    }
  },

  _onCursorMoved: function onCursorMoved(event, updateInput) {
    var datum = this.dropdown.getDatumForCursor();
    var currentCursorId = this.dropdown.getCurrentCursor().attr('id');
    this.input.setActiveDescendant(currentCursorId);

    if (datum) {
      if (updateInput) {
        this.input.setInputValue(datum.value, true);
      }

      this.eventBus.trigger('cursorchanged', datum.raw, datum.datasetName);
    }
  },

  _onCursorRemoved: function onCursorRemoved() {
    this.input.resetInputValue();
    this._updateHint();
    this.eventBus.trigger('cursorremoved');
  },

  _onDatasetRendered: function onDatasetRendered() {
    this._updateHint();

    this.eventBus.trigger('updated');
  },

  _onOpened: function onOpened() {
    this._updateHint();
    this.input.expand();

    this.eventBus.trigger('opened');
  },

  _onEmpty: function onEmpty() {
    this.eventBus.trigger('empty');
  },

  _onRedrawn: function onRedrawn() {
    this.$node.css('top', 0 + 'px');
    this.$node.css('left', 0 + 'px');

    var inputRect = this.$input[0].getBoundingClientRect();

    if (this.autoWidth) {
      this.$node.css('width', inputRect.width + 'px');
    }

    var wrapperRect = this.$node[0].getBoundingClientRect();

    var top = inputRect.bottom - wrapperRect.top;
    this.$node.css('top', top + 'px');
    var left = inputRect.left - wrapperRect.left;
    this.$node.css('left', left + 'px');

    this.eventBus.trigger('redrawn');
  },

  _onShown: function onShown() {
    this.eventBus.trigger('shown');
    if (this.autoselect) {
      this.dropdown.cursorTopSuggestion();
    }
  },

  _onClosed: function onClosed() {
    this.input.clearHint();
    this.input.removeActiveDescendant();
    this.input.collapse();

    this.eventBus.trigger('closed');
  },

  _onFocused: function onFocused() {
    this.isActivated = true;

    if (this.openOnFocus) {
      var query = this.input.getQuery();
      if (query.length >= this.minLength) {
        this.dropdown.update(query);
      } else {
        this.dropdown.empty();
      }

      this.dropdown.open();
    }
  },

  _onBlurred: function onBlurred() {
    var cursorDatum;
    var topSuggestionDatum;

    cursorDatum = this.dropdown.getDatumForCursor();
    topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();
    var context = {selectionMethod: 'blur'};

    if (!this.debug) {
      if (this.autoselectOnBlur && cursorDatum) {
        this._select(cursorDatum, context);
      } else if (this.autoselectOnBlur && topSuggestionDatum) {
        this._select(topSuggestionDatum, context);
      } else {
        this.isActivated = false;
        this.dropdown.empty();
        this.dropdown.close();
      }
    }
  },

  _onEnterKeyed: function onEnterKeyed(type, $e) {
    var cursorDatum;
    var topSuggestionDatum;

    cursorDatum = this.dropdown.getDatumForCursor();
    topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();
    var context = {selectionMethod: 'enterKey'};

    if (cursorDatum) {
      this._select(cursorDatum, context);
      $e.preventDefault();
    } else if (this.autoselect && topSuggestionDatum) {
      this._select(topSuggestionDatum, context);
      $e.preventDefault();
    }
  },

  _onTabKeyed: function onTabKeyed(type, $e) {
    if (!this.tabAutocomplete) {
      // Closing the dropdown enables further tabbing
      this.dropdown.close();
      return;
    }

    var datum;
    var context = {selectionMethod: 'tabKey'};

    if (datum = this.dropdown.getDatumForCursor()) {
      this._select(datum, context);
      $e.preventDefault();
    } else {
      this._autocomplete(true);
    }
  },

  _onEscKeyed: function onEscKeyed() {
    this.dropdown.close();
    this.input.resetInputValue();
  },

  _onUpKeyed: function onUpKeyed() {
    var query = this.input.getQuery();

    if (this.dropdown.isEmpty && query.length >= this.minLength) {
      this.dropdown.update(query);
    } else {
      this.dropdown.moveCursorUp();
    }

    this.dropdown.open();
  },

  _onDownKeyed: function onDownKeyed() {
    var query = this.input.getQuery();

    if (this.dropdown.isEmpty && query.length >= this.minLength) {
      this.dropdown.update(query);
    } else {
      this.dropdown.moveCursorDown();
    }

    this.dropdown.open();
  },

  _onLeftKeyed: function onLeftKeyed() {
    if (this.dir === 'rtl') {
      this._autocomplete();
    }
  },

  _onRightKeyed: function onRightKeyed() {
    if (this.dir === 'ltr') {
      this._autocomplete();
    }
  },

  _onQueryChanged: function onQueryChanged(e, query) {
    this.input.clearHintIfInvalid();

    if (query.length >= this.minLength) {
      this.dropdown.update(query);
    } else {
      this.dropdown.empty();
    }

    this.dropdown.open();
    this._setLanguageDirection();
  },

  _onWhitespaceChanged: function onWhitespaceChanged() {
    this._updateHint();
    this.dropdown.open();
  },

  _setLanguageDirection: function setLanguageDirection() {
    var dir = this.input.getLanguageDirection();

    if (this.dir !== dir) {
      this.dir = dir;
      this.$node.css('direction', dir);
      this.dropdown.setLanguageDirection(dir);
    }
  },

  _updateHint: function updateHint() {
    var datum;
    var val;
    var query;
    var escapedQuery;
    var frontMatchRegEx;
    var match;

    datum = this.dropdown.getDatumForTopSuggestion();

    if (datum && this.dropdown.isVisible() && !this.input.hasOverflow()) {
      val = this.input.getInputValue();
      query = Input.normalizeQuery(val);
      escapedQuery = _.escapeRegExChars(query);

      // match input value, then capture trailing text
      frontMatchRegEx = new RegExp('^(?:' + escapedQuery + ')(.+$)', 'i');
      match = frontMatchRegEx.exec(datum.value);

      // clear hint if there's no trailing text
      if (match) {
        this.input.setHint(val + match[1]);
      } else {
        this.input.clearHint();
      }
    } else {
      this.input.clearHint();
    }
  },

  _autocomplete: function autocomplete(laxCursor) {
    var hint;
    var query;
    var isCursorAtEnd;
    var datum;

    hint = this.input.getHint();
    query = this.input.getQuery();
    isCursorAtEnd = laxCursor || this.input.isCursorAtEnd();

    if (hint && query !== hint && isCursorAtEnd) {
      datum = this.dropdown.getDatumForTopSuggestion();
      if (datum) {
        this.input.setInputValue(datum.value);
      }

      this.eventBus.trigger('autocompleted', datum.raw, datum.datasetName);
    }
  },

  _select: function select(datum, context) {
    if (typeof datum.value !== 'undefined') {
      this.input.setQuery(datum.value);
    }
    if (this.clearOnSelected) {
      this.setVal('');
    } else {
      this.input.setInputValue(datum.value, true);
    }

    this._setLanguageDirection();

    var event = this.eventBus.trigger('selected', datum.raw, datum.datasetName, context);
    if (event.isDefaultPrevented() === false) {
      this.dropdown.close();

      // #118: allow click event to bubble up to the body before removing
      // the suggestions otherwise we break event delegation
      _.defer(_.bind(this.dropdown.empty, this.dropdown));
    }
  },

  // ### public

  open: function open() {
    // if the menu is not activated yet, we need to update
    // the underlying dropdown menu to trigger the search
    // otherwise we're not gonna see anything
    if (!this.isActivated) {
      var query = this.input.getInputValue();
      if (query.length >= this.minLength) {
        this.dropdown.update(query);
      } else {
        this.dropdown.empty();
      }
    }
    this.dropdown.open();
  },

  close: function close() {
    this.dropdown.close();
  },

  setVal: function setVal(val) {
    // expect val to be a string, so be safe, and coerce
    val = _.toStr(val);

    if (this.isActivated) {
      this.input.setInputValue(val);
    } else {
      this.input.setQuery(val);
      this.input.setInputValue(val, true);
    }

    this._setLanguageDirection();
  },

  getVal: function getVal() {
    return this.input.getQuery();
  },

  destroy: function destroy() {
    this.input.destroy();
    this.dropdown.destroy();

    destroyDomStructure(this.$node, this.cssClasses);

    this.$node = null;
  },

  getWrapper: function getWrapper() {
    return this.dropdown.$container[0];
  }
});

function buildDom(options) {
  var $input;
  var $wrapper;
  var $dropdown;
  var $hint;

  $input = DOM.element(options.input);
  $wrapper = DOM
    .element(html.wrapper.replace('%ROOT%', options.cssClasses.root))
    .css(options.css.wrapper);

  // override the display property with the table-cell value
  // if the parent element is a table and the original input was a block
  //  -> https://github.com/algolia/autocomplete.js/issues/16
  if (!options.appendTo && $input.css('display') === 'block' && $input.parent().css('display') === 'table') {
    $wrapper.css('display', 'table-cell');
  }
  var dropdownHtml = html.dropdown.
    replace('%PREFIX%', options.cssClasses.prefix).
    replace('%DROPDOWN_MENU%', options.cssClasses.dropdownMenu);
  $dropdown = DOM.element(dropdownHtml)
    .css(options.css.dropdown)
    .attr({
      role: 'listbox',
      id: options.listboxId
    });
  if (options.templates && options.templates.dropdownMenu) {
    $dropdown.html(_.templatify(options.templates.dropdownMenu)());
  }
  $hint = $input.clone().css(options.css.hint).css(getBackgroundStyles($input));

  $hint
    .val('')
    .addClass(_.className(options.cssClasses.prefix, options.cssClasses.hint, true))
    .removeAttr('id name placeholder required')
    .prop('readonly', true)
    .attr({
      'aria-hidden': 'true',
      autocomplete: 'off',
      spellcheck: 'false',
      tabindex: -1
    });
  if ($hint.removeData) {
    $hint.removeData();
  }

  // store the original values of the attrs that get modified
  // so modifications can be reverted on destroy
  $input.data(attrsKey, {
    'aria-autocomplete': $input.attr('aria-autocomplete'),
    'aria-expanded': $input.attr('aria-expanded'),
    'aria-owns': $input.attr('aria-owns'),
    autocomplete: $input.attr('autocomplete'),
    dir: $input.attr('dir'),
    role: $input.attr('role'),
    spellcheck: $input.attr('spellcheck'),
    style: $input.attr('style'),
    type: $input.attr('type')
  });

  $input
    .addClass(_.className(options.cssClasses.prefix, options.cssClasses.input, true))
    .attr({
      autocomplete: 'off',
      spellcheck: false,

      // Accessibility features
      // Give the field a presentation of a "select".
      // Combobox is the combined presentation of a single line textfield
      // with a listbox popup.
      // https://www.w3.org/WAI/PF/aria/roles#combobox
      role: 'combobox',
      // Let the screen reader know the field has an autocomplete
      // feature to it.
      'aria-autocomplete': (options.datasets &&
        options.datasets[0] && options.datasets[0].displayKey ? 'both' : 'list'),
      // Indicates whether the dropdown it controls is currently expanded or collapsed
      'aria-expanded': 'false',
      'aria-label': options.ariaLabel,
      // Explicitly point to the listbox,
      // which is a list of suggestions (aka options)
      'aria-owns': options.listboxId
    })
    .css(options.hint ? options.css.input : options.css.inputWithNoHint);

  // ie7 does not like it when dir is set to auto
  try {
    if (!$input.attr('dir')) {
      $input.attr('dir', 'auto');
    }
  } catch (e) {
    // ignore
  }

  $wrapper = options.appendTo
    ? $wrapper.appendTo(DOM.element(options.appendTo).eq(0)).eq(0)
    : $input.wrap($wrapper).parent();

  $wrapper
    .prepend(options.hint ? $hint : null)
    .append($dropdown);

  return {
    wrapper: $wrapper,
    input: $input,
    hint: $hint,
    menu: $dropdown
  };
}

function getBackgroundStyles($el) {
  return {
    backgroundAttachment: $el.css('background-attachment'),
    backgroundClip: $el.css('background-clip'),
    backgroundColor: $el.css('background-color'),
    backgroundImage: $el.css('background-image'),
    backgroundOrigin: $el.css('background-origin'),
    backgroundPosition: $el.css('background-position'),
    backgroundRepeat: $el.css('background-repeat'),
    backgroundSize: $el.css('background-size')
  };
}

function destroyDomStructure($node, cssClasses) {
  var $input = $node.find(_.className(cssClasses.prefix, cssClasses.input));

  // need to remove attrs that weren't previously defined and
  // revert attrs that originally had a value
  _.each($input.data(attrsKey), function(val, key) {
    if (val === undefined) {
      $input.removeAttr(key);
    } else {
      $input.attr(key, val);
    }
  });

  $input
    .detach()
    .removeClass(_.className(cssClasses.prefix, cssClasses.input, true))
    .insertAfter($node);
  if ($input.removeData) {
    $input.removeData(attrsKey);
  }

  $node.remove();
}

Typeahead.Dropdown = Dropdown;
Typeahead.Input = Input;
Typeahead.sources = require('../sources/index.js');

module.exports = Typeahead;

},{"../common/dom.js":12,"../common/utils.js":14,"../sources/index.js":16,"./css.js":4,"./dropdown.js":6,"./event_bus.js":7,"./html.js":9,"./input.js":10}],12:[function(require,module,exports){
'use strict';

module.exports = {
  element: null
};

},{}],13:[function(require,module,exports){
'use strict';
module.exports = function parseAlgoliaClientVersion(agent) {
  var parsed = agent.match(/Algolia for vanilla JavaScript (\d+\.)(\d+\.)(\d+)/);
  if (parsed) return [parsed[1], parsed[2], parsed[3]];
  return undefined;
};

},{}],14:[function(require,module,exports){
'use strict';

var DOM = require('./dom.js');

function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}

module.exports = {
  // those methods are implemented differently
  // depending on which build it is, using
  // $... or angular... or Zepto... or require(...)
  isArray: null,
  isFunction: null,
  isObject: null,
  bind: null,
  each: null,
  map: null,
  mixin: null,

  isMsie: function(agentString) {
    if (agentString === undefined) { agentString = navigator.userAgent; }
    // from https://github.com/ded/bowser/blob/master/bowser.js
    if ((/(msie|trident)/i).test(agentString)) {
      var match = agentString.match(/(msie |rv:)(\d+(.\d+)?)/i);
      if (match) { return match[2]; }
    }
    return false;
  },

  // http://stackoverflow.com/a/6969486
  escapeRegExChars: function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
  },

  isNumber: function(obj) { return typeof obj === 'number'; },

  toStr: function toStr(s) {
    return s === undefined || s === null ? '' : s + '';
  },

  cloneDeep: function cloneDeep(obj) {
    var clone = this.mixin({}, obj);
    var self = this;
    this.each(clone, function(value, key) {
      if (value) {
        if (self.isArray(value)) {
          clone[key] = [].concat(value);
        } else if (self.isObject(value)) {
          clone[key] = self.cloneDeep(value);
        }
      }
    });
    return clone;
  },

  error: function(msg) {
    throw new Error(msg);
  },

  every: function(obj, test) {
    var result = true;
    if (!obj) {
      return result;
    }
    this.each(obj, function(val, key) {
      if (result) {
        result = test.call(null, val, key, obj) && result;
      }
    });
    return !!result;
  },

  any: function(obj, test) {
    var found = false;
    if (!obj) {
      return found;
    }
    this.each(obj, function(val, key) {
      if (test.call(null, val, key, obj)) {
        found = true;
        return false;
      }
    });
    return found;
  },

  getUniqueId: (function() {
    var counter = 0;
    return function() { return counter++; };
  })(),

  templatify: function templatify(obj) {
    if (this.isFunction(obj)) {
      return obj;
    }
    var $template = DOM.element(obj);
    if ($template.prop('tagName') === 'SCRIPT') {
      return function template() { return $template.text(); };
    }
    return function template() { return String(obj); };
  },

  defer: function(fn) { setTimeout(fn, 0); },

  noop: function() {},

  formatPrefix: function(prefix, noPrefix) {
    return noPrefix ? '' : prefix + '-';
  },

  className: function(prefix, clazz, skipDot) {
    return (skipDot ? '' : '.') + prefix + clazz;
  },

  escapeHighlightedString: function(str, highlightPreTag, highlightPostTag) {
    highlightPreTag = highlightPreTag || '<em>';
    var pre = document.createElement('div');
    pre.appendChild(document.createTextNode(highlightPreTag));

    highlightPostTag = highlightPostTag || '</em>';
    var post = document.createElement('div');
    post.appendChild(document.createTextNode(highlightPostTag));

    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML
      .replace(RegExp(escapeRegExp(pre.innerHTML), 'g'), highlightPreTag)
      .replace(RegExp(escapeRegExp(post.innerHTML), 'g'), highlightPostTag);
  }
};

},{"./dom.js":12}],15:[function(require,module,exports){
'use strict';

var _ = require('../common/utils.js');
var version = require('../../version.js');
var parseAlgoliaClientVersion = require('../common/parseAlgoliaClientVersion.js');

module.exports = function search(index, params) {
  var algoliaVersion = parseAlgoliaClientVersion(index.as._ua);
  if (algoliaVersion && algoliaVersion[0] >= 3 && algoliaVersion[1] > 20) {
    params = params || {};
    params.additionalUA = 'autocomplete.js ' + version;
  }
  return sourceFn;

  function sourceFn(query, cb) {
    index.search(query, params, function(error, content) {
      if (error) {
        _.error(error.message);
        return;
      }
      cb(content.hits, content);
    });
  }
};

},{"../../version.js":19,"../common/parseAlgoliaClientVersion.js":13,"../common/utils.js":14}],16:[function(require,module,exports){
'use strict';

module.exports = {
  hits: require('./hits.js'),
  popularIn: require('./popularIn.js')
};

},{"./hits.js":15,"./popularIn.js":17}],17:[function(require,module,exports){
'use strict';

var _ = require('../common/utils.js');
var version = require('../../version.js');
var parseAlgoliaClientVersion = require('../common/parseAlgoliaClientVersion.js');

module.exports = function popularIn(index, params, details, options) {
  var algoliaVersion = parseAlgoliaClientVersion(index.as._ua);
  if (algoliaVersion && algoliaVersion[0] >= 3 && algoliaVersion[1] > 20) {
    params = params || {};
    params.additionalUA = 'autocomplete.js ' + version;
  }
  if (!details.source) {
    return _.error("Missing 'source' key");
  }
  var source = _.isFunction(details.source) ? details.source : function(hit) { return hit[details.source]; };

  if (!details.index) {
    return _.error("Missing 'index' key");
  }
  var detailsIndex = details.index;

  options = options || {};

  return sourceFn;

  function sourceFn(query, cb) {
    index.search(query, params, function(error, content) {
      if (error) {
        _.error(error.message);
        return;
      }

      if (content.hits.length > 0) {
        var first = content.hits[0];

        var detailsParams = _.mixin({hitsPerPage: 0}, details);
        delete detailsParams.source; // not a query parameter
        delete detailsParams.index; // not a query parameter

        var detailsAlgoliaVersion = parseAlgoliaClientVersion(detailsIndex.as._ua);
        if (detailsAlgoliaVersion && detailsAlgoliaVersion[0] >= 3 && detailsAlgoliaVersion[1] > 20) {
          params.additionalUA = 'autocomplete.js ' + version;
        }

        detailsIndex.search(source(first), detailsParams, function(error2, content2) {
          if (error2) {
            _.error(error2.message);
            return;
          }

          var suggestions = [];

          // add the 'all department' entry before others
          if (options.includeAll) {
            var label = options.allTitle || 'All departments';
            suggestions.push(_.mixin({
              facet: {value: label, count: content2.nbHits}
            }, _.cloneDeep(first)));
          }

          // enrich the first hit iterating over the facets
          _.each(content2.facets, function(values, facet) {
            _.each(values, function(count, value) {
              suggestions.push(_.mixin({
                facet: {facet: facet, value: value, count: count}
              }, _.cloneDeep(first)));
            });
          });

          // append all other hits
          for (var i = 1; i < content.hits.length; ++i) {
            suggestions.push(content.hits[i]);
          }

          cb(suggestions, content);
        });

        return;
      }

      cb([]);
    });
  }
};

},{"../../version.js":19,"../common/parseAlgoliaClientVersion.js":13,"../common/utils.js":14}],18:[function(require,module,exports){
'use strict';

// this will inject Zepto in window, unfortunately no easy commonJS zepto build
var zepto = require('../../zepto.js');

// setup DOM element
var DOM = require('../common/dom.js');
DOM.element = zepto;

// setup utils functions
var _ = require('../common/utils.js');
_.isArray = zepto.isArray;
_.isFunction = zepto.isFunction;
_.isObject = zepto.isPlainObject;
_.bind = zepto.proxy;
_.each = function(collection, cb) {
  // stupid argument order for jQuery.each
  zepto.each(collection, reverseArgs);
  function reverseArgs(index, value) {
    return cb(value, index);
  }
};
_.map = zepto.map;
_.mixin = zepto.extend;
_.Event = zepto.Event;

var typeaheadKey = 'aaAutocomplete';
var Typeahead = require('../autocomplete/typeahead.js');
var EventBus = require('../autocomplete/event_bus.js');

function autocomplete(selector, options, datasets, typeaheadObject) {
  datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 2);

  var inputs = zepto(selector).each(function(i, input) {
    var $input = zepto(input);
    var eventBus = new EventBus({el: $input});
    var typeahead = typeaheadObject || new Typeahead({
      input: $input,
      eventBus: eventBus,
      dropdownMenuContainer: options.dropdownMenuContainer,
      hint: options.hint === undefined ? true : !!options.hint,
      minLength: options.minLength,
      autoselect: options.autoselect,
      autoselectOnBlur: options.autoselectOnBlur,
      tabAutocomplete: options.tabAutocomplete,
      openOnFocus: options.openOnFocus,
      templates: options.templates,
      debug: options.debug,
      clearOnSelected: options.clearOnSelected,
      cssClasses: options.cssClasses,
      datasets: datasets,
      keyboardShortcuts: options.keyboardShortcuts,
      appendTo: options.appendTo,
      autoWidth: options.autoWidth
    });
    $input.data(typeaheadKey, typeahead);
  });

  // expose all methods in the `autocomplete` attribute
  inputs.autocomplete = {};
  _.each(['open', 'close', 'getVal', 'setVal', 'destroy', 'getWrapper'], function(method) {
    inputs.autocomplete[method] = function() {
      var methodArguments = arguments;
      var result;
      inputs.each(function(j, input) {
        var typeahead = zepto(input).data(typeaheadKey);
        result = typeahead[method].apply(typeahead, methodArguments);
      });
      return result;
    };
  });

  return inputs;
}

autocomplete.sources = Typeahead.sources;
autocomplete.escapeHighlightedString = _.escapeHighlightedString;

var wasAutocompleteSet = 'autocomplete' in window;
var oldAutocomplete = window.autocomplete;
autocomplete.noConflict = function noConflict() {
  if (wasAutocompleteSet) {
    window.autocomplete = oldAutocomplete;
  } else {
    delete window.autocomplete;
  }
  return autocomplete;
};

module.exports = autocomplete;

},{"../../zepto.js":20,"../autocomplete/event_bus.js":7,"../autocomplete/typeahead.js":11,"../common/dom.js":12,"../common/utils.js":14}],19:[function(require,module,exports){
module.exports = "0.35.0";

},{}],20:[function(require,module,exports){
/* istanbul ignore next */
/* Zepto v1.2.0 - zepto event assets data - zeptojs.com/license */
(function(global, factory) {
  module.exports = factory(global);
}(/* this ##### UPDATED: here we want to use window/global instead of this which is the current file context ##### */ window, function(window) {
  var Zepto = (function() {
  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,
    document = window.document,
    elementDisplay = {}, classCache = {},
    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },
    fragmentRE = /^\s*<(\w+|!)[^>]*>/,
    singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
    rootNodeRE = /^(?:body|html)$/i,
    capitalRE = /([A-Z])/g,

    // special attributes that should be get/set via method calls
    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],

    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],
    table = document.createElement('table'),
    tableRow = document.createElement('tr'),
    containers = {
      'tr': document.createElement('tbody'),
      'tbody': table, 'thead': table, 'tfoot': table,
      'td': tableRow, 'th': tableRow,
      '*': document.createElement('div')
    },
    readyRE = /complete|loaded|interactive/,
    simpleSelectorRE = /^[\w-]*$/,
    class2type = {},
    toString = class2type.toString,
    zepto = {},
    camelize, uniq,
    tempParent = document.createElement('div'),
    propMap = {
      'tabindex': 'tabIndex',
      'readonly': 'readOnly',
      'for': 'htmlFor',
      'class': 'className',
      'maxlength': 'maxLength',
      'cellspacing': 'cellSpacing',
      'cellpadding': 'cellPadding',
      'rowspan': 'rowSpan',
      'colspan': 'colSpan',
      'usemap': 'useMap',
      'frameborder': 'frameBorder',
      'contenteditable': 'contentEditable'
    },
    isArray = Array.isArray ||
      function(object){ return object instanceof Array }

  zepto.matches = function(element, selector) {
    if (!selector || !element || element.nodeType !== 1) return false
    var matchesSelector = element.matches || element.webkitMatchesSelector ||
                          element.mozMatchesSelector || element.oMatchesSelector ||
                          element.matchesSelector
    if (matchesSelector) return matchesSelector.call(element, selector)
    // fall back to performing a selector:
    var match, parent = element.parentNode, temp = !parent
    if (temp) (parent = tempParent).appendChild(element)
    match = ~zepto.qsa(parent, selector).indexOf(element)
    temp && tempParent.removeChild(element)
    return match
  }

  function type(obj) {
    return obj == null ? String(obj) :
      class2type[toString.call(obj)] || "object"
  }

  function isFunction(value) { return type(value) == "function" }
  function isWindow(obj)     { return obj != null && obj == obj.window }
  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }
  function isObject(obj)     { return type(obj) == "object" }
  function isPlainObject(obj) {
    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype
  }

  function likeArray(obj) {
    var length = !!obj && 'length' in obj && obj.length,
      type = $.type(obj)

    return 'function' != type && !isWindow(obj) && (
      'array' == type || length === 0 ||
        (typeof length == 'number' && length > 0 && (length - 1) in obj)
    )
  }

  function compact(array) { return filter.call(array, function(item){ return item != null }) }
  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }
  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }
  function dasherize(str) {
    return str.replace(/::/g, '/')
           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
           .replace(/([a-z\d])([A-Z])/g, '$1_$2')
           .replace(/_/g, '-')
           .toLowerCase()
  }
  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }

  function classRE(name) {
    return name in classCache ?
      classCache[name] : (classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)'))
  }

  function maybeAddPx(name, value) {
    return (typeof value == "number" && !cssNumber[dasherize(name)]) ? value + "px" : value
  }

  function defaultDisplay(nodeName) {
    var element, display
    if (!elementDisplay[nodeName]) {
      element = document.createElement(nodeName)
      document.body.appendChild(element)
      display = getComputedStyle(element, '').getPropertyValue("display")
      element.parentNode.removeChild(element)
      display == "none" && (display = "block")
      elementDisplay[nodeName] = display
    }
    return elementDisplay[nodeName]
  }

  function children(element) {
    return 'children' in element ?
      slice.call(element.children) :
      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })
  }

  function Z(dom, selector) {
    var i, len = dom ? dom.length : 0
    for (i = 0; i < len; i++) this[i] = dom[i]
    this.length = len
    this.selector = selector || ''
  }

  // `$.zepto.fragment` takes a html string and an optional tag name
  // to generate DOM nodes from the given html string.
  // The generated DOM nodes are returned as an array.
  // This function can be overridden in plugins for example to make
  // it compatible with browsers that don't support the DOM fully.
  zepto.fragment = function(html, name, properties) {
    var dom, nodes, container

    // A special case optimization for a single tag
    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))

    if (!dom) {
      if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>")
      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1
      if (!(name in containers)) name = '*'

      container = containers[name]
      container.innerHTML = '' + html
      dom = $.each(slice.call(container.childNodes), function(){
        container.removeChild(this)
      })
    }

    if (isPlainObject(properties)) {
      nodes = $(dom)
      $.each(properties, function(key, value) {
        if (methodAttributes.indexOf(key) > -1) nodes[key](value)
        else nodes.attr(key, value)
      })
    }

    return dom
  }

  // `$.zepto.Z` swaps out the prototype of the given `dom` array
  // of nodes with `$.fn` and thus supplying all the Zepto functions
  // to the array. This method can be overridden in plugins.
  zepto.Z = function(dom, selector) {
    return new Z(dom, selector)
  }

  // `$.zepto.isZ` should return `true` if the given object is a Zepto
  // collection. This method can be overridden in plugins.
  zepto.isZ = function(object) {
    return object instanceof zepto.Z
  }

  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
  // takes a CSS selector and an optional context (and handles various
  // special cases).
  // This method can be overridden in plugins.
  zepto.init = function(selector, context) {
    var dom
    // If nothing given, return an empty Zepto collection
    if (!selector) return zepto.Z()
    // Optimize for string selectors
    else if (typeof selector == 'string') {
      selector = selector.trim()
      // If it's a html fragment, create nodes from it
      // Note: In both Chrome 21 and Firefox 15, DOM error 12
      // is thrown if the fragment doesn't begin with <
      if (selector[0] == '<' && fragmentRE.test(selector))
        dom = zepto.fragment(selector, RegExp.$1, context), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // If it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
    }
    // If a function is given, call it when the DOM is ready
    else if (isFunction(selector)) return $(document).ready(selector)
    // If a Zepto collection is given, just return it
    else if (zepto.isZ(selector)) return selector
    else {
      // normalize array if an array of nodes is given
      if (isArray(selector)) dom = compact(selector)
      // Wrap DOM nodes.
      else if (isObject(selector))
        dom = [selector], selector = null
      // If it's a html fragment, create nodes from it
      else if (fragmentRE.test(selector))
        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null
      // If there's a context, create a collection on that context first, and select
      // nodes from there
      else if (context !== undefined) return $(context).find(selector)
      // And last but no least, if it's a CSS selector, use it to select nodes.
      else dom = zepto.qsa(document, selector)
    }
    // create a new Zepto collection from the nodes found
    return zepto.Z(dom, selector)
  }

  // `$` will be the base `Zepto` object. When calling this
  // function just call `$.zepto.init, which makes the implementation
  // details of selecting nodes and creating Zepto collections
  // patchable in plugins.
  $ = function(selector, context){
    return zepto.init(selector, context)
  }

  function extend(target, source, deep) {
    for (key in source)
      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key]))
          target[key] = {}
        if (isArray(source[key]) && !isArray(target[key]))
          target[key] = []
        extend(target[key], source[key], deep)
      }
      else if (source[key] !== undefined) target[key] = source[key]
  }

  // Copy all but undefined properties from one or more
  // objects to the `target` object.
  $.extend = function(target){
    var deep, args = slice.call(arguments, 1)
    if (typeof target == 'boolean') {
      deep = target
      target = args.shift()
    }
    args.forEach(function(arg){ extend(target, arg, deep) })
    return target
  }

  // `$.zepto.qsa` is Zepto's CSS selector implementation which
  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
  // This method can be overridden in plugins.
  zepto.qsa = function(element, selector){
    var found,
        maybeID = selector[0] == '#',
        maybeClass = !maybeID && selector[0] == '.',
        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked
        isSimple = simpleSelectorRE.test(nameOnly)
    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById
      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :
      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :
      slice.call(
        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName
          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
          element.getElementsByTagName(selector) : // Or a tag
          element.querySelectorAll(selector) // Or it's not simple, and we need to query all
      )
  }

  function filtered(nodes, selector) {
    return selector == null ? $(nodes) : $(nodes).filter(selector)
  }

  $.contains = document.documentElement.contains ?
    function(parent, node) {
      return parent !== node && parent.contains(node)
    } :
    function(parent, node) {
      while (node && (node = node.parentNode))
        if (node === parent) return true
      return false
    }

  function funcArg(context, arg, idx, payload) {
    return isFunction(arg) ? arg.call(context, idx, payload) : arg
  }

  function setAttribute(node, name, value) {
    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)
  }

  // access className property while respecting SVGAnimatedString
  function className(node, value){
    var klass = node.className || '',
        svg   = klass && klass.baseVal !== undefined

    if (value === undefined) return svg ? klass.baseVal : klass
    svg ? (klass.baseVal = value) : (node.className = value)
  }

  // "true"  => true
  // "false" => false
  // "null"  => null
  // "42"    => 42
  // "42.5"  => 42.5
  // "08"    => "08"
  // JSON    => parse if valid
  // String  => self
  function deserializeValue(value) {
    try {
      return value ?
        value == "true" ||
        ( value == "false" ? false :
          value == "null" ? null :
          +value + "" == value ? +value :
          /^[\[\{]/.test(value) ? $.parseJSON(value) :
          value )
        : value
    } catch(e) {
      return value
    }
  }

  $.type = type
  $.isFunction = isFunction
  $.isWindow = isWindow
  $.isArray = isArray
  $.isPlainObject = isPlainObject

  $.isEmptyObject = function(obj) {
    var name
    for (name in obj) return false
    return true
  }

  $.isNumeric = function(val) {
    var num = Number(val), type = typeof val
    return val != null && type != 'boolean' &&
      (type != 'string' || val.length) &&
      !isNaN(num) && isFinite(num) || false
  }

  $.inArray = function(elem, array, i){
    return emptyArray.indexOf.call(array, elem, i)
  }

  $.camelCase = camelize
  $.trim = function(str) {
    return str == null ? "" : String.prototype.trim.call(str)
  }

  // plugin compatibility
  $.uuid = 0
  $.support = { }
  $.expr = { }
  $.noop = function() {}

  $.map = function(elements, callback){
    var value, values = [], i, key
    if (likeArray(elements))
      for (i = 0; i < elements.length; i++) {
        value = callback(elements[i], i)
        if (value != null) values.push(value)
      }
    else
      for (key in elements) {
        value = callback(elements[key], key)
        if (value != null) values.push(value)
      }
    return flatten(values)
  }

  $.each = function(elements, callback){
    var i, key
    if (likeArray(elements)) {
      for (i = 0; i < elements.length; i++)
        if (callback.call(elements[i], i, elements[i]) === false) return elements
    } else {
      for (key in elements)
        if (callback.call(elements[key], key, elements[key]) === false) return elements
    }

    return elements
  }

  $.grep = function(elements, callback){
    return filter.call(elements, callback)
  }

  if (window.JSON) $.parseJSON = JSON.parse

  // Populate the class2type map
  $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase()
  })

  // Define methods that will be available on all
  // Zepto collections
  $.fn = {
    constructor: zepto.Z,
    length: 0,

    // Because a collection acts like an array
    // copy over these useful array functions.
    forEach: emptyArray.forEach,
    reduce: emptyArray.reduce,
    push: emptyArray.push,
    sort: emptyArray.sort,
    splice: emptyArray.splice,
    indexOf: emptyArray.indexOf,
    concat: function(){
      var i, value, args = []
      for (i = 0; i < arguments.length; i++) {
        value = arguments[i]
        args[i] = zepto.isZ(value) ? value.toArray() : value
      }
      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)
    },

    // `map` and `slice` in the jQuery API work differently
    // from their array counterparts
    map: function(fn){
      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))
    },
    slice: function(){
      return $(slice.apply(this, arguments))
    },

    ready: function(callback){
      // need to check if document.body exists for IE as that browser reports
      // document ready when it hasn't yet created the body element
      if (readyRE.test(document.readyState) && document.body) callback($)
      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)
      return this
    },
    get: function(idx){
      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
    },
    toArray: function(){ return this.get() },
    size: function(){
      return this.length
    },
    remove: function(){
      return this.each(function(){
        if (this.parentNode != null)
          this.parentNode.removeChild(this)
      })
    },
    each: function(callback){
      emptyArray.every.call(this, function(el, idx){
        return callback.call(el, idx, el) !== false
      })
      return this
    },
    filter: function(selector){
      if (isFunction(selector)) return this.not(this.not(selector))
      return $(filter.call(this, function(element){
        return zepto.matches(element, selector)
      }))
    },
    add: function(selector,context){
      return $(uniq(this.concat($(selector,context))))
    },
    is: function(selector){
      return this.length > 0 && zepto.matches(this[0], selector)
    },
    not: function(selector){
      var nodes=[]
      if (isFunction(selector) && selector.call !== undefined)
        this.each(function(idx){
          if (!selector.call(this,idx)) nodes.push(this)
        })
      else {
        var excludes = typeof selector == 'string' ? this.filter(selector) :
          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)
        this.forEach(function(el){
          if (excludes.indexOf(el) < 0) nodes.push(el)
        })
      }
      return $(nodes)
    },
    has: function(selector){
      return this.filter(function(){
        return isObject(selector) ?
          $.contains(this, selector) :
          $(this).find(selector).size()
      })
    },
    eq: function(idx){
      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
    },
    first: function(){
      var el = this[0]
      return el && !isObject(el) ? el : $(el)
    },
    last: function(){
      var el = this[this.length - 1]
      return el && !isObject(el) ? el : $(el)
    },
    find: function(selector){
      var result, $this = this
      if (!selector) result = $()
      else if (typeof selector == 'object')
        result = $(selector).filter(function(){
          var node = this
          return emptyArray.some.call($this, function(parent){
            return $.contains(parent, node)
          })
        })
      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))
      else result = this.map(function(){ return zepto.qsa(this, selector) })
      return result
    },
    closest: function(selector, context){
      var nodes = [], collection = typeof selector == 'object' && $(selector)
      this.each(function(_, node){
        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))
          node = node !== context && !isDocument(node) && node.parentNode
        if (node && nodes.indexOf(node) < 0) nodes.push(node)
      })
      return $(nodes)
    },
    parents: function(selector){
      var ancestors = [], nodes = this
      while (nodes.length > 0)
        nodes = $.map(nodes, function(node){
          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
            ancestors.push(node)
            return node
          }
        })
      return filtered(ancestors, selector)
    },
    parent: function(selector){
      return filtered(uniq(this.pluck('parentNode')), selector)
    },
    children: function(selector){
      return filtered(this.map(function(){ return children(this) }), selector)
    },
    contents: function() {
      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })
    },
    siblings: function(selector){
      return filtered(this.map(function(i, el){
        return filter.call(children(el.parentNode), function(child){ return child!==el })
      }), selector)
    },
    empty: function(){
      return this.each(function(){ this.innerHTML = '' })
    },
    // `pluck` is borrowed from Prototype.js
    pluck: function(property){
      return $.map(this, function(el){ return el[property] })
    },
    show: function(){
      return this.each(function(){
        this.style.display == "none" && (this.style.display = '')
        if (getComputedStyle(this, '').getPropertyValue("display") == "none")
          this.style.display = defaultDisplay(this.nodeName)
      })
    },
    replaceWith: function(newContent){
      return this.before(newContent).remove()
    },
    wrap: function(structure){
      var func = isFunction(structure)
      if (this[0] && !func)
        var dom   = $(structure).get(0),
            clone = dom.parentNode || this.length > 1

      return this.each(function(index){
        $(this).wrapAll(
          func ? structure.call(this, index) :
            clone ? dom.cloneNode(true) : dom
        )
      })
    },
    wrapAll: function(structure){
      if (this[0]) {
        $(this[0]).before(structure = $(structure))
        var children
        // drill down to the inmost element
        while ((children = structure.children()).length) structure = children.first()
        $(structure).append(this)
      }
      return this
    },
    wrapInner: function(structure){
      var func = isFunction(structure)
      return this.each(function(index){
        var self = $(this), contents = self.contents(),
            dom  = func ? structure.call(this, index) : structure
        contents.length ? contents.wrapAll(dom) : self.append(dom)
      })
    },
    unwrap: function(){
      this.parent().each(function(){
        $(this).replaceWith($(this).children())
      })
      return this
    },
    clone: function(){
      return this.map(function(){ return this.cloneNode(true) })
    },
    hide: function(){
      return this.css("display", "none")
    },
    toggle: function(setting){
      return this.each(function(){
        var el = $(this)
        ;(setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide()
      })
    },
    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },
    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },
    html: function(html){
      return 0 in arguments ?
        this.each(function(idx){
          var originHtml = this.innerHTML
          $(this).empty().append( funcArg(this, html, idx, originHtml) )
        }) :
        (0 in this ? this[0].innerHTML : null)
    },
    text: function(text){
      return 0 in arguments ?
        this.each(function(idx){
          var newText = funcArg(this, text, idx, this.textContent)
          this.textContent = newText == null ? '' : ''+newText
        }) :
        (0 in this ? this.pluck('textContent').join("") : null)
    },
    attr: function(name, value){
      var result
      return (typeof name == 'string' && !(1 in arguments)) ?
        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :
        this.each(function(idx){
          if (this.nodeType !== 1) return
          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])
          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))
        })
    },
    removeAttr: function(name){
      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){
        setAttribute(this, attribute)
      }, this)})
    },
    prop: function(name, value){
      name = propMap[name] || name
      return (1 in arguments) ?
        this.each(function(idx){
          this[name] = funcArg(this, value, idx, this[name])
        }) :
        (this[0] && this[0][name])
    },
    removeProp: function(name){
      name = propMap[name] || name
      return this.each(function(){ delete this[name] })
    },
    data: function(name, value){
      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()

      var data = (1 in arguments) ?
        this.attr(attrName, value) :
        this.attr(attrName)

      return data !== null ? deserializeValue(data) : undefined
    },
    val: function(value){
      if (0 in arguments) {
        if (value == null) value = ""
        return this.each(function(idx){
          this.value = funcArg(this, value, idx, this.value)
        })
      } else {
        return this[0] && (this[0].multiple ?
           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :
           this[0].value)
      }
    },
    offset: function(coordinates){
      if (coordinates) return this.each(function(index){
        var $this = $(this),
            coords = funcArg(this, coordinates, index, $this.offset()),
            parentOffset = $this.offsetParent().offset(),
            props = {
              top:  coords.top  - parentOffset.top,
              left: coords.left - parentOffset.left
            }

        if ($this.css('position') == 'static') props['position'] = 'relative'
        $this.css(props)
      })
      if (!this.length) return null
      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))
        return {top: 0, left: 0}
      var obj = this[0].getBoundingClientRect()
      return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
      }
    },
    css: function(property, value){
      if (arguments.length < 2) {
        var element = this[0]
        if (typeof property == 'string') {
          if (!element) return
          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)
        } else if (isArray(property)) {
          if (!element) return
          var props = {}
          var computedStyle = getComputedStyle(element, '')
          $.each(property, function(_, prop){
            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))
          })
          return props
        }
      }

      var css = ''
      if (type(property) == 'string') {
        if (!value && value !== 0)
          this.each(function(){ this.style.removeProperty(dasherize(property)) })
        else
          css = dasherize(property) + ":" + maybeAddPx(property, value)
      } else {
        for (key in property)
          if (!property[key] && property[key] !== 0)
            this.each(function(){ this.style.removeProperty(dasherize(key)) })
          else
            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'
      }

      return this.each(function(){ this.style.cssText += ';' + css })
    },
    index: function(element){
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
    },
    hasClass: function(name){
      if (!name) return false
      return emptyArray.some.call(this, function(el){
        return this.test(className(el))
      }, classRE(name))
    },
    addClass: function(name){
      if (!name) return this
      return this.each(function(idx){
        if (!('className' in this)) return
        classList = []
        var cls = className(this), newName = funcArg(this, name, idx, cls)
        newName.split(/\s+/g).forEach(function(klass){
          if (!$(this).hasClass(klass)) classList.push(klass)
        }, this)
        classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "))
      })
    },
    removeClass: function(name){
      return this.each(function(idx){
        if (!('className' in this)) return
        if (name === undefined) return className(this, '')
        classList = className(this)
        funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
          classList = classList.replace(classRE(klass), " ")
        })
        className(this, classList.trim())
      })
    },
    toggleClass: function(name, when){
      if (!name) return this
      return this.each(function(idx){
        var $this = $(this), names = funcArg(this, name, idx, className(this))
        names.split(/\s+/g).forEach(function(klass){
          (when === undefined ? !$this.hasClass(klass) : when) ?
            $this.addClass(klass) : $this.removeClass(klass)
        })
      })
    },
    scrollTop: function(value){
      if (!this.length) return
      var hasScrollTop = 'scrollTop' in this[0]
      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset
      return this.each(hasScrollTop ?
        function(){ this.scrollTop = value } :
        function(){ this.scrollTo(this.scrollX, value) })
    },
    scrollLeft: function(value){
      if (!this.length) return
      var hasScrollLeft = 'scrollLeft' in this[0]
      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset
      return this.each(hasScrollLeft ?
        function(){ this.scrollLeft = value } :
        function(){ this.scrollTo(value, this.scrollY) })
    },
    position: function() {
      if (!this.length) return

      var elem = this[0],
        // Get *real* offsetParent
        offsetParent = this.offsetParent(),
        // Get correct offsets
        offset       = this.offset(),
        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0
      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0

      // Add offsetParent borders
      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0
      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0

      // Subtract the two offsets
      return {
        top:  offset.top  - parentOffset.top,
        left: offset.left - parentOffset.left
      }
    },
    offsetParent: function() {
      return this.map(function(){
        var parent = this.offsetParent || document.body
        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static")
          parent = parent.offsetParent
        return parent
      })
    }
  }

  // for now
  $.fn.detach = $.fn.remove

  // Generate the `width` and `height` functions
  ;['width', 'height'].forEach(function(dimension){
    var dimensionProperty =
      dimension.replace(/./, function(m){ return m[0].toUpperCase() })

    $.fn[dimension] = function(value){
      var offset, el = this[0]
      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :
        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :
        (offset = this.offset()) && offset[dimension]
      else return this.each(function(idx){
        el = $(this)
        el.css(dimension, funcArg(this, value, idx, el[dimension]()))
      })
    }
  })

  function traverseNode(node, fun) {
    fun(node)
    for (var i = 0, len = node.childNodes.length; i < len; i++)
      traverseNode(node.childNodes[i], fun)
  }

  // Generate the `after`, `prepend`, `before`, `append`,
  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
  adjacencyOperators.forEach(function(operator, operatorIndex) {
    var inside = operatorIndex % 2 //=> prepend, append

    $.fn[operator] = function(){
      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
      var argType, nodes = $.map(arguments, function(arg) {
            var arr = []
            argType = type(arg)
            if (argType == "array") {
              arg.forEach(function(el) {
                if (el.nodeType !== undefined) return arr.push(el)
                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())
                arr = arr.concat(zepto.fragment(el))
              })
              return arr
            }
            return argType == "object" || arg == null ?
              arg : zepto.fragment(arg)
          }),
          parent, copyByClone = this.length > 1
      if (nodes.length < 1) return this

      return this.each(function(_, target){
        parent = inside ? target : target.parentNode

        // convert all methods to a "before" operation
        target = operatorIndex == 0 ? target.nextSibling :
                 operatorIndex == 1 ? target.firstChild :
                 operatorIndex == 2 ? target :
                 null

        var parentInDocument = $.contains(document.documentElement, parent)

        nodes.forEach(function(node){
          if (copyByClone) node = node.cloneNode(true)
          else if (!parent) return $(node).remove()

          parent.insertBefore(node, target)
          if (parentInDocument) traverseNode(node, function(el){
            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&
               (!el.type || el.type === 'text/javascript') && !el.src){
              var target = el.ownerDocument ? el.ownerDocument.defaultView : window
              target['eval'].call(target, el.innerHTML)
            }
          })
        })
      })
    }

    // after    => insertAfter
    // prepend  => prependTo
    // before   => insertBefore
    // append   => appendTo
    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){
      $(html)[operator](this)
      return this
    }
  })

  zepto.Z.prototype = Z.prototype = $.fn

  // Export internal API functions in the `$.zepto` namespace
  zepto.uniq = uniq
  zepto.deserializeValue = deserializeValue
  $.zepto = zepto

  return $
})()

;(function($){
  var _zid = 1, undefined,
      slice = Array.prototype.slice,
      isFunction = $.isFunction,
      isString = function(obj){ return typeof obj == 'string' },
      handlers = {},
      specialEvents={},
      focusinSupported = 'onfocusin' in window,
      focus = { focus: 'focusin', blur: 'focusout' },
      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }

  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'

  function zid(element) {
    return element._zid || (element._zid = _zid++)
  }
  function findHandlers(element, event, fn, selector) {
    event = parse(event)
    if (event.ns) var matcher = matcherFor(event.ns)
    return (handlers[zid(element)] || []).filter(function(handler) {
      return handler
        && (!event.e  || handler.e == event.e)
        && (!event.ns || matcher.test(handler.ns))
        && (!fn       || zid(handler.fn) === zid(fn))
        && (!selector || handler.sel == selector)
    })
  }
  function parse(event) {
    var parts = ('' + event).split('.')
    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}
  }
  function matcherFor(ns) {
    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
  }

  function eventCapture(handler, captureSetting) {
    return handler.del &&
      (!focusinSupported && (handler.e in focus)) ||
      !!captureSetting
  }

  function realEvent(type) {
    return hover[type] || (focusinSupported && focus[type]) || type
  }

  function add(element, events, fn, data, selector, delegator, capture){
    var id = zid(element), set = (handlers[id] || (handlers[id] = []))
    events.split(/\s/).forEach(function(event){
      if (event == 'ready') return $(document).ready(fn)
      var handler   = parse(event)
      handler.fn    = fn
      handler.sel   = selector
      // emulate mouseenter, mouseleave
      if (handler.e in hover) fn = function(e){
        var related = e.relatedTarget
        if (!related || (related !== this && !$.contains(this, related)))
          return handler.fn.apply(this, arguments)
      }
      handler.del   = delegator
      var callback  = delegator || fn
      handler.proxy = function(e){
        e = compatible(e)
        if (e.isImmediatePropagationStopped()) return
        try {
          var dataPropDescriptor = Object.getOwnPropertyDescriptor(e, 'data')
          if (!dataPropDescriptor || dataPropDescriptor.writable)
            e.data = data
        } catch (e) {} // when using strict mode dataPropDescriptor will be undefined when e is InputEvent (even though data property exists). So we surround with try/catch
        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))
        if (result === false) e.preventDefault(), e.stopPropagation()
        return result
      }
      handler.i = set.length
      set.push(handler)
      if ('addEventListener' in element)
        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
    })
  }
  function remove(element, events, fn, selector, capture){
    var id = zid(element)
    ;(events || '').split(/\s/).forEach(function(event){
      findHandlers(element, event, fn, selector).forEach(function(handler){
        delete handlers[id][handler.i]
      if ('removeEventListener' in element)
        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
      })
    })
  }

  $.event = { add: add, remove: remove }

  $.proxy = function(fn, context) {
    var args = (2 in arguments) && slice.call(arguments, 2)
    if (isFunction(fn)) {
      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }
      proxyFn._zid = zid(fn)
      return proxyFn
    } else if (isString(context)) {
      if (args) {
        args.unshift(fn[context], fn)
        return $.proxy.apply(null, args)
      } else {
        return $.proxy(fn[context], fn)
      }
    } else {
      throw new TypeError("expected function")
    }
  }

  $.fn.bind = function(event, data, callback){
    return this.on(event, data, callback)
  }
  $.fn.unbind = function(event, callback){
    return this.off(event, callback)
  }
  $.fn.one = function(event, selector, data, callback){
    return this.on(event, selector, data, callback, 1)
  }

  var returnTrue = function(){return true},
      returnFalse = function(){return false},
      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
      eventMethods = {
        preventDefault: 'isDefaultPrevented',
        stopImmediatePropagation: 'isImmediatePropagationStopped',
        stopPropagation: 'isPropagationStopped'
      }

  function compatible(event, source) {
    if (source || !event.isDefaultPrevented) {
      source || (source = event)

      $.each(eventMethods, function(name, predicate) {
        var sourceMethod = source[name]
        event[name] = function(){
          this[predicate] = returnTrue
          return sourceMethod && sourceMethod.apply(source, arguments)
        }
        event[predicate] = returnFalse
      })

      event.timeStamp || (event.timeStamp = Date.now())

      if (source.defaultPrevented !== undefined ? source.defaultPrevented :
          'returnValue' in source ? source.returnValue === false :
          source.getPreventDefault && source.getPreventDefault())
        event.isDefaultPrevented = returnTrue
    }
    return event
  }

  function createProxy(event) {
    var key, proxy = { originalEvent: event }
    for (key in event)
      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]

    return compatible(proxy, event)
  }

  $.fn.delegate = function(selector, event, callback){
    return this.on(event, selector, callback)
  }
  $.fn.undelegate = function(selector, event, callback){
    return this.off(event, selector, callback)
  }

  $.fn.live = function(event, callback){
    $(document.body).delegate(this.selector, event, callback)
    return this
  }
  $.fn.die = function(event, callback){
    $(document.body).undelegate(this.selector, event, callback)
    return this
  }

  $.fn.on = function(event, selector, data, callback, one){
    var autoRemove, delegator, $this = this
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.on(type, selector, data, fn, one)
      })
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      callback = data, data = selector, selector = undefined
    if (callback === undefined || data === false)
      callback = data, data = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(_, element){
      if (one) autoRemove = function(e){
        remove(element, e.type, callback)
        return callback.apply(this, arguments)
      }

      if (selector) delegator = function(e){
        var evt, match = $(e.target).closest(selector, element).get(0)
        if (match && match !== element) {
          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})
          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))
        }
      }

      add(element, event, callback, data, selector, delegator || autoRemove)
    })
  }
  $.fn.off = function(event, selector, callback){
    var $this = this
    if (event && !isString(event)) {
      $.each(event, function(type, fn){
        $this.off(type, selector, fn)
      })
      return $this
    }

    if (!isString(selector) && !isFunction(callback) && callback !== false)
      callback = selector, selector = undefined

    if (callback === false) callback = returnFalse

    return $this.each(function(){
      remove(this, event, callback, selector)
    })
  }

  $.fn.trigger = function(event, args){
    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)
    event._args = args
    return this.each(function(){
      // handle focus(), blur() by calling them directly
      if (event.type in focus && typeof this[event.type] == "function") this[event.type]()
      // items in the collection might not be DOM elements
      else if ('dispatchEvent' in this) this.dispatchEvent(event)
      else $(this).triggerHandler(event, args)
    })
  }

  // triggers event handlers on current element just as if an event occurred,
  // doesn't trigger an actual event, doesn't bubble
  $.fn.triggerHandler = function(event, args){
    var e, result
    this.each(function(i, element){
      e = createProxy(isString(event) ? $.Event(event) : event)
      e._args = args
      e.target = element
      $.each(findHandlers(element, event.type || event), function(i, handler){
        result = handler.proxy(e)
        if (e.isImmediatePropagationStopped()) return false
      })
    })
    return result
  }

  // shortcut methods for `.bind(event, fn)` for each event type
  ;('focusin focusout focus blur load resize scroll unload click dblclick '+
  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+
  'change select keydown keypress keyup error').split(' ').forEach(function(event) {
    $.fn[event] = function(callback) {
      return (0 in arguments) ?
        this.bind(event, callback) :
        this.trigger(event)
    }
  })

  $.Event = function(type, props) {
    if (!isString(type)) props = type, type = props.type
    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true
    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])
    event.initEvent(type, bubbles, true)
    return compatible(event)
  }

})(Zepto)

;(function($){
  var cache = [], timeout

  $.fn.remove = function(){
    return this.each(function(){
      if(this.parentNode){
        if(this.tagName === 'IMG'){
          cache.push(this)
          this.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
          if (timeout) clearTimeout(timeout)
          timeout = setTimeout(function(){ cache = [] }, 60000)
        }
        this.parentNode.removeChild(this)
      }
    })
  }
})(Zepto)

;(function($){
  var data = {}, dataAttr = $.fn.data, camelize = $.camelCase,
    exp = $.expando = 'Zepto' + (+new Date()), emptyArray = []

  // Get value from node:
  // 1. first try key as given,
  // 2. then try camelized key,
  // 3. fall back to reading "data-*" attribute.
  function getData(node, name) {
    var id = node[exp], store = id && data[id]
    if (name === undefined) return store || setData(node)
    else {
      if (store) {
        if (name in store) return store[name]
        var camelName = camelize(name)
        if (camelName in store) return store[camelName]
      }
      return dataAttr.call($(node), name)
    }
  }

  // Store value under camelized key on node
  function setData(node, name, value) {
    var id = node[exp] || (node[exp] = ++$.uuid),
      store = data[id] || (data[id] = attributeData(node))
    if (name !== undefined) store[camelize(name)] = value
    return store
  }

  // Read all "data-*" attributes from a node
  function attributeData(node) {
    var store = {}
    $.each(node.attributes || emptyArray, function(i, attr){
      if (attr.name.indexOf('data-') == 0)
        store[camelize(attr.name.replace('data-', ''))] =
          $.zepto.deserializeValue(attr.value)
    })
    return store
  }

  $.fn.data = function(name, value) {
    return value === undefined ?
      // set multiple values via object
      $.isPlainObject(name) ?
        this.each(function(i, node){
          $.each(name, function(key, value){ setData(node, key, value) })
        }) :
        // get value from first element
        (0 in this ? getData(this[0], name) : undefined) :
      // set value on all elements
      this.each(function(){ setData(this, name, value) })
  }

  $.data = function(elem, name, value) {
    return $(elem).data(name, value)
  }

  $.hasData = function(elem) {
    var id = elem[exp], store = id && data[id]
    return store ? !$.isEmptyObject(store) : false
  }

  $.fn.removeData = function(names) {
    if (typeof names == 'string') names = names.split(/\s+/)
    return this.each(function(){
      var id = this[exp], store = id && data[id]
      if (store) $.each(names || store, function(key){
        delete store[names ? camelize(this) : key]
      })
    })
  }

  // Generate extended `remove` and `empty` functions
  ;['remove', 'empty'].forEach(function(methodName){
    var origFn = $.fn[methodName]
    $.fn[methodName] = function() {
      var elements = this.find('*')
      if (methodName === 'remove') elements = elements.add(this)
      elements.removeData()
      return origFn.call(this)
    }
  })
})(Zepto)
  return Zepto
}))

},{}],21:[function(require,module,exports){
/*!
 * Fuse.js v3.4.2 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Fuse", [], factory);
	else if(typeof exports === 'object')
		exports["Fuse"] = factory();
	else
		root["Fuse"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/bitap/bitap_matched_indices.js":
/*!********************************************!*\
  !*** ./src/bitap/bitap_matched_indices.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () {
  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var matchedIndices = [];
  var start = -1;
  var end = -1;
  var i = 0;

  for (var len = matchmask.length; i < len; i += 1) {
    var match = matchmask[i];

    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;

      if (end - start + 1 >= minMatchCharLength) {
        matchedIndices.push([start, end]);
      }

      start = -1;
    }
  } // (i-1 - start) + 1 => i - start


  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    matchedIndices.push([start, i - 1]);
  }

  return matchedIndices;
};

/***/ }),

/***/ "./src/bitap/bitap_pattern_alphabet.js":
/*!*********************************************!*\
  !*** ./src/bitap/bitap_pattern_alphabet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (pattern) {
  var mask = {};
  var len = pattern.length;

  for (var i = 0; i < len; i += 1) {
    mask[pattern.charAt(i)] = 0;
  }

  for (var _i = 0; _i < len; _i += 1) {
    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;
  }

  return mask;
};

/***/ }),

/***/ "./src/bitap/bitap_regex_search.js":
/*!*****************************************!*\
  !*** ./src/bitap/bitap_regex_search.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var SPECIAL_CHARS_REGEX = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;

module.exports = function (text, pattern) {
  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;
  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\$&').replace(tokenSeparator, '|'));
  var matches = text.match(regex);
  var isMatch = !!matches;
  var matchedIndices = [];

  if (isMatch) {
    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {
      var match = matches[i];
      matchedIndices.push([text.indexOf(match), match.length - 1]);
    }
  }

  return {
    // TODO: revisit this score
    score: isMatch ? 0.5 : 1,
    isMatch: isMatch,
    matchedIndices: matchedIndices
  };
};

/***/ }),

/***/ "./src/bitap/bitap_score.js":
/*!**********************************!*\
  !*** ./src/bitap/bitap_score.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (pattern, _ref) {
  var _ref$errors = _ref.errors,
      errors = _ref$errors === void 0 ? 0 : _ref$errors,
      _ref$currentLocation = _ref.currentLocation,
      currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,
      _ref$expectedLocation = _ref.expectedLocation,
      expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? 100 : _ref$distance;
  var accuracy = errors / pattern.length;
  var proximity = Math.abs(expectedLocation - currentLocation);

  if (!distance) {
    // Dodge divide by zero error.
    return proximity ? 1.0 : accuracy;
  }

  return accuracy + proximity / distance;
};

/***/ }),

/***/ "./src/bitap/bitap_search.js":
/*!***********************************!*\
  !*** ./src/bitap/bitap_search.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bitapScore = __webpack_require__(/*! ./bitap_score */ "./src/bitap/bitap_score.js");

var matchedIndices = __webpack_require__(/*! ./bitap_matched_indices */ "./src/bitap/bitap_matched_indices.js");

module.exports = function (text, pattern, patternAlphabet, _ref) {
  var _ref$location = _ref.location,
      location = _ref$location === void 0 ? 0 : _ref$location,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? 100 : _ref$distance,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,
      _ref$findAllMatches = _ref.findAllMatches,
      findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,
      _ref$minMatchCharLeng = _ref.minMatchCharLength,
      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng;
  var expectedLocation = location; // Set starting location at beginning text and initialize the alphabet.

  var textLen = text.length; // Highest score beyond which we give up.

  var currentThreshold = threshold; // Is there a nearby exact match? (speedup)

  var bestLocation = text.indexOf(pattern, expectedLocation);
  var patternLen = pattern.length; // a mask of the matches

  var matchMask = [];

  for (var i = 0; i < textLen; i += 1) {
    matchMask[i] = 0;
  }

  if (bestLocation !== -1) {
    var score = bitapScore(pattern, {
      errors: 0,
      currentLocation: bestLocation,
      expectedLocation: expectedLocation,
      distance: distance
    });
    currentThreshold = Math.min(score, currentThreshold); // What about in the other direction? (speed up)

    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);

    if (bestLocation !== -1) {
      var _score = bitapScore(pattern, {
        errors: 0,
        currentLocation: bestLocation,
        expectedLocation: expectedLocation,
        distance: distance
      });

      currentThreshold = Math.min(_score, currentThreshold);
    }
  } // Reset the best location


  bestLocation = -1;
  var lastBitArr = [];
  var finalScore = 1;
  var binMax = patternLen + textLen;
  var mask = 1 << patternLen - 1;

  for (var _i = 0; _i < patternLen; _i += 1) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from the match location we can stray
    // at this error level.
    var binMin = 0;
    var binMid = binMax;

    while (binMin < binMid) {
      var _score3 = bitapScore(pattern, {
        errors: _i,
        currentLocation: expectedLocation + binMid,
        expectedLocation: expectedLocation,
        distance: distance
      });

      if (_score3 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }

      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    } // Use the result from this iteration as the maximum for the next.


    binMax = binMid;
    var start = Math.max(1, expectedLocation - binMid + 1);
    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen; // Initialize the bit array

    var bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << _i) - 1;

    for (var j = finish; j >= start; j -= 1) {
      var currentLocation = j - 1;
      var charMatch = patternAlphabet[text.charAt(currentLocation)];

      if (charMatch) {
        matchMask[currentLocation] = 1;
      } // First pass: exact match


      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch; // Subsequent passes: fuzzy match

      if (_i !== 0) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }

      if (bitArr[j] & mask) {
        finalScore = bitapScore(pattern, {
          errors: _i,
          currentLocation: currentLocation,
          expectedLocation: expectedLocation,
          distance: distance
        }); // This match will almost certainly be better than any existing match.
        // But check anyway.

        if (finalScore <= currentThreshold) {
          // Indeed it is
          currentThreshold = finalScore;
          bestLocation = currentLocation; // Already passed `loc`, downhill from here on in.

          if (bestLocation <= expectedLocation) {
            break;
          } // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.


          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    } // No hope for a (better) match at greater error levels.


    var _score2 = bitapScore(pattern, {
      errors: _i + 1,
      currentLocation: expectedLocation,
      expectedLocation: expectedLocation,
      distance: distance
    }); // console.log('score', score, finalScore)


    if (_score2 > currentThreshold) {
      break;
    }

    lastBitArr = bitArr;
  } // console.log('FINAL SCORE', finalScore)
  // Count exact matches (those with a score of 0) to be "almost" exact


  return {
    isMatch: bestLocation >= 0,
    score: finalScore === 0 ? 0.001 : finalScore,
    matchedIndices: matchedIndices(matchMask, minMatchCharLength)
  };
};

/***/ }),

/***/ "./src/bitap/index.js":
/*!****************************!*\
  !*** ./src/bitap/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var bitapRegexSearch = __webpack_require__(/*! ./bitap_regex_search */ "./src/bitap/bitap_regex_search.js");

var bitapSearch = __webpack_require__(/*! ./bitap_search */ "./src/bitap/bitap_search.js");

var patternAlphabet = __webpack_require__(/*! ./bitap_pattern_alphabet */ "./src/bitap/bitap_pattern_alphabet.js");

var Bitap =
/*#__PURE__*/
function () {
  function Bitap(pattern, _ref) {
    var _ref$location = _ref.location,
        location = _ref$location === void 0 ? 0 : _ref$location,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? 100 : _ref$distance,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,
        _ref$maxPatternLength = _ref.maxPatternLength,
        maxPatternLength = _ref$maxPatternLength === void 0 ? 32 : _ref$maxPatternLength,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? false : _ref$isCaseSensitive,
        _ref$tokenSeparator = _ref.tokenSeparator,
        tokenSeparator = _ref$tokenSeparator === void 0 ? / +/g : _ref$tokenSeparator,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng;

    _classCallCheck(this, Bitap);

    this.options = {
      location: location,
      distance: distance,
      threshold: threshold,
      maxPatternLength: maxPatternLength,
      isCaseSensitive: isCaseSensitive,
      tokenSeparator: tokenSeparator,
      findAllMatches: findAllMatches,
      minMatchCharLength: minMatchCharLength
    };
    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();

    if (this.pattern.length <= maxPatternLength) {
      this.patternAlphabet = patternAlphabet(this.pattern);
    }
  }

  _createClass(Bitap, [{
    key: "search",
    value: function search(text) {
      if (!this.options.isCaseSensitive) {
        text = text.toLowerCase();
      } // Exact match


      if (this.pattern === text) {
        return {
          isMatch: true,
          score: 0,
          matchedIndices: [[0, text.length - 1]]
        };
      } // When pattern length is greater than the machine word length, just do a a regex comparison


      var _this$options = this.options,
          maxPatternLength = _this$options.maxPatternLength,
          tokenSeparator = _this$options.tokenSeparator;

      if (this.pattern.length > maxPatternLength) {
        return bitapRegexSearch(text, this.pattern, tokenSeparator);
      } // Otherwise, use Bitap algorithm


      var _this$options2 = this.options,
          location = _this$options2.location,
          distance = _this$options2.distance,
          threshold = _this$options2.threshold,
          findAllMatches = _this$options2.findAllMatches,
          minMatchCharLength = _this$options2.minMatchCharLength;
      return bitapSearch(text, this.pattern, this.patternAlphabet, {
        location: location,
        distance: distance,
        threshold: threshold,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength
      });
    }
  }]);

  return Bitap;
}(); // let x = new Bitap("od mn war", {})
// let result = x.search("Old Man's War")
// console.log(result)


module.exports = Bitap;

/***/ }),

/***/ "./src/helpers/deep_value.js":
/*!***********************************!*\
  !*** ./src/helpers/deep_value.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./is_array */ "./src/helpers/is_array.js");

var deepValue = function deepValue(obj, path, list) {
  if (!path) {
    // If there's no path left, we've gotten to the object we care about.
    list.push(obj);
  } else {
    var dotIndex = path.indexOf('.');
    var firstSegment = path;
    var remaining = null;

    if (dotIndex !== -1) {
      firstSegment = path.slice(0, dotIndex);
      remaining = path.slice(dotIndex + 1);
    }

    var value = obj[firstSegment];

    if (value !== null && value !== undefined) {
      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {
        list.push(value.toString());
      } else if (isArray(value)) {
        // Search each item in the array.
        for (var i = 0, len = value.length; i < len; i += 1) {
          deepValue(value[i], remaining, list);
        }
      } else if (remaining) {
        // An object. Recurse further.
        deepValue(value, remaining, list);
      }
    }
  }

  return list;
};

module.exports = function (obj, path) {
  return deepValue(obj, path, []);
};

/***/ }),

/***/ "./src/helpers/is_array.js":
/*!*********************************!*\
  !*** ./src/helpers/is_array.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (obj) {
  return !Array.isArray ? Object.prototype.toString.call(obj) === '[object Array]' : Array.isArray(obj);
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Bitap = __webpack_require__(/*! ./bitap */ "./src/bitap/index.js");

var deepValue = __webpack_require__(/*! ./helpers/deep_value */ "./src/helpers/deep_value.js");

var isArray = __webpack_require__(/*! ./helpers/is_array */ "./src/helpers/is_array.js");

var Fuse =
/*#__PURE__*/
function () {
  function Fuse(list, _ref) {
    var _ref$location = _ref.location,
        location = _ref$location === void 0 ? 0 : _ref$location,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? 100 : _ref$distance,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? 0.6 : _ref$threshold,
        _ref$maxPatternLength = _ref.maxPatternLength,
        maxPatternLength = _ref$maxPatternLength === void 0 ? 32 : _ref$maxPatternLength,
        _ref$caseSensitive = _ref.caseSensitive,
        caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive,
        _ref$tokenSeparator = _ref.tokenSeparator,
        tokenSeparator = _ref$tokenSeparator === void 0 ? / +/g : _ref$tokenSeparator,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? false : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? 1 : _ref$minMatchCharLeng,
        _ref$id = _ref.id,
        id = _ref$id === void 0 ? null : _ref$id,
        _ref$keys = _ref.keys,
        keys = _ref$keys === void 0 ? [] : _ref$keys,
        _ref$shouldSort = _ref.shouldSort,
        shouldSort = _ref$shouldSort === void 0 ? true : _ref$shouldSort,
        _ref$getFn = _ref.getFn,
        getFn = _ref$getFn === void 0 ? deepValue : _ref$getFn,
        _ref$sortFn = _ref.sortFn,
        sortFn = _ref$sortFn === void 0 ? function (a, b) {
      return a.score - b.score;
    } : _ref$sortFn,
        _ref$tokenize = _ref.tokenize,
        tokenize = _ref$tokenize === void 0 ? false : _ref$tokenize,
        _ref$matchAllTokens = _ref.matchAllTokens,
        matchAllTokens = _ref$matchAllTokens === void 0 ? false : _ref$matchAllTokens,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? false : _ref$includeMatches,
        _ref$includeScore = _ref.includeScore,
        includeScore = _ref$includeScore === void 0 ? false : _ref$includeScore,
        _ref$verbose = _ref.verbose,
        verbose = _ref$verbose === void 0 ? false : _ref$verbose;

    _classCallCheck(this, Fuse);

    this.options = {
      location: location,
      distance: distance,
      threshold: threshold,
      maxPatternLength: maxPatternLength,
      isCaseSensitive: caseSensitive,
      tokenSeparator: tokenSeparator,
      findAllMatches: findAllMatches,
      minMatchCharLength: minMatchCharLength,
      id: id,
      keys: keys,
      includeMatches: includeMatches,
      includeScore: includeScore,
      shouldSort: shouldSort,
      getFn: getFn,
      sortFn: sortFn,
      verbose: verbose,
      tokenize: tokenize,
      matchAllTokens: matchAllTokens
    };
    this.setCollection(list);
  }

  _createClass(Fuse, [{
    key: "setCollection",
    value: function setCollection(list) {
      this.list = list;
      return list;
    }
  }, {
    key: "search",
    value: function search(pattern) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        limit: false
      };

      this._log("---------\nSearch pattern: \"".concat(pattern, "\""));

      var _this$_prepareSearche = this._prepareSearchers(pattern),
          tokenSearchers = _this$_prepareSearche.tokenSearchers,
          fullSearcher = _this$_prepareSearche.fullSearcher;

      var _this$_search = this._search(tokenSearchers, fullSearcher),
          weights = _this$_search.weights,
          results = _this$_search.results;

      this._computeScore(weights, results);

      if (this.options.shouldSort) {
        this._sort(results);
      }

      if (opts.limit && typeof opts.limit === 'number') {
        results = results.slice(0, opts.limit);
      }

      return this._format(results);
    }
  }, {
    key: "_prepareSearchers",
    value: function _prepareSearchers() {
      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var tokenSearchers = [];

      if (this.options.tokenize) {
        // Tokenize on the separator
        var tokens = pattern.split(this.options.tokenSeparator);

        for (var i = 0, len = tokens.length; i < len; i += 1) {
          tokenSearchers.push(new Bitap(tokens[i], this.options));
        }
      }

      var fullSearcher = new Bitap(pattern, this.options);
      return {
        tokenSearchers: tokenSearchers,
        fullSearcher: fullSearcher
      };
    }
  }, {
    key: "_search",
    value: function _search() {
      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var fullSearcher = arguments.length > 1 ? arguments[1] : undefined;
      var list = this.list;
      var resultMap = {};
      var results = []; // Check the first item in the list, if it's a string, then we assume
      // that every item in the list is also a string, and thus it's a flattened array.

      if (typeof list[0] === 'string') {
        // Iterate over every item
        for (var i = 0, len = list.length; i < len; i += 1) {
          this._analyze({
            key: '',
            value: list[i],
            record: i,
            index: i
          }, {
            resultMap: resultMap,
            results: results,
            tokenSearchers: tokenSearchers,
            fullSearcher: fullSearcher
          });
        }

        return {
          weights: null,
          results: results
        };
      } // Otherwise, the first item is an Object (hopefully), and thus the searching
      // is done on the values of the keys of each item.


      var weights = {};

      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {
        var item = list[_i]; // Iterate over every key

        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {
          var key = this.options.keys[j];

          if (typeof key !== 'string') {
            weights[key.name] = {
              weight: 1 - key.weight || 1
            };

            if (key.weight <= 0 || key.weight > 1) {
              throw new Error('Key weight has to be > 0 and <= 1');
            }

            key = key.name;
          } else {
            weights[key] = {
              weight: 1
            };
          }

          this._analyze({
            key: key,
            value: this.options.getFn(item, key),
            record: item,
            index: _i
          }, {
            resultMap: resultMap,
            results: results,
            tokenSearchers: tokenSearchers,
            fullSearcher: fullSearcher
          });
        }
      }

      return {
        weights: weights,
        results: results
      };
    }
  }, {
    key: "_analyze",
    value: function _analyze(_ref2, _ref3) {
      var key = _ref2.key,
          _ref2$arrayIndex = _ref2.arrayIndex,
          arrayIndex = _ref2$arrayIndex === void 0 ? -1 : _ref2$arrayIndex,
          value = _ref2.value,
          record = _ref2.record,
          index = _ref2.index;
      var _ref3$tokenSearchers = _ref3.tokenSearchers,
          tokenSearchers = _ref3$tokenSearchers === void 0 ? [] : _ref3$tokenSearchers,
          _ref3$fullSearcher = _ref3.fullSearcher,
          fullSearcher = _ref3$fullSearcher === void 0 ? [] : _ref3$fullSearcher,
          _ref3$resultMap = _ref3.resultMap,
          resultMap = _ref3$resultMap === void 0 ? {} : _ref3$resultMap,
          _ref3$results = _ref3.results,
          results = _ref3$results === void 0 ? [] : _ref3$results;

      // Check if the texvaluet can be searched
      if (value === undefined || value === null) {
        return;
      }

      var exists = false;
      var averageScore = -1;
      var numTextMatches = 0;

      if (typeof value === 'string') {
        this._log("\nKey: ".concat(key === '' ? '-' : key));

        var mainSearchResult = fullSearcher.search(value);

        this._log("Full text: \"".concat(value, "\", score: ").concat(mainSearchResult.score));

        if (this.options.tokenize) {
          var words = value.split(this.options.tokenSeparator);
          var scores = [];

          for (var i = 0; i < tokenSearchers.length; i += 1) {
            var tokenSearcher = tokenSearchers[i];

            this._log("\nPattern: \"".concat(tokenSearcher.pattern, "\"")); // let tokenScores = []


            var hasMatchInText = false;

            for (var j = 0; j < words.length; j += 1) {
              var word = words[j];
              var tokenSearchResult = tokenSearcher.search(word);
              var obj = {};

              if (tokenSearchResult.isMatch) {
                obj[word] = tokenSearchResult.score;
                exists = true;
                hasMatchInText = true;
                scores.push(tokenSearchResult.score);
              } else {
                obj[word] = 1;

                if (!this.options.matchAllTokens) {
                  scores.push(1);
                }
              }

              this._log("Token: \"".concat(word, "\", score: ").concat(obj[word])); // tokenScores.push(obj)

            }

            if (hasMatchInText) {
              numTextMatches += 1;
            }
          }

          averageScore = scores[0];
          var scoresLen = scores.length;

          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {
            averageScore += scores[_i2];
          }

          averageScore = averageScore / scoresLen;

          this._log('Token score average:', averageScore);
        }

        var finalScore = mainSearchResult.score;

        if (averageScore > -1) {
          finalScore = (finalScore + averageScore) / 2;
        }

        this._log('Score average:', finalScore);

        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;

        this._log("\nCheck Matches: ".concat(checkTextMatches)); // If a match is found, add the item to <rawResults>, including its score


        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {
          // Check if the item already exists in our results
          var existingResult = resultMap[index];

          if (existingResult) {
            // Use the lowest score
            // existingResult.score, bitapResult.score
            existingResult.output.push({
              key: key,
              arrayIndex: arrayIndex,
              value: value,
              score: finalScore,
              matchedIndices: mainSearchResult.matchedIndices
            });
          } else {
            // Add it to the raw result list
            resultMap[index] = {
              item: record,
              output: [{
                key: key,
                arrayIndex: arrayIndex,
                value: value,
                score: finalScore,
                matchedIndices: mainSearchResult.matchedIndices
              }]
            };
            results.push(resultMap[index]);
          }
        }
      } else if (isArray(value)) {
        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {
          this._analyze({
            key: key,
            arrayIndex: _i3,
            value: value[_i3],
            record: record,
            index: index
          }, {
            resultMap: resultMap,
            results: results,
            tokenSearchers: tokenSearchers,
            fullSearcher: fullSearcher
          });
        }
      }
    }
  }, {
    key: "_computeScore",
    value: function _computeScore(weights, results) {
      this._log('\n\nComputing score:\n');

      for (var i = 0, len = results.length; i < len; i += 1) {
        var output = results[i].output;
        var scoreLen = output.length;
        var currScore = 1;
        var bestScore = 1;

        for (var j = 0; j < scoreLen; j += 1) {
          var weight = weights ? weights[output[j].key].weight : 1;
          var score = weight === 1 ? output[j].score : output[j].score || 0.001;
          var nScore = score * weight;

          if (weight !== 1) {
            bestScore = Math.min(bestScore, nScore);
          } else {
            output[j].nScore = nScore;
            currScore *= nScore;
          }
        }

        results[i].score = bestScore === 1 ? currScore : bestScore;

        this._log(results[i]);
      }
    }
  }, {
    key: "_sort",
    value: function _sort(results) {
      this._log('\n\nSorting....');

      results.sort(this.options.sortFn);
    }
  }, {
    key: "_format",
    value: function _format(results) {
      var finalOutput = [];

      if (this.options.verbose) {
        var cache = [];

        this._log('\n\nOutput:\n\n', JSON.stringify(results, function (key, value) {
          if (_typeof(value) === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            } // Store value in our collection


            cache.push(value);
          }

          return value;
        }));

        cache = null;
      }

      var transformers = [];

      if (this.options.includeMatches) {
        transformers.push(function (result, data) {
          var output = result.output;
          data.matches = [];

          for (var i = 0, len = output.length; i < len; i += 1) {
            var item = output[i];

            if (item.matchedIndices.length === 0) {
              continue;
            }

            var obj = {
              indices: item.matchedIndices,
              value: item.value
            };

            if (item.key) {
              obj.key = item.key;
            }

            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {
              obj.arrayIndex = item.arrayIndex;
            }

            data.matches.push(obj);
          }
        });
      }

      if (this.options.includeScore) {
        transformers.push(function (result, data) {
          data.score = result.score;
        });
      }

      for (var i = 0, len = results.length; i < len; i += 1) {
        var result = results[i];

        if (this.options.id) {
          result.item = this.options.getFn(result.item, this.options.id)[0];
        }

        if (!transformers.length) {
          finalOutput.push(result.item);
          continue;
        }

        var data = {
          item: result.item
        };

        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {
          transformers[j](result, data);
        }

        finalOutput.push(data);
      }

      return finalOutput;
    }
  }, {
    key: "_log",
    value: function _log() {
      if (this.options.verbose) {
        var _console;

        (_console = console).log.apply(_console, arguments);
      }
    }
  }]);

  return Fuse;
}();

module.exports = Fuse;

/***/ })

/******/ });
});
},{}],22:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],23:[function(require,module,exports){
'use strict';
var types = [
  require('./nextTick'),
  require('./mutation.js'),
  require('./messageChannel'),
  require('./stateChange'),
  require('./timeout')
];
var draining;
var currentQueue;
var queueIndex = -1;
var queue = [];
var scheduled = false;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    nextTick();
  }
}

//named nextTick for less confusing stack traces
function nextTick() {
  if (draining) {
    return;
  }
  scheduled = false;
  draining = true;
  var len = queue.length;
  var timeout = setTimeout(cleanUpNextTick);
  while (len) {
    currentQueue = queue;
    queue = [];
    while (currentQueue && ++queueIndex < len) {
      currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  queueIndex = -1;
  draining = false;
  clearTimeout(timeout);
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  var fun = this.fun;
  var array = this.array;
  switch (array.length) {
  case 0:
    return fun();
  case 1:
    return fun(array[0]);
  case 2:
    return fun(array[0], array[1]);
  case 3:
    return fun(array[0], array[1], array[2]);
  default:
    return fun.apply(null, array);
  }

};
module.exports = immediate;
function immediate(task) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(task, args));
  if (!scheduled && !draining) {
    scheduled = true;
    scheduleDrain();
  }
}

},{"./messageChannel":24,"./mutation.js":25,"./nextTick":26,"./stateChange":27,"./timeout":28}],24:[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],25:[function(require,module,exports){
(function (global){
'use strict';
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],26:[function(require,module,exports){
(function (process){
'use strict';
exports.test = function () {
  // Don't get fooled by e.g. browserify environments.
  return (typeof process !== 'undefined') && !process.browser;
};

exports.install = function (func) {
  return function () {
    process.nextTick(func);
  };
};

}).call(this,require('_process'))
},{"_process":1}],27:[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],28:[function(require,module,exports){
'use strict';
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};
},{}],29:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = __importDefault(require("ol/map"));
var image_1 = __importDefault(require("ol/layer/image"));
var view_1 = __importDefault(require("ol/view"));
var extent_1 = __importDefault(require("ol/extent"));
var overlay_1 = __importDefault(require("ol/overlay"));
var vector_1 = __importDefault(require("ol/layer/vector"));
var imagestatic_1 = __importDefault(require("ol/source/imagestatic"));
var vector_2 = __importDefault(require("ol/source/vector"));
var projection_1 = __importDefault(require("ol/proj/projection"));
var feature_1 = __importDefault(require("ol/feature"));
var point_1 = __importDefault(require("ol/geom/point"));
var polygon_1 = __importDefault(require("ol/geom/polygon"));
var style_1 = __importDefault(require("ol/style/style"));
var icon_1 = __importDefault(require("ol/style/icon"));
var text_1 = __importDefault(require("ol/style/text"));
var stroke_1 = __importDefault(require("ol/style/stroke"));
var fill_1 = __importDefault(require("ol/style/fill"));
var interaction_1 = __importDefault(require("ol/interaction"));
var _config;
/** Internal map obects */
var map;
var view;
var vectorLayer;
var imlayer;
var imExtent;
var imProjection;
/** Attributions to show on map */
var attributions;
/** GPS following */
var followingUser = false;
/** Geolocation id of watch */
var geoLocationId;
/** Last known geolocation */
var geoLocationLast;
/** Whether to show residences on map */
var showResidences = false;
/** Model to convert lat-lng to pixel coords */
var MAP_Xn = 19.133691;
var MAP_Yn = 72.916984;
var MAP_Zn = 4189;
var MAP_Zyn = 1655;
var MAP_WEIGHTS_X = [
    -7.769917472065843,
    159.26978694839946,
    244.46989575495544,
    -6.003894110679995,
    -0.28864271213341297,
    0.010398324019718075,
    4.215508849724247,
    -0.6078830146963545,
    -7.0400449629241395
];
var MAP_WEIGHTS_Y = [
    14.199431377059842,
    -158.80601990819815,
    68.9630034040724,
    5.796703402034644,
    1.1348242200568706,
    0.11891051684489184,
    -0.2930832938484276,
    0.1448231125788526,
    -5.282895700923075
];
/** Make and get the map. Call only once. */
function getMap(config, locations, locationSelectCallback, mapLoadedCallback) {
    _config = config;
    /* Make features array */
    var features = [];
    for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
        var loc = locations_1[_i];
        /* Change coordinate sysetm */
        var pos = [loc.pixel_x, 3575 - loc.pixel_y];
        /* Ignore inner locations */
        if (loc.parent === null) {
            /* Make the Feature */
            var iconFeature = new feature_1.default({
                geometry: new point_1.default(pos),
                loc: loc
            });
            /* Push into array */
            features.push(iconFeature);
        }
    }
    /* Make vector source and layer from features */
    var vectorSource = new vector_2.default({
        features: features
    });
    /* Style the vector layer */
    var vectorLayerStyle = function (feature) {
        var zoom = map.getView().getZoom();
        var loc = feature.get('loc');
        /* Hide residences */
        if (loc.group_id === 3 && !showResidences) {
            return;
        }
        /* Increase font size with zoom */
        var font_size = zoom * 3;
        /* Choose short name if present */
        var loc_name = loc.name;
        if (loc.short_name !== '0') {
            loc_name = loc.short_name;
        }
        /* Choose icon color based on group id */
        var icon_color;
        if (loc.group_id === 1 || loc.group_id === 4 || loc.group_id === 12) {
            icon_color = 'blue';
        }
        else if (loc.group_id === 3) {
            icon_color = 'green';
        }
        else if (loc.group_id === 2) {
            icon_color = 'yellow';
        }
        else {
            icon_color = 'gray';
        }
        /* Make text object */
        var text = new text_1.default({
            offsetY: 20,
            padding: [20, 20, 20, 20],
            font: font_size + "px Roboto",
            text: loc_name,
            fill: new fill_1.default({
                color: '#ffffff'
            }),
            stroke: new stroke_1.default({
                color: '#444', width: 3
            })
        });
        /* Icon image*/
        var icon = new icon_1.default({
            src: _config.markersBase + "marker_dot_" + icon_color + ".png",
            scale: 0.2
        });
        /* Make style */
        var style = new style_1.default({
            image: (zoom >= 3) ? icon : undefined,
            text: (zoom >= 4) ? text : undefined,
        });
        return [style];
    };
    vectorLayer = new vector_1.default({
        source: vectorSource,
        style: vectorLayerStyle
    });
    /* Configure map */
    imExtent = [0, 0, 5430, 3575];
    imProjection = new projection_1.default({
        code: 'instiMAP',
        units: 'pixels',
        extent: imExtent
    });
    var staticSource = new imagestatic_1.default({
        url: config.mapMinPath,
        attributions: attributions,
        projection: imProjection,
        imageExtent: imExtent,
        imageLoadFunction: function (image, src) {
            /* For showing loading spinner */
            var img = image.getImage();
            img.src = src;
            img.onload = function () {
                loadHighRes();
                mapLoadedCallback();
            };
        }
    });
    /* Make image layer */
    imlayer = new image_1.default({
        source: staticSource
    });
    /* Disable tilting */
    var interactions = interaction_1.default.defaults({ altShiftDragRotate: false, pinchRotate: false });
    /* Make view */
    view = new view_1.default({
        projection: imProjection,
        center: extent_1.default.getCenter(imExtent),
        zoom: 3.4,
        minZoom: 2,
        maxZoom: 5.5,
        extent: [300, 300, 5000, 3000]
    });
    /* Generate map */
    map = new map_1.default({
        interactions: interactions,
        layers: [
            imlayer,
            vectorLayer
        ],
        target: _config.map_id,
        view: view,
        controls: []
    });
    /* Handle click */
    map.on('click', function (evt) {
        /* Create extent of acceptable click */
        var pixel = evt.pixel;
        var pixelOffSet = 30;
        var pixelWithOffsetMin = [pixel[0] - pixelOffSet, pixel[1] + pixelOffSet];
        var pixelWithOffsetMax = [pixel[0] + pixelOffSet, pixel[1] - pixelOffSet];
        var XYMin = map.getCoordinateFromPixel(pixelWithOffsetMin);
        var XYMax = map.getCoordinateFromPixel(pixelWithOffsetMax);
        var ext = XYMax.concat(XYMin);
        var extentFeat = new feature_1.default(new polygon_1.default([[
                [ext[0], ext[1]],
                [ext[0], ext[3]],
                [ext[2], ext[3]],
                [ext[2], ext[1]],
                [ext[0], ext[1]]
            ]]));
        /* Get first nearby feature */
        var feature = vectorLayer.getSource().forEachFeatureIntersectingExtent(extentFeat.getGeometry().getExtent(), function (f) { return f; });
        /* Zoom in */
        if (feature) {
            var location_1 = feature.get('loc');
            moveToLocation(location_1);
            locationSelectCallback(location_1);
        }
        else {
            moveMarker(-50, -50, false);
            locationSelectCallback();
        }
    });
    /* Change mouse cursor on features */
    map.on('pointermove', function (e) {
        var pixel = map.getEventPixel(e.originalEvent);
        var hit = map.hasFeatureAtPixel(pixel);
        var nativeElem = document.getElementById(_config.map_id);
        if (nativeElem != null) {
            nativeElem.style.cursor = hit ? 'pointer' : 'move';
        }
    });
    /* Stop following the user on drag */
    map.on('pointerdrag', function () {
        followingUser = false;
    });
    return map;
}
exports.getMap = getMap;
/** Move marker to a location */
function moveToLocation(loc) {
    moveMarker(loc.pixel_x, loc.pixel_y, true);
}
exports.moveToLocation = moveToLocation;
/** Move the marker to location */
function moveMarker(x, y, center, markerid) {
    if (center === void 0) { center = true; }
    if (markerid === void 0) { markerid = _config.marker_id; }
    var pos = [Number(x), 3575 - Number(y)];
    var element = document.getElementById(markerid);
    var marker = new overlay_1.default({
        position: pos,
        positioning: 'bottom-center',
        element: element,
        stopEvent: false,
        offset: [0, 0]
    });
    map.addOverlay(marker);
    /* Animate */
    if (center) {
        view.animate({ center: pos });
        view.animate({ zoom: 4.5 });
    }
}
exports.moveMarker = moveMarker;
/** Show/hide residence buildings on map */
function setResidencesVisible(visible) {
    showResidences = visible;
    vectorLayer.getSource().changed();
}
exports.setResidencesVisible = setResidencesVisible;
/** Load the high resolution map */
function loadHighRes() {
    /* High res source */
    var highResSource = new imagestatic_1.default({
        url: _config.mapPath,
        attributions: attributions,
        projection: imProjection,
        imageExtent: imExtent,
    });
    /* Load high resolution image */
    var highRes = new Image();
    highRes.src = _config.mapPath;
    highRes.onload = function () {
        imlayer.setSource(highResSource);
    };
}
/** Determine if we support geolocation */
function hasGeolocation() {
    return navigator.geolocation ? true : false;
}
exports.hasGeolocation = hasGeolocation;
/** Setup a location watch */
function getGPS(failedCallback) {
    if (hasGeolocation()) {
        /* Start following the user */
        followingUser = true;
        /* If we already have permission */
        if (geoLocationId != null) {
            moveGPS(true);
            return;
        }
        /* Get permission and setup a watch */
        geoLocationId = navigator.geolocation.watchPosition(function (position) {
            var follow = followingUser || geoLocationLast == null;
            var l = getMapXY(position);
            if (l.pixel_x > 0 && l.pixel_y > 0 && l.pixel_x < 5430 && l.pixel_y < 5375) {
                geoLocationLast = l;
                moveGPS(follow);
            }
        }, function () { }, {
            enableHighAccuracy: true
        });
    }
    else {
        if (failedCallback) {
            failedCallback();
        }
    }
}
exports.getGPS = getGPS;
/** Center the user marker to last known location */
function moveGPS(center) {
    if (geoLocationLast == null) {
        return;
    }
    moveMarker(geoLocationLast.pixel_x, geoLocationLast.pixel_y, center, _config.user_marker_id);
}
/** Apply regression to get pixel coordinates on InstiMap */
function getMapXY(position) {
    /* Set the origin */
    var x = (position.coords.latitude - MAP_Xn) * 1000;
    var y = (position.coords.longitude - MAP_Yn) * 1000;
    /* Apply the model */
    var A = MAP_WEIGHTS_X;
    var px = Math.round(MAP_Zn + A[0] + A[1] * x + A[2] * y +
        A[3] * x * x + A[4] * x * x * y +
        A[5] * x * x * y * y + A[6] * y * y +
        A[7] * x * y * y + A[8] * x * y);
    A = MAP_WEIGHTS_Y;
    var py = Math.round(MAP_Zyn + A[0] + A[1] * x + A[2] * y +
        A[3] * x * x + A[4] * x * x * y +
        A[5] * x * x * y * y + A[6] * y * y +
        A[7] * x * y * y + A[8] * x * y);
    return { pixel_x: px, pixel_y: py };
}
exports.getMapXY = getMapXY;
/** True if the user is being followed around the map */
function isFollowingUser() {
    return followingUser;
}
exports.isFollowingUser = isFollowingUser;
/** Last known geolocation */
function getGeolocationLast() {
    return geoLocationLast;
}
exports.getGeolocationLast = getGeolocationLast;
/** Call this to remove watches */
function cleanup() {
    if (geoLocationId != null && geoLocationId != undefined) {
        navigator.geolocation.clearWatch(geoLocationId);
    }
}
exports.cleanup = cleanup;

},{"ol/extent":55,"ol/feature":58,"ol/geom/point":82,"ol/geom/polygon":83,"ol/interaction":91,"ol/layer/image":108,"ol/layer/vector":111,"ol/map":116,"ol/overlay":129,"ol/proj/projection":146,"ol/source/imagestatic":211,"ol/source/vector":214,"ol/style/fill":226,"ol/style/icon":227,"ol/style/stroke":234,"ol/style/style":235,"ol/style/text":236,"ol/view":246}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_array_ = {};
/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */

_ol_array_.binarySearch = function (haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || _ol_array_.numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }
  /* Key not found. */


  return found ? low : ~low;
};
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */


_ol_array_.numberSafeCompareFunction = function (a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};
/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */


_ol_array_.includes = function (arr, obj) {
  return arr.indexOf(obj) >= 0;
};
/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */


_ol_array_.linearFindNearest = function (arr, target, direction) {
  var n = arr.length;

  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;

    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }

    return n - 1;
  }
};
/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */


_ol_array_.reverseSubArray = function (arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
};
/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {Array.<VALUE>|VALUE} data The elements or arrays of elements
 *     to add to arr.
 * @template VALUE
 */


_ol_array_.extend = function (arr, data) {
  var i;
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;

  for (i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
};
/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */


_ol_array_.remove = function (arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;

  if (found) {
    arr.splice(i, 1);
  }

  return found;
};
/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE} The element found.
 */


_ol_array_.find = function (arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];

    if (func(value, i, arr)) {
      return value;
    }
  }

  return null;
};
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */


_ol_array_.equals = function (arr1, arr2) {
  var len1 = arr1.length;

  if (len1 !== arr2.length) {
    return false;
  }

  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
};
/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */


_ol_array_.stableSort = function (arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;

  for (i = 0; i < length; i++) {
    tmp[i] = {
      index: i,
      value: arr[i]
    };
  }

  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });

  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
};
/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */


_ol_array_.findIndex = function (arr, func) {
  var index;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
};
/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */


_ol_array_.isSorted = function (arr, opt_func, opt_strict) {
  var compare = opt_func || _ol_array_.numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }

    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
};

exports.default = _ol_array_;

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @implements {oli.AssertionError}
 * @param {number} code Error code.
 */
var _ol_AssertionError_ = function (code) {
  var path = _index2.default.VERSION ? _index2.default.VERSION.split('-')[0] : 'latest';
  /**
   * @type {string}
   */

  this.message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';
  /**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */

  this.code = code;
  this.name = 'AssertionError';
};

_index2.default.inherits(_ol_AssertionError_, Error);

exports.default = _ol_AssertionError_;

},{"./index.js":90}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assertionerror = require("./assertionerror.js");

var _assertionerror2 = _interopRequireDefault(_assertionerror);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_asserts_ = {};
/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */

_ol_asserts_.assert = function (assertion, errorCode) {
  if (!assertion) {
    throw new _assertionerror2.default(errorCode);
  }
};

exports.default = _ol_asserts_;

},{"./assertionerror.js":31}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tilerange = require("./tilerange.js");

var _tilerange2 = _interopRequireDefault(_tilerange);

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

var _tilegrid = require("./tilegrid.js");

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * An attribution for a layer source.
 *
 * Example:
 *
 *     source: new ol.source.OSM({
 *       attributions: [
 *         new ol.Attribution({
 *           html: 'All maps &copy; ' +
 *               '<a href="https://www.opencyclemap.org/">OpenCycleMap</a>'
 *         }),
 *         ol.source.OSM.ATTRIBUTION
 *       ],
 *     ..
 *
 * @constructor
 * @deprecated This class is deprecated and will removed in the next major release.
 * @param {olx.AttributionOptions} options Attribution options.
 * @struct
 * @api
 */
var _ol_Attribution_ = function (options) {
  /**
   * @private
   * @type {string}
   */
  this.html_ = options.html;
  /**
   * @private
   * @type {Object.<string, Array.<ol.TileRange>>}
   */

  this.tileRanges_ = options.tileRanges ? options.tileRanges : null;
};
/**
 * Get the attribution markup.
 * @return {string} The attribution HTML.
 * @api
 */


_ol_Attribution_.prototype.getHTML = function () {
  return this.html_;
};
/**
 * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {boolean} Intersects any tile range.
 */


_ol_Attribution_.prototype.intersectsAnyTileRange = function (tileRanges, tileGrid, projection) {
  if (!this.tileRanges_) {
    return true;
  }

  var i, ii, tileRange, zKey;

  for (zKey in tileRanges) {
    if (!(zKey in this.tileRanges_)) {
      continue;
    }

    tileRange = tileRanges[zKey];
    var testTileRange;

    for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {
      testTileRange = this.tileRanges_[zKey][i];

      if (testTileRange.intersects(tileRange)) {
        return true;
      }

      var extentTileRange = tileGrid.getTileRangeForExtentAndZ(_tilegrid2.default.extentFromProjection(projection), parseInt(zKey, 10));
      var width = extentTileRange.getWidth();

      if (tileRange.minX < extentTileRange.minX || tileRange.maxX > extentTileRange.maxX) {
        if (testTileRange.intersects(new _tilerange2.default(_math2.default.modulo(tileRange.minX, width), _math2.default.modulo(tileRange.maxX, width), tileRange.minY, tileRange.maxY))) {
          return true;
        }

        if (tileRange.getWidth() > width && testTileRange.intersects(extentTileRange)) {
          return true;
        }
      }
    }
  }

  return false;
};

exports.default = _ol_Attribution_;

},{"./math.js":124,"./tilegrid.js":239,"./tilerange.js":242}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_CenterConstraint_ = {};
/**
 * @param {ol.Extent} extent Extent.
 * @return {ol.CenterConstraintType} The constraint.
 */

_ol_CenterConstraint_.createExtent = function (extent) {
  return (
    /**
     * @param {ol.Coordinate|undefined} center Center.
     * @return {ol.Coordinate|undefined} Center.
     */
    function (center) {
      if (center) {
        return [_math2.default.clamp(center[0], extent[0], extent[2]), _math2.default.clamp(center[1], extent[1], extent[3])];
      } else {
        return undefined;
      }
    }
  );
};
/**
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Center.
 */


_ol_CenterConstraint_.none = function (center) {
  return center;
};

exports.default = _ol_CenterConstraint_;

},{"./math.js":124}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _assertionerror = require("./assertionerror.js");

var _assertionerror2 = _interopRequireDefault(_assertionerror);

var _collectioneventtype = require("./collectioneventtype.js");

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _object = require("./object.js");

var _object2 = _interopRequireDefault(_object);

var _event = require("./events/event.js");

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An implementation of Google Maps' MVCArray.
 * @see https://developers.google.com/maps/documentation/javascript/reference
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @constructor
 * @extends {ol.Object}
 * @fires ol.Collection.Event
 * @param {Array.<T>=} opt_array Array.
 * @param {olx.CollectionOptions=} opt_options Collection options.
 * @template T
 * @api
 */
var _ol_Collection_ = function (opt_array, opt_options) {
  _object2.default.call(this);

  var options = opt_options || {};
  /**
   * @private
   * @type {boolean}
   */

  this.unique_ = !!options.unique;
  /**
   * @private
   * @type {!Array.<T>}
   */

  this.array_ = opt_array ? opt_array : [];

  if (this.unique_) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      this.assertUnique_(this.array_[i], i);
    }
  }

  this.updateLength_();
};

_index2.default.inherits(_ol_Collection_, _object2.default);
/**
 * Remove all elements from the collection.
 * @api
 */


_ol_Collection_.prototype.clear = function () {
  while (this.getLength() > 0) {
    this.pop();
  }
};
/**
 * Add elements to the collection.  This pushes each item in the provided array
 * to the end of the collection.
 * @param {!Array.<T>} arr Array.
 * @return {ol.Collection.<T>} This collection.
 * @api
 */


_ol_Collection_.prototype.extend = function (arr) {
  var i, ii;

  for (i = 0, ii = arr.length; i < ii; ++i) {
    this.push(arr[i]);
  }

  return this;
};
/**
 * Iterate over each element, calling the provided callback.
 * @param {function(this: S, T, number, Array.<T>): *} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array). The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 * @api
 */


_ol_Collection_.prototype.forEach = function (f, opt_this) {
  var fn = opt_this ? f.bind(opt_this) : f;
  var array = this.array_;

  for (var i = 0, ii = array.length; i < ii; ++i) {
    fn(array[i], i, array);
  }
};
/**
 * Get a reference to the underlying Array object. Warning: if the array
 * is mutated, no events will be dispatched by the collection, and the
 * collection's "length" property won't be in sync with the actual length
 * of the array.
 * @return {!Array.<T>} Array.
 * @api
 */


_ol_Collection_.prototype.getArray = function () {
  return this.array_;
};
/**
 * Get the element at the provided index.
 * @param {number} index Index.
 * @return {T} Element.
 * @api
 */


_ol_Collection_.prototype.item = function (index) {
  return this.array_[index];
};
/**
 * Get the length of this collection.
 * @return {number} The length of the array.
 * @observable
 * @api
 */


_ol_Collection_.prototype.getLength = function () {
  return (
    /** @type {number} */
    this.get(_ol_Collection_.Property_.LENGTH)
  );
};
/**
 * Insert an element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */


_ol_Collection_.prototype.insertAt = function (index, elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }

  this.array_.splice(index, 0, elem);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.ADD, elem));
};
/**
 * Remove the last element of the collection and return it.
 * Return `undefined` if the collection is empty.
 * @return {T|undefined} Element.
 * @api
 */


_ol_Collection_.prototype.pop = function () {
  return this.removeAt(this.getLength() - 1);
};
/**
 * Insert the provided element at the end of the collection.
 * @param {T} elem Element.
 * @return {number} New length of the collection.
 * @api
 */


_ol_Collection_.prototype.push = function (elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }

  var n = this.getLength();
  this.insertAt(n, elem);
  return this.getLength();
};
/**
 * Remove the first occurrence of an element from the collection.
 * @param {T} elem Element.
 * @return {T|undefined} The removed element or undefined if none found.
 * @api
 */


_ol_Collection_.prototype.remove = function (elem) {
  var arr = this.array_;
  var i, ii;

  for (i = 0, ii = arr.length; i < ii; ++i) {
    if (arr[i] === elem) {
      return this.removeAt(i);
    }
  }

  return undefined;
};
/**
 * Remove the element at the provided index and return it.
 * Return `undefined` if the collection does not contain this index.
 * @param {number} index Index.
 * @return {T|undefined} Value.
 * @api
 */


_ol_Collection_.prototype.removeAt = function (index) {
  var prev = this.array_[index];
  this.array_.splice(index, 1);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.REMOVE, prev));
  return prev;
};
/**
 * Set the element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */


_ol_Collection_.prototype.setAt = function (index, elem) {
  var n = this.getLength();

  if (index < n) {
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }

    var prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.REMOVE, prev));
    this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.ADD, elem));
  } else {
    var j;

    for (j = n; j < index; ++j) {
      this.insertAt(j, undefined);
    }

    this.insertAt(index, elem);
  }
};
/**
 * @private
 */


_ol_Collection_.prototype.updateLength_ = function () {
  this.set(_ol_Collection_.Property_.LENGTH, this.array_.length);
};
/**
 * @private
 * @param {T} elem Element.
 * @param {number=} opt_except Optional index to ignore.
 */


_ol_Collection_.prototype.assertUnique_ = function (elem, opt_except) {
  for (var i = 0, ii = this.array_.length; i < ii; ++i) {
    if (this.array_[i] === elem && i !== opt_except) {
      throw new _assertionerror2.default(58);
    }
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_Collection_.Property_ = {
  LENGTH: 'length'
};
/**
 * @classdesc
 * Events emitted by {@link ol.Collection} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.Collection.Event}
 * @param {ol.CollectionEventType} type Type.
 * @param {*=} opt_element Element.
 */

_ol_Collection_.Event = function (type, opt_element) {
  _event2.default.call(this, type);
  /**
   * The element that is added to or removed from the collection.
   * @type {*}
   * @api
   */


  this.element = opt_element;
};

_index2.default.inherits(_ol_Collection_.Event, _event2.default);

exports.default = _ol_Collection_;

},{"./assertionerror.js":31,"./collectioneventtype.js":36,"./events/event.js":51,"./index.js":90,"./object.js":126}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_CollectionEventType_ = {
  /**
   * Triggered when an item is added to the collection.
   * @event ol.Collection.Event#add
   * @api
   */
  ADD: 'add',

  /**
   * Triggered when an item is removed from the collection.
   * @event ol.Collection.Event#remove
   * @api
   */
  REMOVE: 'remove'
};
exports.default = _ol_CollectionEventType_;

},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require("./asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_color_ = {};
/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */

_ol_color_.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3,4}){1,2}$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */

_ol_color_.NAMED_COLOR_RE_ = /^([a-z]*)$/i;
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {ol.Color|string} color Color.
 * @return {ol.Color} Color.
 * @api
 */

_ol_color_.asArray = function (color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return _ol_color_.fromString(
    /** @type {string} */
    color);
  }
};
/**
 * Return the color as an rgba string.
 * @param {ol.Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */


_ol_color_.asString = function (color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return _ol_color_.toString(color);
  }
};
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */


_ol_color_.fromNamed = function (color) {
  var el = document.createElement('div');
  el.style.color = color;
  document.body.appendChild(el);
  var rgb = getComputedStyle(el).color;
  document.body.removeChild(el);
  return rgb;
};
/**
 * @param {string} s String.
 * @return {ol.Color} Color.
 */


_ol_color_.fromString = function () {
  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;
  /**
   * @type {Object.<string, ol.Color>}
   */

  var cache = {};
  /**
   * @type {number}
   */

  var cacheSize = 0;
  return (
    /**
     * @param {string} s String.
     * @return {ol.Color} Color.
     */
    function (s) {
      var color;

      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;
          var key;

          for (key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }

        color = _ol_color_.fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }

      return color;
    }
  );
}();
/**
 * @param {string} s String.
 * @private
 * @return {ol.Color} Color.
 */


_ol_color_.fromStringInternal_ = function (s) {
  var r, g, b, a, color, parts;

  if (_ol_color_.NAMED_COLOR_RE_.exec(s)) {
    s = _ol_color_.fromNamed(s);
  }

  if (_ol_color_.HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits

    var d; // number of digits per channel

    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }

    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);

    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }

    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;

      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }

    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    parts = s.slice(5, -1).split(',').map(Number);
    color = _ol_color_.normalize(parts);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    parts = s.slice(4, -1).split(',').map(Number);
    parts.push(1);
    color = _ol_color_.normalize(parts);
  } else {
    _asserts2.default.assert(false, 14); // Invalid color

  }

  return (
    /** @type {ol.Color} */
    color
  );
};
/**
 * @param {ol.Color} color Color.
 * @param {ol.Color=} opt_color Color.
 * @return {ol.Color} Clamped color.
 */


_ol_color_.normalize = function (color, opt_color) {
  var result = opt_color || [];
  result[0] = _math2.default.clamp(color[0] + 0.5 | 0, 0, 255);
  result[1] = _math2.default.clamp(color[1] + 0.5 | 0, 0, 255);
  result[2] = _math2.default.clamp(color[2] + 0.5 | 0, 0, 255);
  result[3] = _math2.default.clamp(color[3], 0, 1);
  return result;
};
/**
 * @param {ol.Color} color Color.
 * @return {string} String.
 */


_ol_color_.toString = function (color) {
  var r = color[0];

  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }

  var g = color[1];

  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }

  var b = color[2];

  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }

  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
};

exports.default = _ol_color_;

},{"./asserts.js":32,"./math.js":124}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color = require("./color.js");

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_colorlike_ = {};
/**
 * @param {ol.Color|ol.ColorLike} color Color.
 * @return {ol.ColorLike} The color as an ol.ColorLike
 * @api
 */

_ol_colorlike_.asColorLike = function (color) {
  if (_ol_colorlike_.isColorLike(color)) {
    return (
      /** @type {string|CanvasPattern|CanvasGradient} */
      color
    );
  } else {
    return _color2.default.asString(
    /** @type {ol.Color} */
    color);
  }
};
/**
 * @param {?} color The value that is potentially an ol.ColorLike
 * @return {boolean} Whether the color is an ol.ColorLike
 */


_ol_colorlike_.isColorLike = function (color) {
  return typeof color === 'string' || color instanceof CanvasPattern || color instanceof CanvasGradient;
};

exports.default = _ol_colorlike_;

},{"./color.js":37}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _collection = require("./collection.js");

var _collection2 = _interopRequireDefault(_collection);

var _attribution = require("./control/attribution.js");

var _attribution2 = _interopRequireDefault(_attribution);

var _rotate = require("./control/rotate.js");

var _rotate2 = _interopRequireDefault(_rotate);

var _zoom = require("./control/zoom.js");

var _zoom2 = _interopRequireDefault(_zoom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_control_ = {};
/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link ol.control.Zoom}
 * * {@link ol.control.Rotate}
 * * {@link ol.control.Attribution}
 *
 * @param {olx.control.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */

_ol_control_.defaults = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new _collection2.default();
  var zoomControl = options.zoom !== undefined ? options.zoom : true;

  if (zoomControl) {
    controls.push(new _zoom2.default(options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;

  if (rotateControl) {
    controls.push(new _rotate2.default(options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;

  if (attributionControl) {
    controls.push(new _attribution2.default(options.attributionOptions));
  }

  return controls;
};

exports.default = _ol_control_;

},{"./collection.js":35,"./control/attribution.js":40,"./control/rotate.js":42,"./control/zoom.js":43}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../array.js");

var _array2 = _interopRequireDefault(_array);

var _control = require("../control/control.js");

var _control2 = _interopRequireDefault(_control);

var _css = require("../css.js");

var _css2 = _interopRequireDefault(_css);

var _dom = require("../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _layer = require("../layer/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME handle date line wrap

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.AttributionOptions=} opt_options Attribution options.
 * @api
 */
var _ol_control_Attribution_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {Element}
   */

  this.ulElement_ = document.createElement('UL');
  /**
   * @private
   * @type {Element}
   */

  this.logoLi_ = document.createElement('LI');
  this.ulElement_.appendChild(this.logoLi_);
  this.logoLi_.style.display = 'none';
  /**
   * @private
   * @type {boolean}
   */

  this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
  /**
   * @private
   * @type {boolean}
   */

  this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

  if (!this.collapsible_) {
    this.collapsed_ = false;
  }

  var className = options.className !== undefined ? options.className : 'ol-attribution';
  var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
  var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

  if (typeof collapseLabel === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.collapseLabel_ = document.createElement('span');
    this.collapseLabel_.textContent = collapseLabel;
  } else {
    this.collapseLabel_ = collapseLabel;
  }

  var label = options.label !== undefined ? options.label : 'i';

  if (typeof label === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.label_ = document.createElement('span');
    this.label_.textContent = label;
  } else {
    this.label_ = label;
  }

  var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
  var button = document.createElement('button');
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(activeLabel);

  _events2.default.listen(button, _eventtype2.default.CLICK, this.handleClick_, this);

  var cssClasses = className + ' ' + _css2.default.CLASS_UNSELECTABLE + ' ' + _css2.default.CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? ' ol-collapsed' : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(this.ulElement_);
  element.appendChild(button);
  var render = options.render ? options.render : _ol_control_Attribution_.render;

  _control2.default.call(this, {
    element: element,
    render: render,
    target: options.target
  });
  /**
   * A list of currently rendered resolutions.
   * @type {Array.<string>}
   * @private
   */


  this.renderedAttributions_ = [];
  /**
   * @private
   * @type {boolean}
   */

  this.renderedVisible_ = true;
  /**
   * @private
   * @type {Object.<string, Element>}
   */

  this.logoElements_ = {};
};

_index2.default.inherits(_ol_control_Attribution_, _control2.default);
/**
 * Get a list of visible attributions.
 * @param {olx.FrameState} frameState Frame state.
 * @return {Array.<string>} Attributions.
 * @private
 */


_ol_control_Attribution_.prototype.getSourceAttributions_ = function (frameState) {
  /**
   * Used to determine if an attribution already exists.
   * @type {Object.<string, boolean>}
   */
  var lookup = {};
  /**
   * A list of visible attributions.
   * @type {Array.<string>}
   */

  var visibleAttributions = [];
  var layerStatesArray = frameState.layerStatesArray;
  var resolution = frameState.viewState.resolution;

  for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    var layerState = layerStatesArray[i];

    if (!_layer2.default.visibleAtResolution(layerState, resolution)) {
      continue;
    }

    var source = layerState.layer.getSource();

    if (!source) {
      continue;
    }

    var attributionGetter = source.getAttributions2();

    if (!attributionGetter) {
      continue;
    }

    var attributions = attributionGetter(frameState);

    if (!attributions) {
      continue;
    }

    if (Array.isArray(attributions)) {
      for (var j = 0, jj = attributions.length; j < jj; ++j) {
        if (!(attributions[j] in lookup)) {
          visibleAttributions.push(attributions[j]);
          lookup[attributions[j]] = true;
        }
      }
    } else {
      if (!(attributions in lookup)) {
        visibleAttributions.push(attributions);
        lookup[attributions] = true;
      }
    }
  }

  return visibleAttributions;
};
/**
 * Update the attribution element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Attribution}
 * @api
 */


_ol_control_Attribution_.render = function (mapEvent) {
  this.updateElement_(mapEvent.frameState);
};
/**
 * @private
 * @param {?olx.FrameState} frameState Frame state.
 */


_ol_control_Attribution_.prototype.updateElement_ = function (frameState) {
  if (!frameState) {
    if (this.renderedVisible_) {
      this.element.style.display = 'none';
      this.renderedVisible_ = false;
    }

    return;
  }

  var attributions = this.getSourceAttributions_(frameState);

  if (_array2.default.equals(attributions, this.renderedAttributions_)) {
    return;
  } // remove everything but the logo


  while (this.ulElement_.lastChild !== this.logoLi_) {
    this.ulElement_.removeChild(this.ulElement_.lastChild);
  } // append the attributions


  for (var i = 0, ii = attributions.length; i < ii; ++i) {
    var element = document.createElement('LI');
    element.innerHTML = attributions[i];
    this.ulElement_.appendChild(element);
  }

  if (attributions.length === 0 && this.renderedAttributions_.length > 0) {
    this.element.classList.add('ol-logo-only');
  } else if (this.renderedAttributions_.length === 0 && attributions.length > 0) {
    this.element.classList.remove('ol-logo-only');
  }

  var visible = attributions.length > 0 || !_obj2.default.isEmpty(frameState.logos);

  if (this.renderedVisible_ != visible) {
    this.element.style.display = visible ? '' : 'none';
    this.renderedVisible_ = visible;
  }

  this.renderedAttributions_ = attributions;
  this.insertLogos_(frameState);
};
/**
 * @param {?olx.FrameState} frameState Frame state.
 * @private
 */


_ol_control_Attribution_.prototype.insertLogos_ = function (frameState) {
  var logo;
  var logos = frameState.logos;
  var logoElements = this.logoElements_;

  for (logo in logoElements) {
    if (!(logo in logos)) {
      _dom2.default.removeNode(logoElements[logo]);

      delete logoElements[logo];
    }
  }

  var image, logoElement, logoKey;

  for (logoKey in logos) {
    var logoValue = logos[logoKey];

    if (logoValue instanceof HTMLElement) {
      this.logoLi_.appendChild(logoValue);
      logoElements[logoKey] = logoValue;
    }

    if (!(logoKey in logoElements)) {
      image = new Image();
      image.src = logoKey;

      if (logoValue === '') {
        logoElement = image;
      } else {
        logoElement = document.createElement('a');
        logoElement.href = logoValue;
        logoElement.appendChild(image);
      }

      this.logoLi_.appendChild(logoElement);
      logoElements[logoKey] = logoElement;
    }
  }

  this.logoLi_.style.display = !_obj2.default.isEmpty(logos) ? '' : 'none';
};
/**
 * @param {Event} event The event to handle
 * @private
 */


_ol_control_Attribution_.prototype.handleClick_ = function (event) {
  event.preventDefault();
  this.handleToggle_();
};
/**
 * @private
 */


_ol_control_Attribution_.prototype.handleToggle_ = function () {
  this.element.classList.toggle('ol-collapsed');

  if (this.collapsed_) {
    _dom2.default.replaceNode(this.collapseLabel_, this.label_);
  } else {
    _dom2.default.replaceNode(this.label_, this.collapseLabel_);
  }

  this.collapsed_ = !this.collapsed_;
};
/**
 * Return `true` if the attribution is collapsible, `false` otherwise.
 * @return {boolean} True if the widget is collapsible.
 * @api
 */


_ol_control_Attribution_.prototype.getCollapsible = function () {
  return this.collapsible_;
};
/**
 * Set whether the attribution should be collapsible.
 * @param {boolean} collapsible True if the widget is collapsible.
 * @api
 */


_ol_control_Attribution_.prototype.setCollapsible = function (collapsible) {
  if (this.collapsible_ === collapsible) {
    return;
  }

  this.collapsible_ = collapsible;
  this.element.classList.toggle('ol-uncollapsible');

  if (!collapsible && this.collapsed_) {
    this.handleToggle_();
  }
};
/**
 * Collapse or expand the attribution according to the passed parameter. Will
 * not do anything if the attribution isn't collapsible or if the current
 * collapsed state is already the one requested.
 * @param {boolean} collapsed True if the widget is collapsed.
 * @api
 */


_ol_control_Attribution_.prototype.setCollapsed = function (collapsed) {
  if (!this.collapsible_ || this.collapsed_ === collapsed) {
    return;
  }

  this.handleToggle_();
};
/**
 * Return `true` when the attribution is currently collapsed or `false`
 * otherwise.
 * @return {boolean} True if the widget is collapsed.
 * @api
 */


_ol_control_Attribution_.prototype.getCollapsed = function () {
  return this.collapsed_;
};

exports.default = _ol_control_Attribution_;

},{"../array.js":30,"../control/control.js":41,"../css.js":45,"../dom.js":47,"../events.js":49,"../events/eventtype.js":53,"../index.js":90,"../layer/layer.js":109,"../obj.js":125}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _mapeventtype = require("../mapeventtype.js");

var _mapeventtype2 = _interopRequireDefault(_mapeventtype);

var _object = require("../object.js");

var _object2 = _interopRequireDefault(_object);

var _dom = require("../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new ol.control.Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be `ol.Object`s in a `ol.Collection`, so you can use their
 * methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @constructor
 * @extends {ol.Object}
 * @implements {oli.control.Control}
 * @param {olx.control.ControlOptions} options Control options.
 * @api
 */
var _ol_control_Control_ = function (options) {
  _object2.default.call(this);
  /**
   * @protected
   * @type {Element}
   */


  this.element = options.element ? options.element : null;
  /**
   * @private
   * @type {Element}
   */

  this.target_ = null;
  /**
   * @private
   * @type {ol.PluggableMap}
   */

  this.map_ = null;
  /**
   * @protected
   * @type {!Array.<ol.EventsKey>}
   */

  this.listenerKeys = [];
  /**
   * @type {function(ol.MapEvent)}
   */

  this.render = options.render ? options.render : _index2.default.nullFunction;

  if (options.target) {
    this.setTarget(options.target);
  }
};

_index2.default.inherits(_ol_control_Control_, _object2.default);
/**
 * @inheritDoc
 */


_ol_control_Control_.prototype.disposeInternal = function () {
  _dom2.default.removeNode(this.element);

  _object2.default.prototype.disposeInternal.call(this);
};
/**
 * Get the map associated with this control.
 * @return {ol.PluggableMap} Map.
 * @api
 */


_ol_control_Control_.prototype.getMap = function () {
  return this.map_;
};
/**
 * Remove the control from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.PluggableMap} map Map.
 * @override
 * @api
 */


_ol_control_Control_.prototype.setMap = function (map) {
  if (this.map_) {
    _dom2.default.removeNode(this.element);
  }

  for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
    _events2.default.unlistenByKey(this.listenerKeys[i]);
  }

  this.listenerKeys.length = 0;
  this.map_ = map;

  if (this.map_) {
    var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
    target.appendChild(this.element);

    if (this.render !== _index2.default.nullFunction) {
      this.listenerKeys.push(_events2.default.listen(map, _mapeventtype2.default.POSTRENDER, this.render, this));
    }

    map.render();
  }
};
/**
 * This function is used to set a target element for the control. It has no
 * effect if it is called after the control has been added to the map (i.e.
 * after `setMap` is called on the control). If no `target` is set in the
 * options passed to the control constructor and if `setTarget` is not called
 * then the control is added to the map's overlay container.
 * @param {Element|string} target Target.
 * @api
 */


_ol_control_Control_.prototype.setTarget = function (target) {
  this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
};

exports.default = _ol_control_Control_;

},{"../dom.js":47,"../events.js":49,"../index.js":90,"../mapeventtype.js":122,"../object.js":126}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _control = require("../control/control.js");

var _control2 = _interopRequireDefault(_control);

var _css = require("../css.js");

var _css2 = _interopRequireDefault(_css);

var _easing = require("../easing.js");

var _easing2 = _interopRequireDefault(_easing);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.RotateOptions=} opt_options Rotate options.
 * @api
 */
var _ol_control_Rotate_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : 'ol-rotate';
  var label = options.label !== undefined ? options.label : '\u21E7';
  /**
   * @type {Element}
   * @private
   */

  this.label_ = null;

  if (typeof label === 'string') {
    this.label_ = document.createElement('span');
    this.label_.className = 'ol-compass';
    this.label_.textContent = label;
  } else {
    this.label_ = label;
    this.label_.classList.add('ol-compass');
  }

  var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
  var button = document.createElement('button');
  button.className = className + '-reset';
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(this.label_);

  _events2.default.listen(button, _eventtype2.default.CLICK, _ol_control_Rotate_.prototype.handleClick_, this);

  var cssClasses = className + ' ' + _css2.default.CLASS_UNSELECTABLE + ' ' + _css2.default.CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(button);
  var render = options.render ? options.render : _ol_control_Rotate_.render;
  this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

  _control2.default.call(this, {
    element: element,
    render: render,
    target: options.target
  });
  /**
   * @type {number}
   * @private
   */


  this.duration_ = options.duration !== undefined ? options.duration : 250;
  /**
   * @type {boolean}
   * @private
   */

  this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
  /**
   * @private
   * @type {number|undefined}
   */

  this.rotation_ = undefined;

  if (this.autoHide_) {
    this.element.classList.add(_css2.default.CLASS_HIDDEN);
  }
};

_index2.default.inherits(_ol_control_Rotate_, _control2.default);
/**
 * @param {Event} event The event to handle
 * @private
 */


_ol_control_Rotate_.prototype.handleClick_ = function (event) {
  event.preventDefault();

  if (this.callResetNorth_ !== undefined) {
    this.callResetNorth_();
  } else {
    this.resetNorth_();
  }
};
/**
 * @private
 */


_ol_control_Rotate_.prototype.resetNorth_ = function () {
  var map = this.getMap();
  var view = map.getView();

  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }

  if (view.getRotation() !== undefined) {
    if (this.duration_ > 0) {
      view.animate({
        rotation: 0,
        duration: this.duration_,
        easing: _easing2.default.easeOut
      });
    } else {
      view.setRotation(0);
    }
  }
};
/**
 * Update the rotate control element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Rotate}
 * @api
 */


_ol_control_Rotate_.render = function (mapEvent) {
  var frameState = mapEvent.frameState;

  if (!frameState) {
    return;
  }

  var rotation = frameState.viewState.rotation;

  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';

    if (this.autoHide_) {
      var contains = this.element.classList.contains(_css2.default.CLASS_HIDDEN);

      if (!contains && rotation === 0) {
        this.element.classList.add(_css2.default.CLASS_HIDDEN);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(_css2.default.CLASS_HIDDEN);
      }
    }

    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }

  this.rotation_ = rotation;
};

exports.default = _ol_control_Rotate_;

},{"../control/control.js":41,"../css.js":45,"../easing.js":48,"../events.js":49,"../events/eventtype.js":53,"../index.js":90}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _control = require("../control/control.js");

var _control2 = _interopRequireDefault(_control);

var _css = require("../css.js");

var _css2 = _interopRequireDefault(_css);

var _easing = require("../easing.js");

var _easing2 = _interopRequireDefault(_easing);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomOptions=} opt_options Zoom options.
 * @api
 */
var _ol_control_Zoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : 'ol-zoom';
  var delta = options.delta !== undefined ? options.delta : 1;
  var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
  var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
  var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
  var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
  var inElement = document.createElement('button');
  inElement.className = className + '-in';
  inElement.setAttribute('type', 'button');
  inElement.title = zoomInTipLabel;
  inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);

  _events2.default.listen(inElement, _eventtype2.default.CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, delta));

  var outElement = document.createElement('button');
  outElement.className = className + '-out';
  outElement.setAttribute('type', 'button');
  outElement.title = zoomOutTipLabel;
  outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);

  _events2.default.listen(outElement, _eventtype2.default.CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, -delta));

  var cssClasses = className + ' ' + _css2.default.CLASS_UNSELECTABLE + ' ' + _css2.default.CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(inElement);
  element.appendChild(outElement);

  _control2.default.call(this, {
    element: element,
    target: options.target
  });
  /**
   * @type {number}
   * @private
   */


  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_control_Zoom_, _control2.default);
/**
 * @param {number} delta Zoom delta.
 * @param {Event} event The event to handle
 * @private
 */


_ol_control_Zoom_.prototype.handleClick_ = function (delta, event) {
  event.preventDefault();
  this.zoomByDelta_(delta);
};
/**
 * @param {number} delta Zoom delta.
 * @private
 */


_ol_control_Zoom_.prototype.zoomByDelta_ = function (delta) {
  var map = this.getMap();
  var view = map.getView();

  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }

  var currentResolution = view.getResolution();

  if (currentResolution) {
    var newResolution = view.constrainResolution(currentResolution, delta);

    if (this.duration_ > 0) {
      if (view.getAnimating()) {
        view.cancelAnimations();
      }

      view.animate({
        resolution: newResolution,
        duration: this.duration_,
        easing: _easing2.default.easeOut
      });
    } else {
      view.setResolution(newResolution);
    }
  }
};

exports.default = _ol_control_Zoom_;

},{"../control/control.js":41,"../css.js":45,"../easing.js":48,"../events.js":49,"../events/eventtype.js":53,"../index.js":90}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

var _string = require("./string.js");

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_coordinate_ = {};
/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     ol.coordinate.add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} The input coordinate adjusted by the given delta.
 * @api
 */

_ol_coordinate_.add = function (coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
};
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {ol.geom.Circle} circle The circle.
 * @return {ol.Coordinate} Closest point on the circumference
 */


_ol_coordinate_.closestOnCircle = function (coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;

  if (dx === 0 && dy === 0) {
    dx = 1;
  }

  var d = Math.sqrt(dx * dx + dy * dy);
  var x, y;
  x = x0 + r * dx / d;
  y = y0 + r * dy / d;
  return [x, y];
};
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {Array.<ol.Coordinate>} segment The two coordinates of the segment.
 * @return {ol.Coordinate} The foot of the perpendicular of the coordinate to
 *     the segment.
 */


_ol_coordinate_.closestOnSegment = function (coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;

  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }

  return [x, y];
};
/**
 * Returns a {@link ol.CoordinateFormatType} function that can be used to format
 * a {ol.Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {ol.CoordinateFormatType} Coordinate format.
 * @api
 */


_ol_coordinate_.createStringXY = function (opt_fractionDigits) {
  return (
    /**
     * @param {ol.Coordinate|undefined} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return _ol_coordinate_.toStringXY(coordinate, opt_fractionDigits);
    }
  );
};
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */


_ol_coordinate_.degreesToStringHDMS = function (hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = _math2.default.modulo(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + _string2.default.padNumber(min, 2) + '\u2032 ' + _string2.default.padNumber(sec, 2, dflPrecision) + '\u2033' + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
};
/**
 * Transforms the given {@link ol.Coordinate} to a string using the given string
 * template. The strings `{x}` and `{y}` in the template will be replaced with
 * the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */


_ol_coordinate_.format = function (coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
};
/**
 * @param {ol.Coordinate} coordinate1 First coordinate.
 * @param {ol.Coordinate} coordinate2 Second coordinate.
 * @return {boolean} Whether the passed coordinates are equal.
 */


_ol_coordinate_.equals = function (coordinate1, coordinate2) {
  var equals = true;

  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }

  return equals;
};
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     ol.coordinate.rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_coordinate_.rotate = function (coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
};
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     ol.coordinate.scale(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {ol.Coordinate} Coordinate.
 */


_ol_coordinate_.scale = function (coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
};
/**
 * Subtract `delta` to `coordinate`. `coordinate` is modified in place and
 * returned by the function.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} Coordinate.
 */


_ol_coordinate_.sub = function (coordinate, delta) {
  coordinate[0] -= delta[0];
  coordinate[1] -= delta[1];
  return coordinate;
};
/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */


_ol_coordinate_.squaredDistance = function (coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
};
/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */


_ol_coordinate_.distance = function (coord1, coord2) {
  return Math.sqrt(_ol_coordinate_.squaredDistance(coord1, coord2));
};
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {ol.Coordinate} coordinate Coordinate of the point.
 * @param {Array.<ol.Coordinate>} segment Line segment (2 coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */


_ol_coordinate_.squaredDistanceToSegment = function (coordinate, segment) {
  return _ol_coordinate_.squaredDistance(coordinate, _ol_coordinate_.closestOnSegment(coordinate, segment));
};
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */


_ol_coordinate_.toStringHDMS = function (coordinate, opt_fractionDigits) {
  if (coordinate) {
    return _ol_coordinate_.degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + _ol_coordinate_.degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
};
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */


_ol_coordinate_.toStringXY = function (coordinate, opt_fractionDigits) {
  return _ol_coordinate_.format(coordinate, '{x}, {y}', opt_fractionDigits);
};

exports.default = _ol_coordinate_;

},{"./math.js":124,"./string.js":217}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_css_ = {};
/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_HIDDEN = 'ol-hidden';
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_SELECTABLE = 'ol-selectable';
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_UNSELECTABLE = 'ol-unselectable';
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_UNSUPPORTED = 'ol-unsupported';
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */

_ol_css_.CLASS_CONTROL = 'ol-control';
/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} The CSS font property.
 * @return {Object.<string>} The font families (or null if the input spec is invalid).
 */

_ol_css_.getFontFamilies = function () {
  var style;
  var cache = {};
  return function (font) {
    if (!style) {
      style = document.createElement('div').style;
    }

    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = '';

      if (!family) {
        return null;
      }

      cache[font] = family.split(/,\s?/);
    }

    return cache[font];
  };
}();

exports.default = _ol_css_;

},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Objects that need to clean up after themselves.
 * @constructor
 */
var _ol_Disposable_ = function () {};
/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */


_ol_Disposable_.prototype.disposed_ = false;
/**
 * Clean up.
 */

_ol_Disposable_.prototype.dispose = function () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};
/**
 * Extension point for disposable objects.
 * @protected
 */


_ol_Disposable_.prototype.disposeInternal = _index2.default.nullFunction;
exports.default = _ol_Disposable_;

},{"./index.js":90}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_dom_ = {};
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */

_ol_dom_.createCanvasContext2D = function (opt_width, opt_height) {
  var canvas = document.createElement('CANVAS');

  if (opt_width) {
    canvas.width = opt_width;
  }

  if (opt_height) {
    canvas.height = opt_height;
  }

  return canvas.getContext('2d');
};
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */


_ol_dom_.outerWidth = function (element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
};
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */


_ol_dom_.outerHeight = function (element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
};
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */


_ol_dom_.replaceNode = function (newNode, oldNode) {
  var parent = oldNode.parentNode;

  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};
/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */


_ol_dom_.removeNode = function (node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};
/**
 * @param {Node} node The node to remove the children from.
 */


_ol_dom_.removeChildren = function (node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
};

exports.default = _ol_dom_;

},{}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_easing_ = {};
/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */

_ol_easing_.easeIn = function (t) {
  return Math.pow(t, 3);
};
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.easeOut = function (t) {
  return 1 - _ol_easing_.easeIn(1 - t);
};
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.inAndOut = function (t) {
  return 3 * t * t - 2 * t * t * t;
};
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.linear = function (t) {
  return t;
};
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link ol.easing.inAndOut}, but the final slowdown
 * is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


_ol_easing_.upAndDown = function (t) {
  if (t < 0.5) {
    return _ol_easing_.inAndOut(2 * t);
  } else {
    return 1 - _ol_easing_.inAndOut(2 * (t - 0.5));
  }
};

exports.default = _ol_easing_;

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _obj = require("./obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_events_ = {};
/**
 * @param {ol.EventsKey} listenerObj Listener object.
 * @return {ol.EventsListenerFunctionType} Bound listener.
 */

_ol_events_.bindListener_ = function (listenerObj) {
  var boundListener = function (evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;

    if (listenerObj.callOnce) {
      _ol_events_.unlistenByKey(listenerObj);
    }

    return listener.call(bindTo, evt);
  };

  listenerObj.boundListener = boundListener;
  return boundListener;
};
/**
 * Finds the matching {@link ol.EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!ol.EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link ol.events.unlistenByKey}.
 * @return {ol.EventsKey|undefined} The matching listener object.
 * @private
 */


_ol_events_.findListener_ = function (listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;

  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];

    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }

      return listenerObj;
    }
  }

  return undefined;
};
/**
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<ol.EventsKey>|undefined} Listeners.
 */


_ol_events_.getListeners = function (target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
};
/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {ol.EventTargetLike} target Target.
 * @return {!Object.<string, Array.<ol.EventsKey>>} Map of
 *     listeners by event type.
 * @private
 */


_ol_events_.getListenerMap_ = function (target) {
  var listenerMap = target.ol_lm;

  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }

  return listenerMap;
};
/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @private
 */


_ol_events_.removeListeners_ = function (target, type) {
  var listeners = _ol_events_.getListeners(target, type);

  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);

      _obj2.default.clear(listeners[i]);
    }

    listeners.length = 0;
    var listenerMap = target.ol_lm;

    if (listenerMap) {
      delete listenerMap[type];

      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
};
/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link ol.events.unlistenByKey}.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {ol.EventsKey} Unique key for the listener.
 */


_ol_events_.listen = function (target, type, listener, opt_this, opt_once) {
  var listenerMap = _ol_events_.getListenerMap_(target);

  var listeners = listenerMap[type];

  if (!listeners) {
    listeners = listenerMap[type] = [];
  }

  var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, false);

  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj =
    /** @type {ol.EventsKey} */
    {
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    };
    target.addEventListener(type, _ol_events_.bindListener_(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
};
/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered
 * before it is called.
 *
 * When {@link ol.events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {ol.EventsKey} Key for unlistenByKey.
 */


_ol_events_.listenOnce = function (target, type, listener, opt_this) {
  return _ol_events_.listen(target, type, listener, opt_this, true);
};
/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link ol.events.listen} call.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */


_ol_events_.unlisten = function (target, type, listener, opt_this) {
  var listeners = _ol_events_.getListeners(target, type);

  if (listeners) {
    var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, true);

    if (listenerObj) {
      _ol_events_.unlistenByKey(listenerObj);
    }
  }
};
/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link ol.events.listen} or {@link ol.events.listenOnce}.
 *
 * @param {ol.EventsKey} key The key.
 */


_ol_events_.unlistenByKey = function (key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);

    var listeners = _ol_events_.getListeners(key.target, key.type);

    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);

      if (i !== -1) {
        listeners.splice(i, 1);
      }

      if (listeners.length === 0) {
        _ol_events_.removeListeners_(key.target, key.type);
      }
    }

    _obj2.default.clear(key);
  }
};
/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {ol.EventTargetLike} target Target.
 */


_ol_events_.unlistenAll = function (target) {
  var listenerMap = _ol_events_.getListenerMap_(target);

  for (var type in listenerMap) {
    _ol_events_.removeListeners_(target, type);
  }
};

exports.default = _ol_events_;

},{"./obj.js":125}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mapbrowsereventtype = require("../mapbrowsereventtype.js");

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _has = require("../has.js");

var _has2 = _interopRequireDefault(_has);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_events_condition_ = {};
/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */

_ol_events_condition_.altKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */


_ol_events_condition_.altShiftKeysOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return always true.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @function
 * @api
 */


_ol_events_condition_.always = _functions2.default.TRUE;
/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */

_ol_events_condition_.click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype2.default.CLICK;
};
/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */


_ol_events_condition_.mouseActionButton = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(_has2.default.WEBKIT && _has2.default.MAC && originalEvent.ctrlKey);
};
/**
 * Return always false.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @function
 * @api
 */


_ol_events_condition_.never = _functions2.default.FALSE;
/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */

_ol_events_condition_.pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};
/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */


_ol_events_condition_.singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype2.default.SINGLECLICK;
};
/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */


_ol_events_condition_.doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype2.default.DBLCLICK;
};
/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */


_ol_events_condition_.noModifierKeys = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */


_ol_events_condition_.platformModifierKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (_has2.default.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */


_ol_events_condition_.shiftKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */


_ol_events_condition_.targetNotEditable = function (mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};
/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */


_ol_events_condition_.mouseOnly = function (mapBrowserEvent) {
  _asserts2.default.assert(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType


  return (
    /** @type {ol.MapBrowserEvent} */
    mapBrowserEvent.pointerEvent.pointerType == 'mouse'
  );
};
/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * @see http://www.w3.org/TR/pointerevents/#button-states
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */


_ol_events_condition_.primaryAction = function (mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.pointerEvent;
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

exports.default = _ol_events_condition_;

},{"../asserts.js":32,"../functions.js":61,"../has.js":85,"../mapbrowsereventtype.js":119}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link ol.events.EventTarget}.
 *
 * @constructor
 * @implements {oli.events.Event}
 * @param {string} type Type.
 */
var _ol_events_Event_ = function (type) {
  /**
   * @type {boolean}
   */
  this.propagationStopped;
  /**
   * The event type.
   * @type {string}
   * @api
   */

  this.type = type;
  /**
   * The event target.
   * @type {Object}
   * @api
   */

  this.target = null;
};
/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */


_ol_events_Event_.prototype.preventDefault =
/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.stopPropagation = function () {
  this.propagationStopped = true;
};
/**
 * @param {Event|ol.events.Event} evt Event
 */


_ol_events_Event_.stopPropagation = function (evt) {
  evt.stopPropagation();
};
/**
 * @param {Event|ol.events.Event} evt Event
 */


_ol_events_Event_.preventDefault = function (evt) {
  evt.preventDefault();
};

exports.default = _ol_events_Event_;

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _disposable = require("../disposable.js");

var _disposable2 = _interopRequireDefault(_disposable);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _event = require("../events/event.js");

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {ol.Disposable}
 */
var _ol_events_EventTarget_ = function () {
  _disposable2.default.call(this);
  /**
   * @private
   * @type {!Object.<string, number>}
   */


  this.pendingRemovals_ = {};
  /**
   * @private
   * @type {!Object.<string, number>}
   */

  this.dispatching_ = {};
  /**
   * @private
   * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}
   */

  this.listeners_ = {};
};

_index2.default.inherits(_ol_events_EventTarget_, _disposable2.default);
/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */


_ol_events_EventTarget_.prototype.addEventListener = function (type, listener) {
  var listeners = this.listeners_[type];

  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }

  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};
/**
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */


_ol_events_EventTarget_.prototype.dispatchEvent = function (event) {
  var evt = typeof event === 'string' ? new _event2.default(event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate;

  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }

    ++this.dispatching_[type];

    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }

    --this.dispatching_[type];

    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];

      while (pendingRemovals--) {
        this.removeEventListener(type, _index2.default.nullFunction);
      }

      delete this.dispatching_[type];
    }

    return propagate;
  }
};
/**
 * @inheritDoc
 */


_ol_events_EventTarget_.prototype.disposeInternal = function () {
  _events2.default.unlistenAll(this);
};
/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<ol.EventsListenerFunctionType>} Listeners.
 */


_ol_events_EventTarget_.prototype.getListeners = function (type) {
  return this.listeners_[type];
};
/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */


_ol_events_EventTarget_.prototype.hasListener = function (opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};
/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */


_ol_events_EventTarget_.prototype.removeEventListener = function (type, listener) {
  var listeners = this.listeners_[type];

  if (listeners) {
    var index = listeners.indexOf(listener);

    if (type in this.pendingRemovals_) {
      // make listener a no-op, and remove later in #dispatchEvent()
      listeners[index] = _index2.default.nullFunction;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);

      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};

exports.default = _ol_events_EventTarget_;

},{"../disposable.js":46,"../events.js":49,"../events/event.js":51,"../index.js":90}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 * @const
 */
var _ol_events_EventType_ = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event ol.events.Event#change
   * @api
   */
  CHANGE: 'change',
  CLEAR: 'clear',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
};
exports.default = _ol_events_EventType_;

},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {number}
 * @const
 */
var _ol_events_KeyCode_ = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
exports.default = _ol_events_KeyCode_;

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require("./asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _corner = require("./extent/corner.js");

var _corner2 = _interopRequireDefault(_corner);

var _relationship = require("./extent/relationship.js");

var _relationship2 = _interopRequireDefault(_relationship);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_extent_ = {};
/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Bounding extent.
 * @api
 */

_ol_extent_.boundingExtent = function (coordinates) {
  var extent = _ol_extent_.createEmpty();

  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }

  return extent;
};
/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @private
 * @return {ol.Extent} Extent.
 */


_ol_extent_.boundingExtentXYs_ = function (xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
/**
 * Return extent increased by the provided value.
 * @param {ol.Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_extent_.buffer = function (extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
};
/**
 * Creates a clone of an extent.
 *
 * @param {ol.Extent} extent Extent to clone.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} The clone.
 */


_ol_extent_.clone = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */


_ol_extent_.closestSquaredDistanceXY = function (extent, x, y) {
  var dx, dy;

  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }

  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }

  return dx * dx + dy * dy;
};
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */


_ol_extent_.containsCoordinate = function (extent, coordinate) {
  return _ol_extent_.containsXY(extent, coordinate[0], coordinate[1]);
};
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */


_ol_extent_.containsExtent = function (extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
};
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */


_ol_extent_.containsXY = function (extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
};
/**
 * Get the relationship between a coordinate and extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} coordinate The coordinate.
 * @return {number} The relationship (bitwise compare with
 *     ol.extent.Relationship).
 */


_ol_extent_.coordinateRelationship = function (extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _relationship2.default.UNKNOWN;

  if (x < minX) {
    relationship = relationship | _relationship2.default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | _relationship2.default.RIGHT;
  }

  if (y < minY) {
    relationship = relationship | _relationship2.default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | _relationship2.default.ABOVE;
  }

  if (relationship === _relationship2.default.UNKNOWN) {
    relationship = _relationship2.default.INTERSECTING;
  }

  return relationship;
};
/**
 * Create an empty extent.
 * @return {ol.Extent} Empty extent.
 * @api
 */


_ol_extent_.createEmpty = function () {
  return [Infinity, Infinity, -Infinity, -Infinity];
};
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdate = function (minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
};
/**
 * Create a new empty extent or make the provided one empty.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateEmpty = function (opt_extent) {
  return _ol_extent_.createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromCoordinate = function (coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return _ol_extent_.createOrUpdate(x, y, x, y, opt_extent);
};
/**
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromCoordinates = function (coordinates, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);

  return _ol_extent_.extendCoordinates(extent, coordinates);
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromFlatCoordinates = function (flatCoordinates, offset, end, stride, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);

  return _ol_extent_.extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
};
/**
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.createOrUpdateFromRings = function (rings, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);

  return _ol_extent_.extendRings(extent, rings);
};
/**
 * Determine if two extents are equivalent.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */


_ol_extent_.equals = function (extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
};
/**
 * Modify an extent to include another extent.
 * @param {ol.Extent} extent1 The extent to be modified.
 * @param {ol.Extent} extent2 The extent that will be included in the first.
 * @return {ol.Extent} A reference to the first (extended) extent.
 * @api
 */


_ol_extent_.extend = function (extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }

  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }

  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }

  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }

  return extent1;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 */


_ol_extent_.extendCoordinate = function (extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }

  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }

  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }

  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.extendCoordinates = function (extent, coordinates) {
  var i, ii;

  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }

  return extent;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.extendFlatCoordinates = function (extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    _ol_extent_.extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }

  return extent;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.extendRings = function (extent, rings) {
  var i, ii;

  for (i = 0, ii = rings.length; i < ii; ++i) {
    _ol_extent_.extendCoordinates(extent, rings[i]);
  }

  return extent;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */


_ol_extent_.extendXY = function (extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
};
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {ol.Extent} extent Extent.
 * @param {function(this:T, ol.Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */


_ol_extent_.forEachCorner = function (extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, _ol_extent_.getBottomLeft(extent));

  if (val) {
    return val;
  }

  val = callback.call(opt_this, _ol_extent_.getBottomRight(extent));

  if (val) {
    return val;
  }

  val = callback.call(opt_this, _ol_extent_.getTopRight(extent));

  if (val) {
    return val;
  }

  val = callback.call(opt_this, _ol_extent_.getTopLeft(extent));

  if (val) {
    return val;
  }

  return false;
};
/**
 * Get the size of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Area.
 * @api
 */


_ol_extent_.getArea = function (extent) {
  var area = 0;

  if (!_ol_extent_.isEmpty(extent)) {
    area = _ol_extent_.getWidth(extent) * _ol_extent_.getHeight(extent);
  }

  return area;
};
/**
 * Get the bottom left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom left coordinate.
 * @api
 */


_ol_extent_.getBottomLeft = function (extent) {
  return [extent[0], extent[1]];
};
/**
 * Get the bottom right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom right coordinate.
 * @api
 */


_ol_extent_.getBottomRight = function (extent) {
  return [extent[2], extent[1]];
};
/**
 * Get the center coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Center.
 * @api
 */


_ol_extent_.getCenter = function (extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
};
/**
 * Get a corner coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.extent.Corner} corner Corner.
 * @return {ol.Coordinate} Corner coordinate.
 */


_ol_extent_.getCorner = function (extent, corner) {
  var coordinate;

  if (corner === _corner2.default.BOTTOM_LEFT) {
    coordinate = _ol_extent_.getBottomLeft(extent);
  } else if (corner === _corner2.default.BOTTOM_RIGHT) {
    coordinate = _ol_extent_.getBottomRight(extent);
  } else if (corner === _corner2.default.TOP_LEFT) {
    coordinate = _ol_extent_.getTopLeft(extent);
  } else if (corner === _corner2.default.TOP_RIGHT) {
    coordinate = _ol_extent_.getTopRight(extent);
  } else {
    _asserts2.default.assert(false, 13); // Invalid corner

  }

  return (
    /** @type {!ol.Coordinate} */
    coordinate
  );
};
/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */


_ol_extent_.getEnlargedArea = function (extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
};
/**
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.getForViewAndSize = function (center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return _ol_extent_.createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
};
/**
 * Get the height of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Height.
 * @api
 */


_ol_extent_.getHeight = function (extent) {
  return extent[3] - extent[1];
};
/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */


_ol_extent_.getIntersectionArea = function (extent1, extent2) {
  var intersection = _ol_extent_.getIntersection(extent1, extent2);

  return _ol_extent_.getArea(intersection);
};
/**
 * Get the intersection of two extents.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @param {ol.Extent=} opt_extent Optional extent to populate with intersection.
 * @return {ol.Extent} Intersecting extent.
 * @api
 */


_ol_extent_.getIntersection = function (extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : _ol_extent_.createEmpty();

  if (_ol_extent_.intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }

    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }

    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }

    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  }

  return intersection;
};
/**
 * @param {ol.Extent} extent Extent.
 * @return {number} Margin.
 */


_ol_extent_.getMargin = function (extent) {
  return _ol_extent_.getWidth(extent) + _ol_extent_.getHeight(extent);
};
/**
 * Get the size (width, height) of an extent.
 * @param {ol.Extent} extent The extent.
 * @return {ol.Size} The extent size.
 * @api
 */


_ol_extent_.getSize = function (extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
};
/**
 * Get the top left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top left coordinate.
 * @api
 */


_ol_extent_.getTopLeft = function (extent) {
  return [extent[0], extent[3]];
};
/**
 * Get the top right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top right coordinate.
 * @api
 */


_ol_extent_.getTopRight = function (extent) {
  return [extent[2], extent[3]];
};
/**
 * Get the width of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Width.
 * @api
 */


_ol_extent_.getWidth = function (extent) {
  return extent[2] - extent[0];
};
/**
 * Determine if one extent intersects another.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */


_ol_extent_.intersects = function (extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
};
/**
 * Determine if an extent is empty.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */


_ol_extent_.isEmpty = function (extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_extent_.returnOrUpdate = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} value Value.
 */


_ol_extent_.scaleFromCenter = function (extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
};
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} start Segment start coordinate.
 * @param {ol.Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */


_ol_extent_.intersectsSegment = function (extent, start, end) {
  var intersects = false;

  var startRel = _ol_extent_.coordinateRelationship(extent, start);

  var endRel = _ol_extent_.coordinateRelationship(extent, end);

  if (startRel === _relationship2.default.INTERSECTING || endRel === _relationship2.default.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;

    if (!!(endRel & _relationship2.default.ABOVE) && !(startRel & _relationship2.default.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _relationship2.default.RIGHT) && !(startRel & _relationship2.default.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }

    if (!intersects && !!(endRel & _relationship2.default.BELOW) && !(startRel & _relationship2.default.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _relationship2.default.LEFT) && !(startRel & _relationship2.default.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }

  return intersects;
};
/**
 * Apply a transform function to the extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.TransformFunction} transformFn Transform function.  Called with
 * [minX, minY, maxX, maxY] extent coordinates.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_extent_.applyTransform = function (extent, transformFn, opt_extent) {
  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _ol_extent_.boundingExtentXYs_(xs, ys, opt_extent);
};

exports.default = _ol_extent_;

},{"./asserts.js":32,"./extent/corner.js":56,"./extent/relationship.js":57}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Extent corner.
 * @enum {string}
 */
var _ol_extent_Corner_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};
exports.default = _ol_extent_Corner_;

},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Relationship to an extent.
 * @enum {number}
 */
var _ol_extent_Relationship_ = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
exports.default = _ol_extent_Relationship_;

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require("./asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require("./events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("./events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _object = require("./object.js");

var _object2 = _interopRequireDefault(_object);

var _geometry = require("./geom/geometry.js");

var _geometry2 = _interopRequireDefault(_geometry);

var _style = require("./style/style.js");

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link ol.Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 * var feature = new ol.Feature({
 *   geometry: new ol.geom.Polygon(polyCoords),
 *   labelPoint: new ol.geom.Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @constructor
 * @extends {ol.Object}
 * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties
 *     You may pass a Geometry object directly, or an object literal
 *     containing properties.  If you pass an object literal, you may
 *     include a Geometry associated with a `geometry` key.
 * @api
 */
var _ol_Feature_ = function (opt_geometryOrProperties) {
  _object2.default.call(this);
  /**
   * @private
   * @type {number|string|undefined}
   */


  this.id_ = undefined;
  /**
   * @type {string}
   * @private
   */

  this.geometryName_ = 'geometry';
  /**
   * User provided style.
   * @private
   * @type {ol.style.Style|Array.<ol.style.Style>|
   *     ol.FeatureStyleFunction}
   */

  this.style_ = null;
  /**
   * @private
   * @type {ol.FeatureStyleFunction|undefined}
   */

  this.styleFunction_ = undefined;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.geometryChangeKey_ = null;

  _events2.default.listen(this, _object2.default.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  if (opt_geometryOrProperties !== undefined) {
    if (opt_geometryOrProperties instanceof _geometry2.default || !opt_geometryOrProperties) {
      var geometry = opt_geometryOrProperties;
      this.setGeometry(geometry);
    } else {
      /** @type {Object.<string, *>} */
      var properties = opt_geometryOrProperties;
      this.setProperties(properties);
    }
  }
};

_index2.default.inherits(_ol_Feature_, _object2.default);
/**
 * Clone this feature. If the original feature has a geometry it
 * is also cloned. The feature id is not set in the clone.
 * @return {ol.Feature} The clone.
 * @api
 */


_ol_Feature_.prototype.clone = function () {
  var clone = new _ol_Feature_(this.getProperties());
  clone.setGeometryName(this.getGeometryName());
  var geometry = this.getGeometry();

  if (geometry) {
    clone.setGeometry(geometry.clone());
  }

  var style = this.getStyle();

  if (style) {
    clone.setStyle(style);
  }

  return clone;
};
/**
 * Get the feature's default geometry.  A feature may have any number of named
 * geometries.  The "default" geometry (the one that is rendered by default) is
 * set when calling {@link ol.Feature#setGeometry}.
 * @return {ol.geom.Geometry|undefined} The default geometry for the feature.
 * @api
 * @observable
 */


_ol_Feature_.prototype.getGeometry = function () {
  return (
    /** @type {ol.geom.Geometry|undefined} */
    this.get(this.geometryName_)
  );
};
/**
 * Get the feature identifier.  This is a stable identifier for the feature and
 * is either set when reading data from a remote source or set explicitly by
 * calling {@link ol.Feature#setId}.
 * @return {number|string|undefined} Id.
 * @api
 */


_ol_Feature_.prototype.getId = function () {
  return this.id_;
};
/**
 * Get the name of the feature's default geometry.  By default, the default
 * geometry is named `geometry`.
 * @return {string} Get the property name associated with the default geometry
 *     for this feature.
 * @api
 */


_ol_Feature_.prototype.getGeometryName = function () {
  return this.geometryName_;
};
/**
 * Get the feature's style. Will return what was provided to the
 * {@link ol.Feature#setStyle} method.
 * @return {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.
 * @api
 */


_ol_Feature_.prototype.getStyle = function () {
  return this.style_;
};
/**
 * Get the feature's style function.
 * @return {ol.FeatureStyleFunction|undefined} Return a function
 * representing the current style of this feature.
 * @api
 */


_ol_Feature_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};
/**
 * @private
 */


_ol_Feature_.prototype.handleGeometryChange_ = function () {
  this.changed();
};
/**
 * @private
 */


_ol_Feature_.prototype.handleGeometryChanged_ = function () {
  if (this.geometryChangeKey_) {
    _events2.default.unlistenByKey(this.geometryChangeKey_);

    this.geometryChangeKey_ = null;
  }

  var geometry = this.getGeometry();

  if (geometry) {
    this.geometryChangeKey_ = _events2.default.listen(geometry, _eventtype2.default.CHANGE, this.handleGeometryChange_, this);
  }

  this.changed();
};
/**
 * Set the default geometry for the feature.  This will update the property
 * with the name returned by {@link ol.Feature#getGeometryName}.
 * @param {ol.geom.Geometry|undefined} geometry The new geometry.
 * @api
 * @observable
 */


_ol_Feature_.prototype.setGeometry = function (geometry) {
  this.set(this.geometryName_, geometry);
};
/**
 * Set the style for the feature.  This can be a single style object, an array
 * of styles, or a function that takes a resolution and returns an array of
 * styles. If it is `null` the feature has no style (a `null` style).
 * @param {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.
 * @api
 * @fires ol.events.Event#event:change
 */


_ol_Feature_.prototype.setStyle = function (style) {
  this.style_ = style;
  this.styleFunction_ = !style ? undefined : _ol_Feature_.createStyleFunction(style);
  this.changed();
};
/**
 * Set the feature id.  The feature id is considered stable and may be used when
 * requesting features or comparing identifiers returned from a remote source.
 * The feature id can be used with the {@link ol.source.Vector#getFeatureById}
 * method.
 * @param {number|string|undefined} id The feature id.
 * @api
 * @fires ol.events.Event#event:change
 */


_ol_Feature_.prototype.setId = function (id) {
  this.id_ = id;
  this.changed();
};
/**
 * Set the property name to be used when getting the feature's default geometry.
 * When calling {@link ol.Feature#getGeometry}, the value of the property with
 * this name will be returned.
 * @param {string} name The property name of the default geometry.
 * @api
 */


_ol_Feature_.prototype.setGeometryName = function (name) {
  _events2.default.unlisten(this, _object2.default.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  this.geometryName_ = name;

  _events2.default.listen(this, _object2.default.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  this.handleGeometryChanged_();
};
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of ol.style.Style or single style objects wrapped
 * in a new feature style function.
 * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {ol.FeatureStyleFunction} A style function.
 */


_ol_Feature_.createStyleFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    if (obj.length == 2) {
      styleFunction = function (resolution) {
        return (
          /** @type {ol.StyleFunction} */
          obj(this, resolution)
        );
      };
    } else {
      styleFunction = obj;
    }
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;

    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      _asserts2.default.assert(obj instanceof _style2.default, 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`


      styles = [obj];
    }

    styleFunction = function () {
      return styles;
    };
  }

  return styleFunction;
};

exports.default = _ol_Feature_;

},{"./asserts.js":32,"./events.js":49,"./events/eventtype.js":53,"./geom/geometry.js":78,"./index.js":90,"./object.js":126,"./style/style.js":235}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _formattype = require("./format/formattype.js");

var _formattype2 = _interopRequireDefault(_formattype);

var _xml = require("./xml.js");

var _xml2 = _interopRequireDefault(_xml);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_featureloader_ = {};
/**
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @param {function(this:ol.VectorTile, Array.<ol.Feature>, ol.proj.Projection, ol.Extent)|function(this:ol.source.Vector, Array.<ol.Feature>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:ol.VectorTile)|function(this:ol.source.Vector)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {ol.FeatureLoader} The feature loader.
 */

_ol_featureloader_.loadFeaturesXhr = function (url, format, success, failure) {
  return (
    /**
     * @param {ol.Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {ol.proj.Projection} projection Projection.
     * @this {ol.source.Vector|ol.VectorTile}
     */
    function (extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);

      if (format.getType() == _formattype2.default.ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */


      xhr.onload = function (event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */

          var source;

          if (type == _formattype2.default.JSON || type == _formattype2.default.TEXT) {
            source = xhr.responseText;
          } else if (type == _formattype2.default.XML) {
            source = xhr.responseXML;

            if (!source) {
              source = _xml2.default.parse(xhr.responseText);
            }
          } else if (type == _formattype2.default.ARRAY_BUFFER) {
            source =
            /** @type {ArrayBuffer} */
            xhr.response;
          }

          if (source) {
            success.call(this, format.readFeatures(source, {
              featureProjection: projection
            }), format.readProjection(source), format.getLastExtent());
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */


      xhr.onerror = function () {
        failure.call(this);
      }.bind(this);

      xhr.send();
    }
  );
};
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @return {ol.FeatureLoader} The feature loader.
 * @api
 */


_ol_featureloader_.xhr = function (url, format) {
  return _ol_featureloader_.loadFeaturesXhr(url, format,
  /**
   * @param {Array.<ol.Feature>} features The loaded features.
   * @param {ol.proj.Projection} dataProjection Data projection.
   * @this {ol.source.Vector}
   */
  function (features, dataProjection) {
    this.addFeatures(features);
  },
  /* FIXME handle error */
  _index2.default.nullFunction);
};

exports.default = _ol_featureloader_;

},{"./format/formattype.js":60,"./index.js":90,"./xml.js":256}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_format_FormatType_ = {
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
};
exports.default = _ol_format_FormatType_;

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_functions_ = {};
/**
 * Always returns true.
 * @returns {boolean} true.
 */

_ol_functions_.TRUE = function () {
  return true;
};
/**
 * Always returns false.
 * @returns {boolean} false.
 */


_ol_functions_.FALSE = function () {
  return false;
};

exports.default = _ol_functions_;

},{}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_area_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */

_ol_geom_flat_area_.linearRing = function (flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }

  return twiceArea / 2;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


_ol_geom_flat_area_.linearRings = function (flatCoordinates, offset, ends, stride) {
  var area = 0;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += _ol_geom_flat_area_.linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }

  return area;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


_ol_geom_flat_area_.linearRingss = function (flatCoordinates, offset, endss, stride) {
  var area = 0;
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += _ol_geom_flat_area_.linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }

  return area;
};

exports.default = _ol_geom_flat_area_;

},{}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require("../../math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_geom_flat_closest_ = {};
/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 */

_ol_geom_flat_closest_.point = function (flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var i, offset;

  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = _math2.default.lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }

      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }

  for (i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }

  closestPoint.length = stride;
};
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */


_ol_geom_flat_closest_.getMaxSquaredDelta = function (flatCoordinates, offset, end, stride, maxSquaredDelta) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];

  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    var squaredDelta = _math2.default.squaredDistance(x1, y1, x2, y2);

    if (squaredDelta > maxSquaredDelta) {
      maxSquaredDelta = squaredDelta;
    }

    x1 = x2;
    y1 = y2;
  }

  return maxSquaredDelta;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */


_ol_geom_flat_closest_.getsMaxSquaredDelta = function (flatCoordinates, offset, ends, stride, maxSquaredDelta) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(flatCoordinates, offset, end, stride, maxSquaredDelta);
    offset = end;
  }

  return maxSquaredDelta;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */


_ol_geom_flat_closest_.getssMaxSquaredDelta = function (flatCoordinates, offset, endss, stride, maxSquaredDelta) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(flatCoordinates, offset, ends, stride, maxSquaredDelta);
    offset = ends[ends.length - 1];
  }

  return maxSquaredDelta;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


_ol_geom_flat_closest_.getClosestPoint = function (flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }

  var i, squaredDistance;

  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = _math2.default.squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);

    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }

  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;

  while (index < end) {
    _ol_geom_flat_closest_.point(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);

    squaredDistance = _math2.default.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }

  if (isRing) {
    // Check the closing segment.
    _ol_geom_flat_closest_.point(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);

    squaredDistance = _math2.default.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
    }
  }

  return minSquaredDistance;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


_ol_geom_flat_closest_.getsClosestPoint = function (flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }

  return minSquaredDistance;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


_ol_geom_flat_closest_.getssClosestPoint = function (flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }

  return minSquaredDistance;
};

exports.default = _ol_geom_flat_closest_;

},{"../../math.js":124}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_geom_flat_contains_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Contains extent.
 */

_ol_geom_flat_contains_.linearRingContainsExtent = function (flatCoordinates, offset, end, stride, extent) {
  var outside = _extent2.default.forEachCorner(extent,
  /**
   * @param {ol.Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });

  return !outside;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_flat_contains_.linearRingContainsXY = function (flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }

    x1 = x2;
    y1 = y2;
  }

  return wn !== 0;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_flat_contains_.linearRingsContainsXY = function (flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }

  if (!_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }

  var i, ii;

  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }

  return true;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_flat_contains_.linearRingssContainsXY = function (flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }

  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (_ol_geom_flat_contains_.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
};

exports.default = _ol_geom_flat_contains_;

},{"../../extent.js":55}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_deflate_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */

_ol_geom_flat_deflate_.coordinate = function (flatCoordinates, offset, coordinate, stride) {
  var i, ii;

  for (i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }

  return offset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */


_ol_geom_flat_deflate_.coordinates = function (flatCoordinates, offset, coordinates, stride) {
  var i, ii;

  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    var j;

    for (j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }

  return offset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<ol.Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array.<number>=} opt_ends Ends.
 * @return {Array.<number>} Ends.
 */


_ol_geom_flat_deflate_.coordinatess = function (flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = _ol_geom_flat_deflate_.coordinates(flatCoordinates, offset, coordinatess[j], stride);

    ends[i++] = end;
    offset = end;
  }

  ends.length = i;
  return ends;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<number>>=} opt_endss Endss.
 * @return {Array.<Array.<number>>} Endss.
 */


_ol_geom_flat_deflate_.coordinatesss = function (flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = _ol_geom_flat_deflate_.coordinatess(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);

    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }

  endss.length = i;
  return endss;
};

exports.default = _ol_geom_flat_deflate_;

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_inflate_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array.<ol.Coordinate>=} opt_coordinates Coordinates.
 * @return {Array.<ol.Coordinate>} Coordinates.
 */

_ol_geom_flat_inflate_.coordinates = function (flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  var j;

  for (j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }

  coordinates.length = i;
  return coordinates;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<Array.<ol.Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinatess.
 */


_ol_geom_flat_inflate_.coordinatess = function (flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = _ol_geom_flat_inflate_.coordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }

  coordinatess.length = i;
  return coordinatess;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinatesss.
 */


_ol_geom_flat_inflate_.coordinatesss = function (flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  var j, jj;

  for (j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = _ol_geom_flat_inflate_.coordinatess(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }

  coordinatesss.length = i;
  return coordinatesss;
};

exports.default = _ol_geom_flat_inflate_;

},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _contains = require("../flat/contains.js");

var _contains2 = _interopRequireDefault(_contains);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_geom_flat_interiorpoint_ = {};
/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */

_ol_geom_flat_interiorpoint_.linearRings = function (flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array.<number>} */

  var intersections = []; // Calculate intersections with the horizontal line

  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];

    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];

      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }

      x1 = x2;
      y1 = y2;
    }
  } // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.


  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array2.default.numberSafeCompareFunction);
  x1 = intersections[0];

  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);

    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;

      if (_contains2.default.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }

    x1 = x2;
  }

  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }

  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @return {Array.<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */


_ol_geom_flat_interiorpoint_.linearRingss = function (flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = _ol_geom_flat_interiorpoint_.linearRings(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }

  return interiorPoints;
};

exports.default = _ol_geom_flat_interiorpoint_;

},{"../../array.js":30,"../flat/contains.js":64}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _contains = require("../flat/contains.js");

var _contains2 = _interopRequireDefault(_contains);

var _segments = require("../flat/segments.js");

var _segments2 = _interopRequireDefault(_segments);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_geom_flat_intersectsextent_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */

_ol_geom_flat_intersectsextent_.lineString = function (flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = _extent2.default.extendFlatCoordinates(_extent2.default.createEmpty(), flatCoordinates, offset, end, stride);

  if (!_extent2.default.intersects(extent, coordinatesExtent)) {
    return false;
  }

  if (_extent2.default.containsExtent(extent, coordinatesExtent)) {
    return true;
  }

  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }

  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }

  return _segments2.default.forEach(flatCoordinates, offset, end, stride,
  /**
   * @param {ol.Coordinate} point1 Start point.
   * @param {ol.Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return _extent2.default.intersectsSegment(extent, point1, point2);
  });
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.lineStrings = function (flatCoordinates, offset, ends, stride, extent) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }

    offset = ends[i];
  }

  return false;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.linearRing = function (flatCoordinates, offset, end, stride, extent) {
  if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }

  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }

  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }

  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }

  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }

  return false;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.linearRings = function (flatCoordinates, offset, ends, stride, extent) {
  if (!_ol_geom_flat_intersectsextent_.linearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }

  if (ends.length === 1) {
    return true;
  }

  var i, ii;

  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (_contains2.default.linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      return false;
    }
  }

  return true;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


_ol_geom_flat_intersectsextent_.linearRingss = function (flatCoordinates, offset, endss, stride, extent) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (_ol_geom_flat_intersectsextent_.linearRings(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
};

exports.default = _ol_geom_flat_intersectsextent_;

},{"../../extent.js":55,"../flat/contains.js":64,"../flat/segments.js":72}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_length_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */

_ol_geom_flat_length_.lineString = function (flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  var i;

  for (i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }

  return length;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */


_ol_geom_flat_length_.linearRing = function (flatCoordinates, offset, end, stride) {
  var perimeter = _ol_geom_flat_length_.lineString(flatCoordinates, offset, end, stride);

  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
};

exports.default = _ol_geom_flat_length_;

},{}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reverse = require("../flat/reverse.js");

var _reverse2 = _interopRequireDefault(_reverse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_geom_flat_orient_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */

_ol_geom_flat_orient_.linearRingIsClockwise = function (flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }

  return edge > 0;
};
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


_ol_geom_flat_orient_.linearRingsAreOriented = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);

    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }

    offset = end;
  }

  return true;
};
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


_ol_geom_flat_orient_.linearRingssAreOriented = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    if (!_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }

  return true;
};
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


_ol_geom_flat_orient_.orientLinearRings = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);

    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;

    if (reverse) {
      _reverse2.default.coordinates(flatCoordinates, offset, end, stride);
    }

    offset = end;
  }

  return offset;
};
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


_ol_geom_flat_orient_.orientLinearRingss = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = _ol_geom_flat_orient_.orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }

  return offset;
};

exports.default = _ol_geom_flat_orient_;

},{"../flat/reverse.js":71}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_reverse_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */

_ol_geom_flat_reverse_.coordinates = function (flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    var i;

    for (i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }

    offset += stride;
    end -= stride;
  }
};

exports.default = _ol_geom_flat_reverse_;

},{}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_segments_ = {};
/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */

_ol_geom_flat_segments_.forEach = function (flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;

  for (; offset + stride < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);

    if (ret) {
      return ret;
    }

    point1[0] = point2[0];
    point1[1] = point2[1];
  }

  return false;
};

exports.default = _ol_geom_flat_segments_;

},{}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require("../../math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
var _ol_geom_flat_simplify_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array.<number>} Simplified line string.
 */

_ol_geom_flat_simplify_.lineString = function (flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];

  if (!highQuality) {
    end = _ol_geom_flat_simplify_.radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }

  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.douglasPeucker = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;

  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }
  /** @type {Array.<number>} */


  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array.<number>} */

  var stack = [offset, end - stride];
  var index = 0;
  var i;

  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];

    for (i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];

      var squaredDistance = _math2.default.squaredSegmentDistance(x, y, x1, y1, x2, y2);

      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }

    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;

      if (first + stride < index) {
        stack.push(first, index);
      }

      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }

  for (i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.douglasPeuckers = function (flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.douglasPeuckerss = function (flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeuckers(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.radialDistance = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1]; // copy first point

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;

  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];

    if (_math2.default.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }

  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }

  return simplifiedOffset;
};
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */


_ol_geom_flat_simplify_.snap = function (value, tolerance) {
  return tolerance * Math.round(value / tolerance);
};
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.quantize = function (flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  } // snap the first coordinate (P1)


  var x1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);

  var y1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);

  offset += stride; // add the first coordinate to the output

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)

  var x2, y2;

  do {
    x2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;

    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);

  while (offset < end) {
    var x3, y3; // snap the next coordinate (P3)

    x3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride; // skip P3 if it is equal to P2

    if (x3 == x2 && y3 == y2) {
      continue;
    } // calculate the delta between P1 and P2


    var dx1 = x2 - x1;
    var dy1 = y2 - y1; // calculate the delta between P3 and P1

    var dx2 = x3 - x1;
    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3

    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3


    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  } // add the last point (P2)


  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.quantizes = function (flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


_ol_geom_flat_simplify_.quantizess = function (flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.quantizes(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
};

exports.default = _ol_geom_flat_simplify_;

},{"../../math.js":124}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_straightchunk_ = {};
/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array.<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */

_ol_geom_flat_straightchunk_.lineString = function (maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;

  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];

    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);

      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));

        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }

          m = 0;
          start = i - stride;
        }
      }

      m12 = m23;
      x12 = x23;
      y12 = y23;
    }

    x1 = x2;
    y1 = y2;
  }

  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
};

exports.default = _ol_geom_flat_straightchunk_;

},{}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require("../../math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_geom_flat_textpath_ = {};
/**
 * @param {Array.<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {function(string):number} measure Measure function returning the
 * width of the character passed as 1st argument.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was
 * exceeded. Entries of the array are x, y, anchorX, angle, chunk.
 */

_ol_geom_flat_textpath_.lineString = function (flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
  var result = []; // Keep text upright

  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];
  var numChars = text.length;
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  var chunk = '';
  var chunkLength = 0;
  var data, index, previousAngle;

  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text.charAt(index);
    chunk = reverse ? char + chunk : chunk + char;
    var charLength = measure(chunk) - chunkLength;
    chunkLength += charLength;
    var charM = startM + charLength / 2;

    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }

    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;

      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }

    var interpolate = segmentPos / segmentLength;

    var x = _math2.default.lerp(x1, x2, interpolate);

    var y = _math2.default.lerp(y1, y2, interpolate);

    if (previousAngle == angle) {
      if (reverse) {
        data[0] = x;
        data[1] = y;
        data[2] = charLength / 2;
      }

      data[4] = chunk;
    } else {
      chunk = char;
      chunkLength = charLength;
      data = [x, y, charLength / 2, angle, chunk];

      if (reverse) {
        result.unshift(data);
      } else {
        result.push(data);
      }

      previousAngle = angle;
    }

    startM += charLength;
  }

  return result;
};

exports.default = _ol_geom_flat_textpath_;

},{"../../math.js":124}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _area = require("../flat/area.js");

var _area2 = _interopRequireDefault(_area);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_geom_flat_topology_ = {};
/**
 * Check if the linestring is a boundary.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring is a boundary.
 */

_ol_geom_flat_topology_.lineStringIsClosed = function (flatCoordinates, offset, end, stride) {
  var lastCoord = end - stride;

  if (flatCoordinates[offset] === flatCoordinates[lastCoord] && flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {
    return !!_area2.default.linearRing(flatCoordinates, offset, end, stride);
  }

  return false;
};

exports.default = _ol_geom_flat_topology_;

},{"../flat/area.js":62}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_transform_ = {};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */

_ol_geom_flat_transform_.transform2D = function (flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j;

  for (j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array.<number>} anchor Rotation anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */


_ol_geom_flat_transform_.rotate = function (flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};
/**
 * Scale the coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array.<number>} anchor Scale anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */


_ol_geom_flat_transform_.scale = function (flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */


_ol_geom_flat_transform_.translate = function (flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j, k;

  for (j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;

    for (k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
};

exports.default = _ol_geom_flat_transform_;

},{}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _object = require("../object.js");

var _object2 = _interopRequireDefault(_object);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _transform = require("../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _proj = require("../proj.js");

var _proj2 = _interopRequireDefault(_proj);

var _units = require("../proj/units.js");

var _units2 = _interopRequireDefault(_units);

var _transform3 = require("../transform.js");

var _transform4 = _interopRequireDefault(_transform3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @api
 */
var _ol_geom_Geometry_ = function () {
  _object2.default.call(this);
  /**
   * @private
   * @type {ol.Extent}
   */


  this.extent_ = _extent2.default.createEmpty();
  /**
   * @private
   * @type {number}
   */

  this.extentRevision_ = -1;
  /**
   * @protected
   * @type {Object.<string, ol.geom.Geometry>}
   */

  this.simplifiedGeometryCache = {};
  /**
   * @protected
   * @type {number}
   */

  this.simplifiedGeometryMaxMinSquaredTolerance = 0;
  /**
   * @protected
   * @type {number}
   */

  this.simplifiedGeometryRevision = 0;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.tmpTransform_ = _transform4.default.create();
};

_index2.default.inherits(_ol_geom_Geometry_, _object2.default);
/**
 * Make a complete copy of the geometry.
 * @abstract
 * @return {!ol.geom.Geometry} Clone.
 */


_ol_geom_Geometry_.prototype.clone = function () {};
/**
 * @abstract
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.Coordinate} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @return {number} Minimum squared distance.
 */


_ol_geom_Geometry_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {};
/**
 * Return the closest point of the geometry to the passed point as
 * {@link ol.Coordinate coordinate}.
 * @param {ol.Coordinate} point Point.
 * @param {ol.Coordinate=} opt_closestPoint Closest point.
 * @return {ol.Coordinate} Closest point.
 * @api
 */


_ol_geom_Geometry_.prototype.getClosestPoint = function (point, opt_closestPoint) {
  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
  this.closestPointXY(point[0], point[1], closestPoint, Infinity);
  return closestPoint;
};
/**
 * Returns true if this geometry includes the specified coordinate. If the
 * coordinate is on the boundary of the geometry, returns false.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} Contains coordinate.
 * @api
 */


_ol_geom_Geometry_.prototype.intersectsCoordinate = function (coordinate) {
  return this.containsXY(coordinate[0], coordinate[1]);
};
/**
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @protected
 * @return {ol.Extent} extent Extent.
 */


_ol_geom_Geometry_.prototype.computeExtent = function (extent) {};
/**
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


_ol_geom_Geometry_.prototype.containsXY = _functions2.default.FALSE;
/**
 * Get the extent of the geometry.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} extent Extent.
 * @api
 */

_ol_geom_Geometry_.prototype.getExtent = function (opt_extent) {
  if (this.extentRevision_ != this.getRevision()) {
    this.extent_ = this.computeExtent(this.extent_);
    this.extentRevision_ = this.getRevision();
  }

  return _extent2.default.returnOrUpdate(this.extent_, opt_extent);
};
/**
 * Rotate the geometry around a given coordinate. This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} angle Rotation angle in radians.
 * @param {ol.Coordinate} anchor The rotation center.
 * @api
 */


_ol_geom_Geometry_.prototype.rotate = function (angle, anchor) {};
/**
 * Scale the geometry (with an optional origin).  This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} sx The scaling factor in the x-direction.
 * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
 *     sx).
 * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center
 *     of the geometry extent).
 * @api
 */


_ol_geom_Geometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {};
/**
 * Create a simplified version of this geometry.  For linestrings, this uses
 * the the {@link
 * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * Douglas Peucker} algorithm.  For polygons, a quantization-based
 * simplification is used to preserve topology.
 * @function
 * @param {number} tolerance The tolerance distance for simplification.
 * @return {ol.geom.Geometry} A new, simplified version of the original
 *     geometry.
 * @api
 */


_ol_geom_Geometry_.prototype.simplify = function (tolerance) {
  return this.getSimplifiedGeometry(tolerance * tolerance);
};
/**
 * Create a simplified version of this geometry using the Douglas Peucker
 * algorithm.
 * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * @abstract
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.Geometry} Simplified geometry.
 */


_ol_geom_Geometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {};
/**
 * Get the type of this geometry.
 * @abstract
 * @return {ol.geom.GeometryType} Geometry type.
 */


_ol_geom_Geometry_.prototype.getType = function () {};
/**
 * Apply a transform function to each coordinate of the geometry.
 * The geometry is modified in place.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 * @abstract
 * @param {ol.TransformFunction} transformFn Transform.
 */


_ol_geom_Geometry_.prototype.applyTransform = function (transformFn) {};
/**
 * Test if the geometry and the passed extent intersect.
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @return {boolean} `true` if the geometry and the extent intersect.
 */


_ol_geom_Geometry_.prototype.intersectsExtent = function (extent) {};
/**
 * Translate the geometry.  This modifies the geometry coordinates in place.  If
 * instead you want a new geometry, first `clone()` this geometry.
 * @abstract
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 */


_ol_geom_Geometry_.prototype.translate = function (deltaX, deltaY) {};
/**
 * Transform each coordinate of the geometry from one coordinate reference
 * system to another. The geometry is modified in place.
 * For example, a line will be transformed to a line and a circle to a circle.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 *
 * @param {ol.ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @param {ol.ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @return {ol.geom.Geometry} This geometry.  Note that original geometry is
 *     modified in place.
 * @api
 */


_ol_geom_Geometry_.prototype.transform = function (source, destination) {
  var tmpTransform = this.tmpTransform_;
  source = _proj2.default.get(source);
  var transformFn = source.getUnits() == _units2.default.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {
    var pixelExtent = source.getExtent();
    var projectedExtent = source.getWorldExtent();

    var scale = _extent2.default.getHeight(projectedExtent) / _extent2.default.getHeight(pixelExtent);

    _transform4.default.compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);

    _transform2.default.transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);

    return _proj2.default.getTransform(source, destination)(inCoordinates, outCoordinates, stride);
  } : _proj2.default.getTransform(source, destination);
  this.applyTransform(transformFn);
  return this;
};

exports.default = _ol_geom_Geometry_;

},{"../extent.js":55,"../functions.js":61,"../geom/flat/transform.js":77,"../index.js":90,"../object.js":126,"../proj.js":142,"../proj/units.js":149,"../transform.js":244}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
var _ol_geom_GeometryLayout_ = {
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
};
exports.default = _ol_geom_GeometryLayout_;

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
var _ol_geom_GeometryType_ = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};
exports.default = _ol_geom_GeometryType_;

},{}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require("../geom/geometrylayout.js");

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require("../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _simplegeometry = require("../geom/simplegeometry.js");

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _area = require("../geom/flat/area.js");

var _area2 = _interopRequireDefault(_area);

var _closest = require("../geom/flat/closest.js");

var _closest2 = _interopRequireDefault(_closest);

var _deflate = require("../geom/flat/deflate.js");

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require("../geom/flat/inflate.js");

var _inflate2 = _interopRequireDefault(_inflate);

var _simplify = require("../geom/flat/simplify.js");

var _simplify2 = _interopRequireDefault(_simplify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_LinearRing_ = function (coordinates, opt_layout) {
  _simplegeometry2.default.call(this);
  /**
   * @private
   * @type {number}
   */


  this.maxDelta_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDeltaRevision_ = -1;
  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_LinearRing_, _simplegeometry2.default);
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LinearRing} Clone.
 * @override
 * @api
 */


_ol_geom_LinearRing_.prototype.clone = function () {
  var linearRing = new _ol_geom_LinearRing_(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return linearRing;
};
/**
 * @inheritDoc
 */


_ol_geom_LinearRing_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_closest2.default.getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }

  return _closest2.default.getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
/**
 * Return the area of the linear ring on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */


_ol_geom_LinearRing_.prototype.getArea = function () {
  return _area2.default.linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
/**
 * Return the coordinates of the linear ring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */


_ol_geom_LinearRing_.prototype.getCoordinates = function () {
  return _inflate2.default.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
/**
 * @inheritDoc
 */


_ol_geom_LinearRing_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = _simplify2.default.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLinearRing = new _ol_geom_LinearRing_(null);
  simplifiedLinearRing.setFlatCoordinates(_geometrylayout2.default.XY, simplifiedFlatCoordinates);
  return simplifiedLinearRing;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_LinearRing_.prototype.getType = function () {
  return _geometrytype2.default.LINEAR_RING;
};
/**
 * @inheritDoc
 */


_ol_geom_LinearRing_.prototype.intersectsExtent = function (extent) {};
/**
 * Set the coordinates of the linear ring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_LinearRing_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = _deflate2.default.coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */


_ol_geom_LinearRing_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};

exports.default = _ol_geom_LinearRing_;

},{"../extent.js":55,"../geom/flat/area.js":62,"../geom/flat/closest.js":63,"../geom/flat/deflate.js":65,"../geom/flat/inflate.js":66,"../geom/flat/simplify.js":73,"../geom/geometrylayout.js":79,"../geom/geometrytype.js":80,"../geom/simplegeometry.js":84,"../index.js":90}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require("../geom/geometrylayout.js");

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require("../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _simplegeometry = require("../geom/simplegeometry.js");

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _deflate = require("../geom/flat/deflate.js");

var _deflate2 = _interopRequireDefault(_deflate);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {ol.Coordinate} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_Point_ = function (coordinates, opt_layout) {
  _simplegeometry2.default.call(this);

  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_Point_, _simplegeometry2.default);
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Point} Clone.
 * @override
 * @api
 */


_ol_geom_Point_.prototype.clone = function () {
  var point = new _ol_geom_Point_(null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return point;
};
/**
 * @inheritDoc
 */


_ol_geom_Point_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  var flatCoordinates = this.flatCoordinates;

  var squaredDistance = _math2.default.squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);

  if (squaredDistance < minSquaredDistance) {
    var stride = this.stride;
    var i;

    for (i = 0; i < stride; ++i) {
      closestPoint[i] = flatCoordinates[i];
    }

    closestPoint.length = stride;
    return squaredDistance;
  } else {
    return minSquaredDistance;
  }
};
/**
 * Return the coordinate of the point.
 * @return {ol.Coordinate} Coordinates.
 * @override
 * @api
 */


_ol_geom_Point_.prototype.getCoordinates = function () {
  return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
};
/**
 * @inheritDoc
 */


_ol_geom_Point_.prototype.computeExtent = function (extent) {
  return _extent2.default.createOrUpdateFromCoordinate(this.flatCoordinates, extent);
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Point_.prototype.getType = function () {
  return _geometrytype2.default.POINT;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Point_.prototype.intersectsExtent = function (extent) {
  return _extent2.default.containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Point_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = _deflate2.default.coordinate(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */


_ol_geom_Point_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};

exports.default = _ol_geom_Point_;

},{"../extent.js":55,"../geom/flat/deflate.js":65,"../geom/geometrylayout.js":79,"../geom/geometrytype.js":80,"../geom/simplegeometry.js":84,"../index.js":90,"../math.js":124}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../array.js");

var _array2 = _interopRequireDefault(_array);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require("../geom/geometrylayout.js");

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require("../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _linearring = require("../geom/linearring.js");

var _linearring2 = _interopRequireDefault(_linearring);

var _point = require("../geom/point.js");

var _point2 = _interopRequireDefault(_point);

var _simplegeometry = require("../geom/simplegeometry.js");

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _area = require("../geom/flat/area.js");

var _area2 = _interopRequireDefault(_area);

var _closest = require("../geom/flat/closest.js");

var _closest2 = _interopRequireDefault(_closest);

var _contains = require("../geom/flat/contains.js");

var _contains2 = _interopRequireDefault(_contains);

var _deflate = require("../geom/flat/deflate.js");

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require("../geom/flat/inflate.js");

var _inflate2 = _interopRequireDefault(_inflate);

var _interiorpoint = require("../geom/flat/interiorpoint.js");

var _interiorpoint2 = _interopRequireDefault(_interiorpoint);

var _intersectsextent = require("../geom/flat/intersectsextent.js");

var _intersectsextent2 = _interopRequireDefault(_intersectsextent);

var _orient = require("../geom/flat/orient.js");

var _orient2 = _interopRequireDefault(_orient);

var _simplify = require("../geom/flat/simplify.js");

var _simplify2 = _interopRequireDefault(_simplify);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear
 *     rings that define the polygon. The first linear ring of the array
 *     defines the outer-boundary or surface of the polygon. Each subsequent
 *     linear ring defines a hole in the surface of the polygon. A linear ring
 *     is an array of vertices' coordinates where the first coordinate and the
 *     last are equivalent.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_Polygon_ = function (coordinates, opt_layout) {
  _simplegeometry2.default.call(this);
  /**
   * @type {Array.<number>}
   * @private
   */


  this.ends_ = [];
  /**
   * @private
   * @type {number}
   */

  this.flatInteriorPointRevision_ = -1;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.flatInteriorPoint_ = null;
  /**
   * @private
   * @type {number}
   */

  this.maxDelta_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.maxDeltaRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.orientedRevision_ = -1;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.orientedFlatCoordinates_ = null;
  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_Polygon_, _simplegeometry2.default);
/**
 * Append the passed linear ring to this polygon.
 * @param {ol.geom.LinearRing} linearRing Linear ring.
 * @api
 */


_ol_geom_Polygon_.prototype.appendLinearRing = function (linearRing) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = linearRing.getFlatCoordinates().slice();
  } else {
    _array2.default.extend(this.flatCoordinates, linearRing.getFlatCoordinates());
  }

  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};
/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Polygon} Clone.
 * @override
 * @api
 */


_ol_geom_Polygon_.prototype.clone = function () {
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return polygon;
};
/**
 * @inheritDoc
 */


_ol_geom_Polygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }

  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_closest2.default.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }

  return _closest2.default.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
/**
 * @inheritDoc
 */


_ol_geom_Polygon_.prototype.containsXY = function (x, y) {
  return _contains2.default.linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
};
/**
 * Return the area of the polygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */


_ol_geom_Polygon_.prototype.getArea = function () {
  return _area2.default.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
};
/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */


_ol_geom_Polygon_.prototype.getCoordinates = function (opt_right) {
  var flatCoordinates;

  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();

    _orient2.default.orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }

  return _inflate2.default.coordinatess(flatCoordinates, 0, this.ends_, this.stride);
};
/**
 * @return {Array.<number>} Ends.
 */


_ol_geom_Polygon_.prototype.getEnds = function () {
  return this.ends_;
};
/**
 * @return {Array.<number>} Interior point.
 */


_ol_geom_Polygon_.prototype.getFlatInteriorPoint = function () {
  if (this.flatInteriorPointRevision_ != this.getRevision()) {
    var flatCenter = _extent2.default.getCenter(this.getExtent());

    this.flatInteriorPoint_ = _interiorpoint2.default.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
    this.flatInteriorPointRevision_ = this.getRevision();
  }

  return this.flatInteriorPoint_;
};
/**
 * Return an interior point of the polygon.
 * @return {ol.geom.Point} Interior point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 * @api
 */


_ol_geom_Polygon_.prototype.getInteriorPoint = function () {
  return new _point2.default(this.getFlatInteriorPoint(), _geometrylayout2.default.XYM);
};
/**
 * Return the number of rings of the polygon,  this includes the exterior
 * ring and any interior rings.
 *
 * @return {number} Number of rings.
 * @api
 */


_ol_geom_Polygon_.prototype.getLinearRingCount = function () {
  return this.ends_.length;
};
/**
 * Return the Nth linear ring of the polygon geometry. Return `null` if the
 * given index is out of range.
 * The exterior linear ring is available at index `0` and the interior rings
 * at index `1` and beyond.
 *
 * @param {number} index Index.
 * @return {ol.geom.LinearRing} Linear ring.
 * @api
 */


_ol_geom_Polygon_.prototype.getLinearRing = function (index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }

  var linearRing = new _linearring2.default(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return linearRing;
};
/**
 * Return the linear rings of the polygon.
 * @return {Array.<ol.geom.LinearRing>} Linear rings.
 * @api
 */


_ol_geom_Polygon_.prototype.getLinearRings = function () {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var linearRings = [];
  var offset = 0;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var linearRing = new _linearring2.default(null);
    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    linearRings.push(linearRing);
    offset = end;
  }

  return linearRings;
};
/**
 * @return {Array.<number>} Oriented flat coordinates.
 */


_ol_geom_Polygon_.prototype.getOrientedFlatCoordinates = function () {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;

    if (_orient2.default.linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = _orient2.default.orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
    }

    this.orientedRevision_ = this.getRevision();
  }

  return this.orientedFlatCoordinates_;
};
/**
 * @inheritDoc
 */


_ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = _simplify2.default.quantizes(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedPolygon = new _ol_geom_Polygon_(null);
  simplifiedPolygon.setFlatCoordinates(_geometrylayout2.default.XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedPolygon;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Polygon_.prototype.getType = function () {
  return _geometrytype2.default.POLYGON;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_Polygon_.prototype.intersectsExtent = function (extent) {
  return _intersectsextent2.default.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
};
/**
 * Set the coordinates of the polygon.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */


_ol_geom_Polygon_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = _deflate2.default.coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);

    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */


_ol_geom_Polygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {ol.Sphere} sphere The sphere.
 * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @return {ol.geom.Polygon} The "circular" polygon.
 * @api
 */


_ol_geom_Polygon_.circular = function (sphere, center, radius, opt_n) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array.<number>} */

  var flatCoordinates = [];
  var i;

  for (i = 0; i < n; ++i) {
    _array2.default.extend(flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));
  }

  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(_geometrylayout2.default.XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {ol.Extent} extent The extent.
 * @return {ol.geom.Polygon} The polygon.
 * @api
 */


_ol_geom_Polygon_.fromExtent = function (extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(_geometrylayout2.default.XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};
/**
 * Create a regular polygon from a circle.
 * @param {ol.geom.Circle} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {ol.geom.Polygon} Polygon geometry.
 * @api
 */


_ol_geom_Polygon_.fromCircle = function (circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var polygon = new _ol_geom_Polygon_(null, layout);
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);

  for (var i = 0; i < arrayLength; i++) {
    flatCoordinates[i] = 0;
  }

  var ends = [flatCoordinates.length];
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);

  _ol_geom_Polygon_.makeRegular(polygon, circle.getCenter(), circle.getRadius(), opt_angle);

  return polygon;
};
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {ol.geom.Polygon} polygon Polygon geometry.
 * @param {ol.Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */


_ol_geom_Polygon_.makeRegular = function (polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var layout = polygon.getLayout();
  var stride = polygon.getStride();
  var ends = polygon.getEnds();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  var angle, offset;

  for (var i = 0; i <= sides; ++i) {
    offset = i * stride;
    angle = startAngle + _math2.default.modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }

  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
};

exports.default = _ol_geom_Polygon_;

},{"../array.js":30,"../extent.js":55,"../geom/flat/area.js":62,"../geom/flat/closest.js":63,"../geom/flat/contains.js":64,"../geom/flat/deflate.js":65,"../geom/flat/inflate.js":66,"../geom/flat/interiorpoint.js":67,"../geom/flat/intersectsextent.js":68,"../geom/flat/orient.js":70,"../geom/flat/simplify.js":73,"../geom/geometrylayout.js":79,"../geom/geometrytype.js":80,"../geom/linearring.js":81,"../geom/point.js":82,"../geom/simplegeometry.js":84,"../index.js":90,"../math.js":124}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _geometry = require("../geom/geometry.js");

var _geometry2 = _interopRequireDefault(_geometry);

var _geometrylayout = require("../geom/geometrylayout.js");

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _transform = require("../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @constructor
 * @abstract
 * @extends {ol.geom.Geometry}
 * @api
 */
var _ol_geom_SimpleGeometry_ = function () {
  _geometry2.default.call(this);
  /**
   * @protected
   * @type {ol.geom.GeometryLayout}
   */


  this.layout = _geometrylayout2.default.XY;
  /**
   * @protected
   * @type {number}
   */

  this.stride = 2;
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.flatCoordinates = null;
};

_index2.default.inherits(_ol_geom_SimpleGeometry_, _geometry2.default);
/**
 * @param {number} stride Stride.
 * @private
 * @return {ol.geom.GeometryLayout} layout Layout.
 */


_ol_geom_SimpleGeometry_.getLayoutForStride_ = function (stride) {
  var layout;

  if (stride == 2) {
    layout = _geometrylayout2.default.XY;
  } else if (stride == 3) {
    layout = _geometrylayout2.default.XYZ;
  } else if (stride == 4) {
    layout = _geometrylayout2.default.XYZM;
  }

  return (
    /** @type {ol.geom.GeometryLayout} */
    layout
  );
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @return {number} Stride.
 */


_ol_geom_SimpleGeometry_.getStrideForLayout = function (layout) {
  var stride;

  if (layout == _geometrylayout2.default.XY) {
    stride = 2;
  } else if (layout == _geometrylayout2.default.XYZ || layout == _geometrylayout2.default.XYM) {
    stride = 3;
  } else if (layout == _geometrylayout2.default.XYZM) {
    stride = 4;
  }

  return (
    /** @type {number} */
    stride
  );
};
/**
 * @inheritDoc
 */


_ol_geom_SimpleGeometry_.prototype.containsXY = _functions2.default.FALSE;
/**
 * @inheritDoc
 */

_ol_geom_SimpleGeometry_.prototype.computeExtent = function (extent) {
  return _extent2.default.createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};
/**
 * @abstract
 * @return {Array} Coordinates.
 */


_ol_geom_SimpleGeometry_.prototype.getCoordinates = function () {};
/**
 * Return the first coordinate of the geometry.
 * @return {ol.Coordinate} First coordinate.
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.getFirstCoordinate = function () {
  return this.flatCoordinates.slice(0, this.stride);
};
/**
 * @return {Array.<number>} Flat coordinates.
 */


_ol_geom_SimpleGeometry_.prototype.getFlatCoordinates = function () {
  return this.flatCoordinates;
};
/**
 * Return the last coordinate of the geometry.
 * @return {ol.Coordinate} Last point.
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.getLastCoordinate = function () {
  return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
};
/**
 * Return the {@link ol.geom.GeometryLayout layout} of the geometry.
 * @return {ol.geom.GeometryLayout} Layout.
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.getLayout = function () {
  return this.layout;
};
/**
 * @inheritDoc
 */


_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    _obj2.default.clear(this.simplifiedGeometryCache);

    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  } // If squaredTolerance is negative or if we know that simplification will not
  // have any effect then just return this.


  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }

  var key = squaredTolerance.toString();

  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();

    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      this.simplifiedGeometryCache[key] = simplifiedGeometry;
      return simplifiedGeometry;
    } else {
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};
/**
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.SimpleGeometry} Simplified geometry.
 * @protected
 */


_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  return this;
};
/**
 * @return {number} Stride.
 */


_ol_geom_SimpleGeometry_.prototype.getStride = function () {
  return this.stride;
};
/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @protected
 */


_ol_geom_SimpleGeometry_.prototype.setFlatCoordinatesInternal = function (layout, flatCoordinates) {
  this.stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  this.layout = layout;
  this.flatCoordinates = flatCoordinates;
};
/**
 * @abstract
 * @param {Array} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 */


_ol_geom_SimpleGeometry_.prototype.setCoordinates = function (coordinates, opt_layout) {};
/**
 * @param {ol.geom.GeometryLayout|undefined} layout Layout.
 * @param {Array} coordinates Coordinates.
 * @param {number} nesting Nesting.
 * @protected
 */


_ol_geom_SimpleGeometry_.prototype.setLayout = function (layout, coordinates, nesting) {
  /** @type {number} */
  var stride;

  if (layout) {
    stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  } else {
    var i;

    for (i = 0; i < nesting; ++i) {
      if (coordinates.length === 0) {
        this.layout = _geometrylayout2.default.XY;
        this.stride = 2;
        return;
      } else {
        coordinates =
        /** @type {Array} */
        coordinates[0];
      }
    }

    stride = coordinates.length;
    layout = _ol_geom_SimpleGeometry_.getLayoutForStride_(stride);
  }

  this.layout = layout;
  this.stride = stride;
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.applyTransform = function (transformFn) {
  if (this.flatCoordinates) {
    transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
    this.changed();
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.rotate = function (angle, anchor) {
  var flatCoordinates = this.getFlatCoordinates();

  if (flatCoordinates) {
    var stride = this.getStride();

    _transform2.default.rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);

    this.changed();
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {
  var sy = opt_sy;

  if (sy === undefined) {
    sy = sx;
  }

  var anchor = opt_anchor;

  if (!anchor) {
    anchor = _extent2.default.getCenter(this.getExtent());
  }

  var flatCoordinates = this.getFlatCoordinates();

  if (flatCoordinates) {
    var stride = this.getStride();

    _transform2.default.scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);

    this.changed();
  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_geom_SimpleGeometry_.prototype.translate = function (deltaX, deltaY) {
  var flatCoordinates = this.getFlatCoordinates();

  if (flatCoordinates) {
    var stride = this.getStride();

    _transform2.default.translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);

    this.changed();
  }
};
/**
 * @param {ol.geom.SimpleGeometry} simpleGeometry Simple geometry.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed flat coordinates.
 */


_ol_geom_SimpleGeometry_.transform2D = function (simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();

  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return _transform2.default.transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
};

exports.default = _ol_geom_SimpleGeometry_;

},{"../extent.js":55,"../functions.js":61,"../geom/flat/transform.js":77,"../geom/geometry.js":78,"../geom/geometrylayout.js":79,"../index.js":90,"../obj.js":125}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _webgl = require("./webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_has_ = {};
var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */

_ol_has_.FIREFOX = ua.indexOf('firefox') !== -1;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */

_ol_has_.SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */

_ol_has_.WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */

_ol_has_.MAC = ua.indexOf('macintosh') !== -1;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */

_ol_has_.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;
/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */

_ol_has_.CANVAS_LINE_DASH = false;
/**
 * True if both the library and browser support Canvas.  Always `false`
 * if `ol.ENABLE_CANVAS` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.CANVAS = _index2.default.ENABLE_CANVAS &&
/**
 * @return {boolean} Canvas supported.
 */
function () {
  if (!('HTMLCanvasElement' in window)) {
    return false;
  }

  try {
    var context = document.createElement('CANVAS').getContext('2d');

    if (!context) {
      return false;
    } else {
      if (context.setLineDash !== undefined) {
        _ol_has_.CANVAS_LINE_DASH = true;
      }

      return true;
    }
  } catch (e) {
    return false;
  }
}();
/**
 * Indicates if DeviceOrientation is supported in the user's browser.
 * @const
 * @type {boolean}
 * @api
 */


_ol_has_.DEVICE_ORIENTATION = 'DeviceOrientationEvent' in window;
/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.GEOLOCATION = 'geolocation' in navigator;
/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.TOUCH = _index2.default.ASSUME_TOUCH || 'ontouchstart' in window;
/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */

_ol_has_.POINTER = 'PointerEvent' in window;
/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */

_ol_has_.MSPOINTER = !!navigator.msPointerEnabled;
/**
 * True if both OpenLayers and browser support WebGL.  Always `false`
 * if `ol.ENABLE_WEBGL` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */

_ol_has_.WEBGL;

(function () {
  if (_index2.default.ENABLE_WEBGL) {
    var hasWebGL = false;
    var textureSize;
    var
    /** @type {Array.<string>} */
    extensions = [];

    if ('WebGLRenderingContext' in window) {
      try {
        var canvas =
        /** @type {HTMLCanvasElement} */
        document.createElement('CANVAS');

        var gl = _webgl2.default.getContext(canvas, {
          failIfMajorPerformanceCaveat: true
        });

        if (gl) {
          hasWebGL = true;
          textureSize =
          /** @type {number} */
          gl.getParameter(gl.MAX_TEXTURE_SIZE);
          extensions = gl.getSupportedExtensions();
        }
      } catch (e) {// pass
      }
    }

    _ol_has_.WEBGL = hasWebGL;
    _index2.default.WEBGL_EXTENSIONS = extensions;
    _index2.default.WEBGL_MAX_TEXTURE_SIZE = textureSize;
  }
})();

exports.default = _ol_has_;

},{"./index.js":90,"./webgl.js":249}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _imagebase = require("./imagebase.js");

var _imagebase2 = _interopRequireDefault(_imagebase);

var _imagestate = require("./imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _events = require("./events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("./events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.ImageBase}
 * @param {ol.Extent} extent Extent.
 * @param {number|undefined} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageLoadFunctionType} imageLoadFunction Image load function.
 */
var _ol_Image_ = function (extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
  _imagebase2.default.call(this, extent, resolution, pixelRatio, _imagestate2.default.IDLE);
  /**
   * @private
   * @type {string}
   */


  this.src_ = src;
  /**
   * @private
   * @type {HTMLCanvasElement|Image|HTMLVideoElement}
   */

  this.image_ = new Image();

  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */


  this.imageListenerKeys_ = null;
  /**
   * @protected
   * @type {ol.ImageState}
   */

  this.state = _imagestate2.default.IDLE;
  /**
   * @private
   * @type {ol.ImageLoadFunctionType}
   */

  this.imageLoadFunction_ = imageLoadFunction;
};

_index2.default.inherits(_ol_Image_, _imagebase2.default);
/**
 * @inheritDoc
 * @api
 */


_ol_Image_.prototype.getImage = function () {
  return this.image_;
};
/**
 * Tracks loading or read errors.
 *
 * @private
 */


_ol_Image_.prototype.handleImageError_ = function () {
  this.state = _imagestate2.default.ERROR;
  this.unlistenImage_();
  this.changed();
};
/**
 * Tracks successful image load.
 *
 * @private
 */


_ol_Image_.prototype.handleImageLoad_ = function () {
  if (this.resolution === undefined) {
    this.resolution = _extent2.default.getHeight(this.extent) / this.image_.height;
  }

  this.state = _imagestate2.default.LOADED;
  this.unlistenImage_();
  this.changed();
};
/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @override
 * @api
 */


_ol_Image_.prototype.load = function () {
  if (this.state == _imagestate2.default.IDLE || this.state == _imagestate2.default.ERROR) {
    this.state = _imagestate2.default.LOADING;
    this.changed();
    this.imageListenerKeys_ = [_events2.default.listenOnce(this.image_, _eventtype2.default.ERROR, this.handleImageError_, this), _events2.default.listenOnce(this.image_, _eventtype2.default.LOAD, this.handleImageLoad_, this)];
    this.imageLoadFunction_(this, this.src_);
  }
};
/**
 * @param {HTMLCanvasElement|Image|HTMLVideoElement} image Image.
 */


_ol_Image_.prototype.setImage = function (image) {
  this.image_ = image;
};
/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */


_ol_Image_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.imageListenerKeys_ = null;
};

exports.default = _ol_Image_;

},{"./events.js":49,"./events/eventtype.js":53,"./extent.js":55,"./imagebase.js":87,"./imagestate.js":89,"./index.js":90}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _eventtarget = require("./events/eventtarget.js");

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require("./events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @extends {ol.events.EventTarget}
 * @param {ol.Extent} extent Extent.
 * @param {number|undefined} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.ImageState} state State.
 */
var _ol_ImageBase_ = function (extent, resolution, pixelRatio, state) {
  _eventtarget2.default.call(this);
  /**
   * @protected
   * @type {ol.Extent}
   */


  this.extent = extent;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.resolution = resolution;
  /**
   * @protected
   * @type {ol.ImageState}
   */

  this.state = state;
};

_index2.default.inherits(_ol_ImageBase_, _eventtarget2.default);
/**
 * @protected
 */


_ol_ImageBase_.prototype.changed = function () {
  this.dispatchEvent(_eventtype2.default.CHANGE);
};
/**
 * @return {ol.Extent} Extent.
 */


_ol_ImageBase_.prototype.getExtent = function () {
  return this.extent;
};
/**
 * @abstract
 * @return {HTMLCanvasElement|Image|HTMLVideoElement} Image.
 */


_ol_ImageBase_.prototype.getImage = function () {};
/**
 * @return {number} PixelRatio.
 */


_ol_ImageBase_.prototype.getPixelRatio = function () {
  return this.pixelRatio_;
};
/**
 * @return {number} Resolution.
 */


_ol_ImageBase_.prototype.getResolution = function () {
  return (
    /** @type {number} */
    this.resolution
  );
};
/**
 * @return {ol.ImageState} State.
 */


_ol_ImageBase_.prototype.getState = function () {
  return this.state;
};
/**
 * Load not yet loaded URI.
 * @abstract
 */


_ol_ImageBase_.prototype.load = function () {};

exports.default = _ol_ImageBase_;

},{"./events/eventtarget.js":52,"./events/eventtype.js":53,"./index.js":90}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _imagebase = require("./imagebase.js");

var _imagebase2 = _interopRequireDefault(_imagebase);

var _imagestate = require("./imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.ImageBase}
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {ol.ImageCanvasLoader=} opt_loader Optional loader function to
 *     support asynchronous canvas drawing.
 */
var _ol_ImageCanvas_ = function (extent, resolution, pixelRatio, canvas, opt_loader) {
  /**
   * Optional canvas loader function.
   * @type {?ol.ImageCanvasLoader}
   * @private
   */
  this.loader_ = opt_loader !== undefined ? opt_loader : null;
  var state = opt_loader !== undefined ? _imagestate2.default.IDLE : _imagestate2.default.LOADED;

  _imagebase2.default.call(this, extent, resolution, pixelRatio, state);
  /**
   * @private
   * @type {HTMLCanvasElement}
   */


  this.canvas_ = canvas;
  /**
   * @private
   * @type {Error}
   */

  this.error_ = null;
};

_index2.default.inherits(_ol_ImageCanvas_, _imagebase2.default);
/**
 * Get any error associated with asynchronous rendering.
 * @return {Error} Any error that occurred during rendering.
 */


_ol_ImageCanvas_.prototype.getError = function () {
  return this.error_;
};
/**
 * Handle async drawing complete.
 * @param {Error} err Any error during drawing.
 * @private
 */


_ol_ImageCanvas_.prototype.handleLoad_ = function (err) {
  if (err) {
    this.error_ = err;
    this.state = _imagestate2.default.ERROR;
  } else {
    this.state = _imagestate2.default.LOADED;
  }

  this.changed();
};
/**
 * @inheritDoc
 */


_ol_ImageCanvas_.prototype.load = function () {
  if (this.state == _imagestate2.default.IDLE) {
    this.state = _imagestate2.default.LOADING;
    this.changed();
    this.loader_(this.handleLoad_.bind(this));
  }
};
/**
 * @inheritDoc
 */


_ol_ImageCanvas_.prototype.getImage = function () {
  return this.canvas_;
};

exports.default = _ol_ImageCanvas_;

},{"./imagebase.js":87,"./imagestate.js":89,"./index.js":90}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {number}
 */
var _ol_ImageState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
};
exports.default = _ol_ImageState_;

},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_ = {};
/**
 * Constants defined with the define tag cannot be changed in application
 * code, but can be set at compile time.
 * Some reduce the size of the build in advanced compile mode.
 */

/**
 * @define {boolean} Assume touch.  Default is `false`.
 */

_ol_.ASSUME_TOUCH = false;
/**
 * TODO: rename this to something having to do with tile grids
 * see https://github.com/openlayers/openlayers/issues/2076
 * @define {number} Default maximum zoom for default tile grids.
 */

_ol_.DEFAULT_MAX_ZOOM = 42;
/**
 * @define {number} Default min zoom level for the map view.  Default is `0`.
 */

_ol_.DEFAULT_MIN_ZOOM = 0;
/**
 * @define {number} Default maximum allowed threshold  (in pixels) for
 *     reprojection triangulation. Default is `0.5`.
 */

_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;
/**
 * @define {number} Default tile size.
 */

_ol_.DEFAULT_TILE_SIZE = 256;
/**
 * @define {string} Default WMS version.
 */

_ol_.DEFAULT_WMS_VERSION = '1.3.0';
/**
 * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the Canvas renderer from the build.
 */

_ol_.ENABLE_CANVAS = true;
/**
 * @define {boolean} Enable integration with the Proj4js library.  Default is
 *     `true`.
 */

_ol_.ENABLE_PROJ4JS = true;
/**
 * @define {boolean} Enable automatic reprojection of raster sources. Default is
 *     `true`.
 */

_ol_.ENABLE_RASTER_REPROJECTION = true;
/**
 * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the WebGL renderer from the build.
 */

_ol_.ENABLE_WEBGL = true;
/**
 * @define {boolean} Include debuggable shader sources.  Default is `true`.
 *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`
 *     is `true`).
 */

_ol_.DEBUG_WEBGL = true;
/**
 * @define {number} The size in pixels of the first atlas image. Default is
 * `256`.
 */

_ol_.INITIAL_ATLAS_SIZE = 256;
/**
 * @define {number} The maximum size in pixels of atlas images. Default is
 * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is
 * used instead).
 */

_ol_.MAX_ATLAS_SIZE = -1;
/**
 * @define {number} Maximum mouse wheel delta.
 */

_ol_.MOUSEWHEELZOOM_MAXDELTA = 1;
/**
 * @define {number} Maximum width and/or height extent ratio that determines
 * when the overview map should be zoomed out.
 */

_ol_.OVERVIEWMAP_MAX_RATIO = 0.75;
/**
 * @define {number} Minimum width and/or height extent ratio that determines
 * when the overview map should be zoomed in.
 */

_ol_.OVERVIEWMAP_MIN_RATIO = 0.1;
/**
 * @define {number} Maximum number of source tiles for raster reprojection of
 *     a single tile.
 *     If too many source tiles are determined to be loaded to create a single
 *     reprojected tile the browser can become unresponsive or even crash.
 *     This can happen if the developer defines projections improperly and/or
 *     with unlimited extents.
 *     If too many tiles are required, no tiles are loaded and
 *     `ol.TileState.ERROR` state is set. Default is `100`.
 */

_ol_.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;
/**
 * @define {number} Maximum number of subdivision steps during raster
 *     reprojection triangulation. Prevents high memory usage and large
 *     number of proj4 calls (for certain transformations and areas).
 *     At most `2*(2^this)` triangles are created for each triangulated
 *     extent (tile/image). Default is `10`.
 */

_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;
/**
 * @define {number} Maximum allowed size of triangle relative to world width.
 *     When transforming corners of world extent between certain projections,
 *     the resulting triangulation seems to have zero error and no subdivision
 *     is performed.
 *     If the triangle width is more than this (relative to world width; 0-1),
 *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).
 *     Default is `0.25`.
 */

_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @define {number} Tolerance for geometry simplification in device pixels.
 */

_ol_.SIMPLIFY_TOLERANCE = 0.5;
/**
 * @define {number} Texture cache high water mark.
 */

_ol_.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;
/**
 * @define {string} OpenLayers version.
 */

_ol_.VERSION = 'v4.6.4';
/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @const
 * @type {number|undefined}
 */

_ol_.WEBGL_MAX_TEXTURE_SIZE; // value is set in `ol.has`

/**
 * List of supported WebGL extensions.
 * @const
 * @type {Array.<string>}
 */

_ol_.WEBGL_EXTENSIONS; // value is set in `ol.has`

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     ol.inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */

_ol_.inherits = function (childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
};
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */


_ol_.nullFunction = function () {};
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */


_ol_.getUid = function (obj) {
  return obj.ol_uid || (obj.ol_uid = ++_ol_.uidCounter_);
};
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */


_ol_.uidCounter_ = 0;
exports.default = _ol_;

},{}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _collection = require("./collection.js");

var _collection2 = _interopRequireDefault(_collection);

var _kinetic = require("./kinetic.js");

var _kinetic2 = _interopRequireDefault(_kinetic);

var _doubleclickzoom = require("./interaction/doubleclickzoom.js");

var _doubleclickzoom2 = _interopRequireDefault(_doubleclickzoom);

var _dragpan = require("./interaction/dragpan.js");

var _dragpan2 = _interopRequireDefault(_dragpan);

var _dragrotate = require("./interaction/dragrotate.js");

var _dragrotate2 = _interopRequireDefault(_dragrotate);

var _dragzoom = require("./interaction/dragzoom.js");

var _dragzoom2 = _interopRequireDefault(_dragzoom);

var _keyboardpan = require("./interaction/keyboardpan.js");

var _keyboardpan2 = _interopRequireDefault(_keyboardpan);

var _keyboardzoom = require("./interaction/keyboardzoom.js");

var _keyboardzoom2 = _interopRequireDefault(_keyboardzoom);

var _mousewheelzoom = require("./interaction/mousewheelzoom.js");

var _mousewheelzoom2 = _interopRequireDefault(_mousewheelzoom);

var _pinchrotate = require("./interaction/pinchrotate.js");

var _pinchrotate2 = _interopRequireDefault(_pinchrotate);

var _pinchzoom = require("./interaction/pinchzoom.js");

var _pinchzoom2 = _interopRequireDefault(_pinchzoom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_interaction_ = {};
/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link ol.interaction.Interaction} instances and insert them into a
 * {@link ol.Collection} in the order you want before creating your
 * {@link ol.Map} instance. The default set of interactions, in sequence, is:
 * * {@link ol.interaction.DragRotate}
 * * {@link ol.interaction.DoubleClickZoom}
 * * {@link ol.interaction.DragPan}
 * * {@link ol.interaction.PinchRotate}
 * * {@link ol.interaction.PinchZoom}
 * * {@link ol.interaction.KeyboardPan}
 * * {@link ol.interaction.KeyboardZoom}
 * * {@link ol.interaction.MouseWheelZoom}
 * * {@link ol.interaction.DragZoom}
 *
 * @param {olx.interaction.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.interaction.Interaction>} A collection of
 * interactions to be used with the ol.Map constructor's interactions option.
 * @api
 */

_ol_interaction_.defaults = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new _collection2.default();
  var kinetic = new _kinetic2.default(-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;

  if (altShiftDragRotate) {
    interactions.push(new _dragrotate2.default());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;

  if (doubleClickZoom) {
    interactions.push(new _doubleclickzoom2.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;

  if (dragPan) {
    interactions.push(new _dragpan2.default({
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;

  if (pinchRotate) {
    interactions.push(new _pinchrotate2.default());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;

  if (pinchZoom) {
    interactions.push(new _pinchzoom2.default({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;

  if (keyboard) {
    interactions.push(new _keyboardpan2.default());
    interactions.push(new _keyboardzoom2.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;

  if (mouseWheelZoom) {
    interactions.push(new _mousewheelzoom2.default({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;

  if (shiftDragZoom) {
    interactions.push(new _dragzoom2.default({
      duration: options.zoomDuration
    }));
  }

  return interactions;
};

exports.default = _ol_interaction_;

},{"./collection.js":35,"./interaction/doubleclickzoom.js":92,"./interaction/dragpan.js":94,"./interaction/dragrotate.js":95,"./interaction/dragzoom.js":96,"./interaction/keyboardpan.js":98,"./interaction/keyboardzoom.js":99,"./interaction/mousewheelzoom.js":100,"./interaction/pinchrotate.js":101,"./interaction/pinchzoom.js":102,"./kinetic.js":105}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _mapbrowsereventtype = require("../mapbrowsereventtype.js");

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.DoubleClickZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DoubleClickZoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {number}
   */

  this.delta_ = options.delta ? options.delta : 1;

  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_DoubleClickZoom_.handleEvent
  });
  /**
   * @private
   * @type {number}
   */


  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_interaction_DoubleClickZoom_, _interaction2.default);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.DoubleClickZoom}
 * @api
 */


_ol_interaction_DoubleClickZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  var browserEvent = mapBrowserEvent.originalEvent;

  if (mapBrowserEvent.type == _mapbrowsereventtype2.default.DBLCLICK) {
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();

    _interaction2.default.zoomByDelta(view, delta, anchor, this.duration_);

    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }

  return !stopEvent;
};

exports.default = _ol_interaction_DoubleClickZoom_;

},{"../index.js":90,"../interaction/interaction.js":97,"../mapbrowsereventtype.js":119}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _event = require("../events/event.js");

var _event2 = _interopRequireDefault(_event);

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _condition = require("../events/condition.js");

var _condition2 = _interopRequireDefault(_condition);

var _pointer = require("../interaction/pointer.js");

var _pointer2 = _interopRequireDefault(_pointer);

var _box = require("../render/box.js");

var _box2 = _interopRequireDefault(_box);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME draw drag box

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link ol.interaction.DragZoom} and
 * {@link ol.interaction.DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires ol.interaction.DragBox.Event
 * @param {olx.interaction.DragBoxOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragBox_ = function (opt_options) {
  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_DragBox_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragBox_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragBox_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};
  /**
   * @type {ol.render.Box}
   * @private
   */

  this.box_ = new _box2.default(options.className || 'ol-dragbox');
  /**
   * @type {number}
   * @private
   */

  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
  /**
   * @type {ol.Pixel}
   * @private
   */

  this.startPixel_ = null;
  /**
   * @private
   * @type {ol.EventsConditionType}
   */

  this.condition_ = options.condition ? options.condition : _condition2.default.always;
  /**
   * @private
   * @type {ol.DragBoxEndConditionType}
   */

  this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _ol_interaction_DragBox_.defaultBoxEndCondition;
};

_index2.default.inherits(_ol_interaction_DragBox_, _pointer2.default);
/**
 * The default condition for determining whether the boxend event
 * should fire.
 * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent
 *     leading to the box end.
 * @param {ol.Pixel} startPixel The starting pixel of the box.
 * @param {ol.Pixel} endPixel The end pixel of the box.
 * @return {boolean} Whether or not the boxend condition should be fired.
 * @this {ol.interaction.DragBox}
 */


_ol_interaction_DragBox_.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
  var width = endPixel[0] - startPixel[0];
  var height = endPixel[1] - startPixel[1];
  return width * width + height * height >= this.minArea_;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragBox}
 * @private
 */


_ol_interaction_DragBox_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return;
  }

  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
  this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
};
/**
 * Returns geometry of last drawn box.
 * @return {ol.geom.Polygon} Geometry.
 * @api
 */


_ol_interaction_DragBox_.prototype.getGeometry = function () {
  return this.box_.getGeometry();
};
/**
 * To be overridden by child classes.
 * FIXME: use constructor option instead of relying on overriding.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @protected
 */


_ol_interaction_DragBox_.prototype.onBoxEnd = _index2.default.nullFunction;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */

_ol_interaction_DragBox_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return true;
  }

  this.box_.setMap(null);

  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
    this.onBoxEnd(mapBrowserEvent);
    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
  }

  return false;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */


_ol_interaction_DragBox_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (_condition2.default.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    this.startPixel_ = mapBrowserEvent.pixel;
    this.box_.setMap(mapBrowserEvent.map);
    this.box_.setPixels(this.startPixel_, this.startPixel_);
    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
    return true;
  } else {
    return false;
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_interaction_DragBox_.EventType_ = {
  /**
   * Triggered upon drag box start.
   * @event ol.interaction.DragBox.Event#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event ol.interaction.DragBox.Event#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event ol.interaction.DragBox.Event#boxend
   * @api
   */
  BOXEND: 'boxend'
};
/**
 * @classdesc
 * Events emitted by {@link ol.interaction.DragBox} instances are instances of
 * this type.
 *
 * @param {string} type The event type.
 * @param {ol.Coordinate} coordinate The event coordinate.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.
 * @extends {ol.events.Event}
 * @constructor
 * @implements {oli.DragBoxEvent}
 */

_ol_interaction_DragBox_.Event = function (type, coordinate, mapBrowserEvent) {
  _event2.default.call(this, type);
  /**
   * The coordinate of the drag event.
   * @const
   * @type {ol.Coordinate}
   * @api
   */


  this.coordinate = coordinate;
  /**
   * @const
   * @type {ol.MapBrowserEvent}
   * @api
   */

  this.mapBrowserEvent = mapBrowserEvent;
};

_index2.default.inherits(_ol_interaction_DragBox_.Event, _event2.default);

exports.default = _ol_interaction_DragBox_;

},{"../events/condition.js":50,"../events/event.js":51,"../index.js":90,"../interaction/pointer.js":103,"../render/box.js":150}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _viewhint = require("../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _coordinate = require("../coordinate.js");

var _coordinate2 = _interopRequireDefault(_coordinate);

var _easing = require("../easing.js");

var _easing2 = _interopRequireDefault(_easing);

var _condition = require("../events/condition.js");

var _condition2 = _interopRequireDefault(_condition);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _pointer = require("../interaction/pointer.js");

var _pointer2 = _interopRequireDefault(_pointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragPanOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragPan_ = function (opt_options) {
  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_DragPan_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragPan_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragPan_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {ol.Kinetic|undefined}
   */

  this.kinetic_ = options.kinetic;
  /**
   * @type {ol.Pixel}
   */

  this.lastCentroid = null;
  /**
   * @type {number}
   */

  this.lastPointersCount_;
  /**
   * @private
   * @type {ol.EventsConditionType}
   */

  this.condition_ = options.condition ? options.condition : _condition2.default.noModifierKeys;
  /**
   * @private
   * @type {boolean}
   */

  this.noKinetic_ = false;
};

_index2.default.inherits(_ol_interaction_DragPan_, _pointer2.default);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragPan}
 * @private
 */


_ol_interaction_DragPan_.handleDragEvent_ = function (mapBrowserEvent) {
  var targetPointers = this.targetPointers;

  var centroid = _pointer2.default.centroid(targetPointers);

  if (targetPointers.length == this.lastPointersCount_) {
    if (this.kinetic_) {
      this.kinetic_.update(centroid[0], centroid[1]);
    }

    if (this.lastCentroid) {
      var deltaX = this.lastCentroid[0] - centroid[0];
      var deltaY = centroid[1] - this.lastCentroid[1];
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var viewState = view.getState();
      var center = [deltaX, deltaY];

      _coordinate2.default.scale(center, viewState.resolution);

      _coordinate2.default.rotate(center, viewState.rotation);

      _coordinate2.default.add(center, viewState.center);

      center = view.constrainCenter(center);
      view.setCenter(center);
    }
  } else if (this.kinetic_) {
    // reset so we don't overestimate the kinetic energy after
    // after one finger down, tiny drag, second finger down
    this.kinetic_.begin();
  }

  this.lastCentroid = centroid;
  this.lastPointersCount_ = targetPointers.length;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */


_ol_interaction_DragPan_.handleUpEvent_ = function (mapBrowserEvent) {
  var map = mapBrowserEvent.map;
  var view = map.getView();

  if (this.targetPointers.length === 0) {
    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
      var distance = this.kinetic_.getDistance();
      var angle = this.kinetic_.getAngle();
      var center =
      /** @type {!ol.Coordinate} */
      view.getCenter();
      var centerpx = map.getPixelFromCoordinate(center);
      var dest = map.getCoordinateFromPixel([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
      view.animate({
        center: view.constrainCenter(dest),
        duration: 500,
        easing: _easing2.default.easeOut
      });
    }

    view.setHint(_viewhint2.default.INTERACTING, -1);
    return false;
  } else {
    if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger up, tiny drag, second finger up
      this.kinetic_.begin();
    }

    this.lastCentroid = null;
    return true;
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */


_ol_interaction_DragPan_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    this.lastCentroid = null;

    if (!this.handlingDownUpSequence) {
      view.setHint(_viewhint2.default.INTERACTING, 1);
    } // stop any current animation


    if (view.getAnimating()) {
      view.setCenter(mapBrowserEvent.frameState.viewState.center);
    }

    if (this.kinetic_) {
      this.kinetic_.begin();
    } // No kinetic as soon as more than one pointer on the screen is
    // detected. This is to prevent nasty pans after pinch.


    this.noKinetic_ = this.targetPointers.length > 1;
    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_DragPan_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_DragPan_;

},{"../coordinate.js":44,"../easing.js":48,"../events/condition.js":50,"../functions.js":61,"../index.js":90,"../interaction/pointer.js":103,"../viewhint.js":247}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _rotationconstraint = require("../rotationconstraint.js");

var _rotationconstraint2 = _interopRequireDefault(_rotationconstraint);

var _viewhint = require("../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _condition = require("../events/condition.js");

var _condition2 = _interopRequireDefault(_condition);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

var _pointer = require("../interaction/pointer.js");

var _pointer2 = _interopRequireDefault(_pointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragRotateOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragRotate_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_DragRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragRotate_.handleUpEvent_
  });
  /**
   * @private
   * @type {ol.EventsConditionType}
   */


  this.condition_ = options.condition ? options.condition : _condition2.default.altShiftKeysOnly;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastAngle_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_interaction_DragRotate_, _pointer2.default);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragRotate}
 * @private
 */


_ol_interaction_DragRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();

  if (view.getConstraints().rotation === _rotationconstraint2.default.disable) {
    return;
  }

  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);

  if (this.lastAngle_ !== undefined) {
    var delta = theta - this.lastAngle_;
    var rotation = view.getRotation();

    _interaction2.default.rotateWithoutConstraints(view, rotation - delta);
  }

  this.lastAngle_ = theta;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */


_ol_interaction_DragRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return true;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(_viewhint2.default.INTERACTING, -1);
  var rotation = view.getRotation();

  _interaction2.default.rotate(view, rotation, undefined, this.duration_);

  return false;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */


_ol_interaction_DragRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (_condition2.default.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    map.getView().setHint(_viewhint2.default.INTERACTING, 1);
    this.lastAngle_ = undefined;
    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_DragRotate_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_DragRotate_;

},{"../events/condition.js":50,"../functions.js":61,"../index.js":90,"../interaction/interaction.js":97,"../interaction/pointer.js":103,"../rotationconstraint.js":208,"../viewhint.js":247}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _easing = require("../easing.js");

var _easing2 = _interopRequireDefault(_easing);

var _condition = require("../events/condition.js");

var _condition2 = _interopRequireDefault(_condition);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _dragbox = require("../interaction/dragbox.js");

var _dragbox2 = _interopRequireDefault(_dragbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragZoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var condition = options.condition ? options.condition : _condition2.default.shiftKeyOnly;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 200;
  /**
   * @private
   * @type {boolean}
   */

  this.out_ = options.out !== undefined ? options.out : false;

  _dragbox2.default.call(this, {
    condition: condition,
    className: options.className || 'ol-dragzoom'
  });
};

_index2.default.inherits(_ol_interaction_DragZoom_, _dragbox2.default);
/**
 * @inheritDoc
 */


_ol_interaction_DragZoom_.prototype.onBoxEnd = function () {
  var map = this.getMap();
  var view =
  /** @type {!ol.View} */
  map.getView();
  var size =
  /** @type {!ol.Size} */
  map.getSize();
  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtent(size);

    var boxPixelExtent = _extent2.default.createOrUpdateFromCoordinates([map.getPixelFromCoordinate(_extent2.default.getBottomLeft(extent)), map.getPixelFromCoordinate(_extent2.default.getTopRight(extent))]);

    var factor = view.getResolutionForExtent(boxPixelExtent, size);

    _extent2.default.scaleFromCenter(mapExtent, 1 / factor);

    extent = mapExtent;
  }

  var resolution = view.constrainResolution(view.getResolutionForExtent(extent, size));

  var center = _extent2.default.getCenter(extent);

  center = view.constrainCenter(center);
  view.animate({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: _easing2.default.easeOut
  });
};

exports.default = _ol_interaction_DragZoom_;

},{"../easing.js":48,"../events/condition.js":50,"../extent.js":55,"../index.js":90,"../interaction/dragbox.js":93}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _object = require("../object.js");

var _object2 = _interopRequireDefault(_object);

var _easing = require("../easing.js");

var _easing2 = _interopRequireDefault(_easing);

var _property = require("../interaction/property.js");

var _property2 = _interopRequireDefault(_property);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME factor out key precondition (shift et. al)

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link ol.interaction.KeyboardZoom} is functionally the same as
 * {@link ol.control.Zoom}, but triggered by a keyboard event not a button
 * element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 *
 * @constructor
 * @param {olx.interaction.InteractionOptions} options Options.
 * @extends {ol.Object}
 * @api
 */
var _ol_interaction_Interaction_ = function (options) {
  _object2.default.call(this);
  /**
   * @private
   * @type {ol.PluggableMap}
   */


  this.map_ = null;
  this.setActive(true);
  /**
   * @type {function(ol.MapBrowserEvent):boolean}
   */

  this.handleEvent = options.handleEvent;
};

_index2.default.inherits(_ol_interaction_Interaction_, _object2.default);
/**
 * Return whether the interaction is currently active.
 * @return {boolean} `true` if the interaction is active, `false` otherwise.
 * @observable
 * @api
 */


_ol_interaction_Interaction_.prototype.getActive = function () {
  return (
    /** @type {boolean} */
    this.get(_property2.default.ACTIVE)
  );
};
/**
 * Get the map associated with this interaction.
 * @return {ol.PluggableMap} Map.
 * @api
 */


_ol_interaction_Interaction_.prototype.getMap = function () {
  return this.map_;
};
/**
 * Activate or deactivate the interaction.
 * @param {boolean} active Active.
 * @observable
 * @api
 */


_ol_interaction_Interaction_.prototype.setActive = function (active) {
  this.set(_property2.default.ACTIVE, active);
};
/**
 * Remove the interaction from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.PluggableMap} map Map.
 */


_ol_interaction_Interaction_.prototype.setMap = function (map) {
  this.map_ = map;
};
/**
 * @param {ol.View} view View.
 * @param {ol.Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.pan = function (view, delta, opt_duration) {
  var currentCenter = view.getCenter();

  if (currentCenter) {
    var center = view.constrainCenter([currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);

    if (opt_duration) {
      view.animate({
        duration: opt_duration,
        easing: _easing2.default.linear,
        center: center
      });
    } else {
      view.setCenter(center);
    }
  }
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.rotate = function (view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);

  _ol_interaction_Interaction_.rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.rotateWithoutConstraints = function (view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();

    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({
        rotation: rotation,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing2.default.easeOut
      });
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */


_ol_interaction_Interaction_.zoom = function (view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);

  _ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};
/**
 * @param {ol.View} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.zoomByDelta = function (view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);

  if (resolution !== undefined) {
    var resolutions = view.getResolutions();
    resolution = _math2.default.clamp(resolution, view.getMinResolution() || resolutions[resolutions.length - 1], view.getMaxResolution() || resolutions[0]);
  } // If we have a constraint on center, we need to change the anchor so that the
  // new center is within the extent. We first calculate the new center, apply
  // the constraint to it, and then calculate back the anchor


  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);
    opt_anchor = [(resolution * currentCenter[0] - currentResolution * center[0]) / (resolution - currentResolution), (resolution * currentCenter[1] - currentResolution * center[1]) / (resolution - currentResolution)];
  }

  _ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};
/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */


_ol_interaction_Interaction_.zoomWithoutConstraints = function (view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();

    if (currentResolution !== undefined && currentCenter && resolution !== currentResolution && opt_duration) {
      view.animate({
        resolution: resolution,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing2.default.easeOut
      });
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }

      view.setResolution(resolution);
    }
  }
};

exports.default = _ol_interaction_Interaction_;

},{"../easing.js":48,"../index.js":90,"../interaction/property.js":104,"../math.js":124,"../object.js":126}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _coordinate = require("../coordinate.js");

var _coordinate2 = _interopRequireDefault(_coordinate);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _keycode = require("../events/keycode.js");

var _keycode2 = _interopRequireDefault(_keycode);

var _condition = require("../events/condition.js");

var _condition2 = _interopRequireDefault(_condition);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardZoom}.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.KeyboardPanOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_KeyboardPan_ = function (opt_options) {
  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_KeyboardPan_.handleEvent
  });

  var options = opt_options || {};
  /**
   * @private
   * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.
   * @return {boolean} Combined condition result.
   */

  this.defaultCondition_ = function (mapBrowserEvent) {
    return _condition2.default.noModifierKeys(mapBrowserEvent) && _condition2.default.targetNotEditable(mapBrowserEvent);
  };
  /**
   * @private
   * @type {ol.EventsConditionType}
   */


  this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 100;
  /**
   * @private
   * @type {number}
   */

  this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
};

_index2.default.inherits(_ol_interaction_KeyboardPan_, _interaction2.default);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardPan}
 * @api
 */


_ol_interaction_KeyboardPan_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;

  if (mapBrowserEvent.type == _eventtype2.default.KEYDOWN) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var keyCode = keyEvent.keyCode;

    if (this.condition_(mapBrowserEvent) && (keyCode == _keycode2.default.DOWN || keyCode == _keycode2.default.LEFT || keyCode == _keycode2.default.RIGHT || keyCode == _keycode2.default.UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0,
          deltaY = 0;

      if (keyCode == _keycode2.default.DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == _keycode2.default.LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == _keycode2.default.RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }

      var delta = [deltaX, deltaY];

      _coordinate2.default.rotate(delta, view.getRotation());

      _interaction2.default.pan(view, delta, this.duration_);

      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }

  return !stopEvent;
};

exports.default = _ol_interaction_KeyboardPan_;

},{"../coordinate.js":44,"../events/condition.js":50,"../events/eventtype.js":53,"../events/keycode.js":54,"../index.js":90,"../interaction/interaction.js":97}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _condition = require("../events/condition.js");

var _condition2 = _interopRequireDefault(_condition);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardPan}.
 *
 * @constructor
 * @param {olx.interaction.KeyboardZoomOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */
var _ol_interaction_KeyboardZoom_ = function (opt_options) {
  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_KeyboardZoom_.handleEvent
  });

  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {ol.EventsConditionType}
   */

  this.condition_ = options.condition ? options.condition : _condition2.default.targetNotEditable;
  /**
   * @private
   * @type {number}
   */

  this.delta_ = options.delta ? options.delta : 1;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 100;
};

_index2.default.inherits(_ol_interaction_KeyboardZoom_, _interaction2.default);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardZoom}
 * @api
 */


_ol_interaction_KeyboardZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;

  if (mapBrowserEvent.type == _eventtype2.default.KEYDOWN || mapBrowserEvent.type == _eventtype2.default.KEYPRESS) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var charCode = keyEvent.charCode;

    if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
      var view = map.getView();

      _interaction2.default.zoomByDelta(view, delta, undefined, this.duration_);

      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }

  return !stopEvent;
};

exports.default = _ol_interaction_KeyboardZoom_;

},{"../events/condition.js":50,"../events/eventtype.js":53,"../index.js":90,"../interaction/interaction.js":97}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _viewhint = require("../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _easing = require("../easing.js");

var _easing2 = _interopRequireDefault(_easing);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _has = require("../has.js");

var _has2 = _interopRequireDefault(_has);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.MouseWheelZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_MouseWheelZoom_ = function (opt_options) {
  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_MouseWheelZoom_.handleEvent
  });

  var options = opt_options || {};
  /**
   * @private
   * @type {number}
   */

  this.delta_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 250;
  /**
   * @private
   * @type {number}
   */

  this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
  /**
   * @private
   * @type {boolean}
   */

  this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
  /**
   * @private
   * @type {boolean}
   */

  this.constrainResolution_ = options.constrainResolution || false;
  /**
   * @private
   * @type {?ol.Coordinate}
   */

  this.lastAnchor_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.startTime_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.timeoutId_ = undefined;
  /**
   * @private
   * @type {ol.interaction.MouseWheelZoom.Mode_|undefined}
   */

  this.mode_ = undefined;
  /**
   * Trackpad events separated by this delay will be considered separate
   * interactions.
   * @type {number}
   */

  this.trackpadEventGap_ = 400;
  /**
   * @type {number|undefined}
   */

  this.trackpadTimeoutId_ = undefined;
  /**
   * The number of delta values per zoom level
   * @private
   * @type {number}
   */

  this.trackpadDeltaPerZoom_ = 300;
  /**
   * The zoom factor by which scroll zooming is allowed to exceed the limits.
   * @private
   * @type {number}
   */

  this.trackpadZoomBuffer_ = 1.5;
};

_index2.default.inherits(_ol_interaction_MouseWheelZoom_, _interaction2.default);
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * mousewheel-event) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} Allow event propagation.
 * @this {ol.interaction.MouseWheelZoom}
 * @api
 */


_ol_interaction_MouseWheelZoom_.handleEvent = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;

  if (type !== _eventtype2.default.WHEEL && type !== _eventtype2.default.MOUSEWHEEL) {
    return true;
  }

  mapBrowserEvent.preventDefault();
  var map = mapBrowserEvent.map;
  var wheelEvent =
  /** @type {WheelEvent} */
  mapBrowserEvent.originalEvent;

  if (this.useAnchor_) {
    this.lastAnchor_ = mapBrowserEvent.coordinate;
  } // Delta normalisation inspired by
  // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js


  var delta;

  if (mapBrowserEvent.type == _eventtype2.default.WHEEL) {
    delta = wheelEvent.deltaY;

    if (_has2.default.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
      delta /= _has2.default.DEVICE_PIXEL_RATIO;
    }

    if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      delta *= 40;
    }
  } else if (mapBrowserEvent.type == _eventtype2.default.MOUSEWHEEL) {
    delta = -wheelEvent.wheelDeltaY;

    if (_has2.default.SAFARI) {
      delta /= 3;
    }
  }

  if (delta === 0) {
    return false;
  }

  var now = Date.now();

  if (this.startTime_ === undefined) {
    this.startTime_ = now;
  }

  if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
    this.mode_ = Math.abs(delta) < 4 ? _ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD : _ol_interaction_MouseWheelZoom_.Mode_.WHEEL;
  }

  if (this.mode_ === _ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD) {
    var view = map.getView();

    if (this.trackpadTimeoutId_) {
      clearTimeout(this.trackpadTimeoutId_);
    } else {
      view.setHint(_viewhint2.default.INTERACTING, 1);
    }

    this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
    var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
    var minResolution = view.getMinResolution();
    var maxResolution = view.getMaxResolution();
    var rebound = 0;

    if (resolution < minResolution) {
      resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
      rebound = 1;
    } else if (resolution > maxResolution) {
      resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
      rebound = -1;
    }

    if (this.lastAnchor_) {
      var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
      view.setCenter(view.constrainCenter(center));
    }

    view.setResolution(resolution);

    if (rebound === 0 && this.constrainResolution_) {
      view.animate({
        resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
        easing: _easing2.default.easeOut,
        anchor: this.lastAnchor_,
        duration: this.duration_
      });
    }

    if (rebound > 0) {
      view.animate({
        resolution: minResolution,
        easing: _easing2.default.easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    } else if (rebound < 0) {
      view.animate({
        resolution: maxResolution,
        easing: _easing2.default.easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    }

    this.startTime_ = now;
    return false;
  }

  this.delta_ += delta;
  var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
  clearTimeout(this.timeoutId_);
  this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
  return false;
};
/**
 * @private
 */


_ol_interaction_MouseWheelZoom_.prototype.decrementInteractingHint_ = function () {
  this.trackpadTimeoutId_ = undefined;
  var view = this.getMap().getView();
  view.setHint(_viewhint2.default.INTERACTING, -1);
};
/**
 * @private
 * @param {ol.PluggableMap} map Map.
 */


_ol_interaction_MouseWheelZoom_.prototype.handleWheelZoom_ = function (map) {
  var view = map.getView();

  if (view.getAnimating()) {
    view.cancelAnimations();
  }

  var maxDelta = _index2.default.MOUSEWHEELZOOM_MAXDELTA;

  var delta = _math2.default.clamp(this.delta_, -maxDelta, maxDelta);

  _interaction2.default.zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);

  this.mode_ = undefined;
  this.delta_ = 0;
  this.lastAnchor_ = null;
  this.startTime_ = undefined;
  this.timeoutId_ = undefined;
};
/**
 * Enable or disable using the mouse's location as an anchor when zooming
 * @param {boolean} useAnchor true to zoom to the mouse's location, false
 * to zoom to the center of the map
 * @api
 */


_ol_interaction_MouseWheelZoom_.prototype.setMouseAnchor = function (useAnchor) {
  this.useAnchor_ = useAnchor;

  if (!useAnchor) {
    this.lastAnchor_ = null;
  }
};
/**
 * @enum {string}
 * @private
 */


_ol_interaction_MouseWheelZoom_.Mode_ = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};
exports.default = _ol_interaction_MouseWheelZoom_;

},{"../easing.js":48,"../events/eventtype.js":53,"../has.js":85,"../index.js":90,"../interaction/interaction.js":97,"../math.js":124,"../viewhint.js":247}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _viewhint = require("../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

var _pointer = require("../interaction/pointer.js");

var _pointer2 = _interopRequireDefault(_pointer);

var _rotationconstraint = require("../rotationconstraint.js");

var _rotationconstraint2 = _interopRequireDefault(_rotationconstraint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchRotateOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_PinchRotate_ = function (opt_options) {
  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_PinchRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchRotate_.handleUpEvent_
  });

  var options = opt_options || {};
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.anchor_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastAngle_ = undefined;
  /**
   * @private
   * @type {boolean}
   */

  this.rotating_ = false;
  /**
   * @private
   * @type {number}
   */

  this.rotationDelta_ = 0.0;
  /**
   * @private
   * @type {number}
   */

  this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_interaction_PinchRotate_, _pointer2.default);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchRotate}
 * @private
 */


_ol_interaction_PinchRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  var rotationDelta = 0.0;
  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1]; // angle between touches

  var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

  if (this.lastAngle_ !== undefined) {
    var delta = angle - this.lastAngle_;
    this.rotationDelta_ += delta;

    if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
      this.rotating_ = true;
    }

    rotationDelta = delta;
  }

  this.lastAngle_ = angle;
  var map = mapBrowserEvent.map;
  var view = map.getView();

  if (view.getConstraints().rotation === _rotationconstraint2.default.disable) {
    return;
  } // rotate anchor point.
  // FIXME: should be the intersection point between the lines:
  //     touch0,touch1 and previousTouch0,previousTouch1


  var viewportPosition = map.getViewport().getBoundingClientRect();

  var centroid = _pointer2.default.centroid(this.targetPointers);

  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid); // rotate

  if (this.rotating_) {
    var rotation = view.getRotation();
    map.render();

    _interaction2.default.rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */


_ol_interaction_PinchRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_viewhint2.default.INTERACTING, -1);

    if (this.rotating_) {
      var rotation = view.getRotation();

      _interaction2.default.rotate(view, rotation, this.anchor_, this.duration_);
    }

    return false;
  } else {
    return true;
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */


_ol_interaction_PinchRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastAngle_ = undefined;
    this.rotating_ = false;
    this.rotationDelta_ = 0.0;

    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_viewhint2.default.INTERACTING, 1);
    }

    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_PinchRotate_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_PinchRotate_;

},{"../functions.js":61,"../index.js":90,"../interaction/interaction.js":97,"../interaction/pointer.js":103,"../rotationconstraint.js":208,"../viewhint.js":247}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _viewhint = require("../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

var _pointer = require("../interaction/pointer.js");

var _pointer2 = _interopRequireDefault(_pointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_PinchZoom_ = function (opt_options) {
  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_PinchZoom_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchZoom_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchZoom_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};
  /**
   * @private
   * @type {boolean}
   */

  this.constrainResolution_ = options.constrainResolution || false;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.anchor_ = null;
  /**
   * @private
   * @type {number}
   */

  this.duration_ = options.duration !== undefined ? options.duration : 400;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lastDistance_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.lastScaleDelta_ = 1;
};

_index2.default.inherits(_ol_interaction_PinchZoom_, _pointer2.default);
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchZoom}
 * @private
 */


_ol_interaction_PinchZoom_.handleDragEvent_ = function (mapBrowserEvent) {
  var scaleDelta = 1.0;
  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];
  var dx = touch0.clientX - touch1.clientX;
  var dy = touch0.clientY - touch1.clientY; // distance between touches

  var distance = Math.sqrt(dx * dx + dy * dy);

  if (this.lastDistance_ !== undefined) {
    scaleDelta = this.lastDistance_ / distance;
  }

  this.lastDistance_ = distance;
  var map = mapBrowserEvent.map;
  var view = map.getView();
  var resolution = view.getResolution();
  var maxResolution = view.getMaxResolution();
  var minResolution = view.getMinResolution();
  var newResolution = resolution * scaleDelta;

  if (newResolution > maxResolution) {
    scaleDelta = maxResolution / resolution;
    newResolution = maxResolution;
  } else if (newResolution < minResolution) {
    scaleDelta = minResolution / resolution;
    newResolution = minResolution;
  }

  if (scaleDelta != 1.0) {
    this.lastScaleDelta_ = scaleDelta;
  } // scale anchor point.


  var viewportPosition = map.getViewport().getBoundingClientRect();

  var centroid = _pointer2.default.centroid(this.targetPointers);

  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid); // scale, bypass the resolution constraint

  map.render();

  _interaction2.default.zoomWithoutConstraints(view, newResolution, this.anchor_);
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */


_ol_interaction_PinchZoom_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_viewhint2.default.INTERACTING, -1);
    var resolution = view.getResolution();

    if (this.constrainResolution_ || resolution < view.getMinResolution() || resolution > view.getMaxResolution()) {
      // Zoom to final resolution, with an animation, and provide a
      // direction not to zoom out/in if user was pinching in/out.
      // Direction is > 0 if pinching out, and < 0 if pinching in.
      var direction = this.lastScaleDelta_ - 1;

      _interaction2.default.zoom(view, resolution, this.anchor_, this.duration_, direction);
    }

    return false;
  } else {
    return true;
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */


_ol_interaction_PinchZoom_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastDistance_ = undefined;
    this.lastScaleDelta_ = 1;

    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_viewhint2.default.INTERACTING, 1);
    }

    return true;
  } else {
    return false;
  }
};
/**
 * @inheritDoc
 */


_ol_interaction_PinchZoom_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_PinchZoom_;

},{"../functions.js":61,"../index.js":90,"../interaction/interaction.js":97,"../interaction/pointer.js":103,"../viewhint.js":247}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _mapbrowsereventtype = require("../mapbrowsereventtype.js");

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _mapbrowserpointerevent = require("../mapbrowserpointerevent.js");

var _mapbrowserpointerevent2 = _interopRequireDefault(_mapbrowserpointerevent);

var _interaction = require("../interaction/interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 *
 * @constructor
 * @param {olx.interaction.PointerOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */
var _ol_interaction_Pointer_ = function (opt_options) {
  var options = opt_options ? opt_options : {};
  var handleEvent = options.handleEvent ? options.handleEvent : _ol_interaction_Pointer_.handleEvent;

  _interaction2.default.call(this, {
    handleEvent: handleEvent
  });
  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */


  this.handleDownEvent_ = options.handleDownEvent ? options.handleDownEvent : _ol_interaction_Pointer_.handleDownEvent;
  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */

  this.handleDragEvent_ = options.handleDragEvent ? options.handleDragEvent : _ol_interaction_Pointer_.handleDragEvent;
  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */

  this.handleMoveEvent_ = options.handleMoveEvent ? options.handleMoveEvent : _ol_interaction_Pointer_.handleMoveEvent;
  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */

  this.handleUpEvent_ = options.handleUpEvent ? options.handleUpEvent : _ol_interaction_Pointer_.handleUpEvent;
  /**
   * @type {boolean}
   * @protected
   */

  this.handlingDownUpSequence = false;
  /**
   * @type {Object.<string, ol.pointer.PointerEvent>}
   * @private
   */

  this.trackedPointers_ = {};
  /**
   * @type {Array.<ol.pointer.PointerEvent>}
   * @protected
   */

  this.targetPointers = [];
};

_index2.default.inherits(_ol_interaction_Pointer_, _interaction2.default);
/**
 * @param {Array.<ol.pointer.PointerEvent>} pointerEvents List of events.
 * @return {ol.Pixel} Centroid pixel.
 */


_ol_interaction_Pointer_.centroid = function (pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;

  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }

  return [clientX / length, clientY / length];
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 * @private
 */


_ol_interaction_Pointer_.prototype.isPointerDraggingEvent_ = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _mapbrowsereventtype2.default.POINTERDOWN || type === _mapbrowsereventtype2.default.POINTERDRAG || type === _mapbrowsereventtype2.default.POINTERUP;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @private
 */


_ol_interaction_Pointer_.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
  if (this.isPointerDraggingEvent_(mapBrowserEvent)) {
    var event = mapBrowserEvent.pointerEvent;
    var id = event.pointerId.toString();

    if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERUP) {
      delete this.trackedPointers_[id];
    } else if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERDOWN) {
      this.trackedPointers_[id] = event;
    } else if (id in this.trackedPointers_) {
      // update only when there was a pointerdown event for this pointer
      this.trackedPointers_[id] = event;
    }

    this.targetPointers = _obj2.default.getValues(this.trackedPointers_);
  }
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */


_ol_interaction_Pointer_.handleDragEvent = _index2.default.nullFunction;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */

_ol_interaction_Pointer_.handleUpEvent = _functions2.default.FALSE;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */

_ol_interaction_Pointer_.handleDownEvent = _functions2.default.FALSE;
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */

_ol_interaction_Pointer_.handleMoveEvent = _index2.default.nullFunction;
/**
 * Handles the {@link ol.MapBrowserEvent map browser event} and may call into
 * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
 * detected.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.Pointer}
 * @api
 */

_ol_interaction_Pointer_.handleEvent = function (mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof _mapbrowserpointerevent2.default)) {
    return true;
  }

  var stopEvent = false;
  this.updateTrackedPointers_(mapBrowserEvent);

  if (this.handlingDownUpSequence) {
    if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERDRAG) {
      this.handleDragEvent_(mapBrowserEvent);
    } else if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERUP) {
      var handledUp = this.handleUpEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
    }
  } else {
    if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERDOWN) {
      var handled = this.handleDownEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handled;
      stopEvent = this.shouldStopEvent(handled);
    } else if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERMOVE) {
      this.handleMoveEvent_(mapBrowserEvent);
    }
  }

  return !stopEvent;
};
/**
 * This method is used to determine if "down" events should be propagated to
 * other interactions or should be stopped.
 *
 * The method receives the return code of the "handleDownEvent" function.
 *
 * By default this function is the "identity" function. It's overidden in
 * child classes.
 *
 * @param {boolean} handled Was the event handled by the interaction?
 * @return {boolean} Should the event be stopped?
 * @protected
 */


_ol_interaction_Pointer_.prototype.shouldStopEvent = function (handled) {
  return handled;
};

exports.default = _ol_interaction_Pointer_;

},{"../functions.js":61,"../index.js":90,"../interaction/interaction.js":97,"../mapbrowsereventtype.js":119,"../mapbrowserpointerevent.js":120,"../obj.js":125}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_interaction_Property_ = {
  ACTIVE: 'active'
};
exports.default = _ol_interaction_Property_;

},{}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @constructor
 * @param {number} decay Rate of decay (must be negative).
 * @param {number} minVelocity Minimum velocity (pixels/millisecond).
 * @param {number} delay Delay to consider to calculate the kinetic
 *     initial values (milliseconds).
 * @struct
 * @api
 */
var _ol_Kinetic_ = function (decay, minVelocity, delay) {
  /**
   * @private
   * @type {number}
   */
  this.decay_ = decay;
  /**
   * @private
   * @type {number}
   */

  this.minVelocity_ = minVelocity;
  /**
   * @private
   * @type {number}
   */

  this.delay_ = delay;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.points_ = [];
  /**
   * @private
   * @type {number}
   */

  this.angle_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.initialVelocity_ = 0;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_Kinetic_.prototype.begin = function () {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};
/**
 * @param {number} x X.
 * @param {number} y Y.
 */


_ol_Kinetic_.prototype.update = function (x, y) {
  this.points_.push(x, y, Date.now());
};
/**
 * @return {boolean} Whether we should do kinetic animation.
 */


_ol_Kinetic_.prototype.end = function () {
  if (this.points_.length < 6) {
    // at least 2 points are required (i.e. there must be at least 6 elements
    // in the array)
    return false;
  }

  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;

  if (this.points_[lastIndex + 2] < delay) {
    // the last tracked point is too old, which means that the user stopped
    // panning before releasing the map
    return false;
  } // get the first point which still falls into the delay time


  var firstIndex = lastIndex - 3;

  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }

  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)
  // we also make sure the user panned for a duration of at least one frame
  // (1/60s) to compute sane displacement values

  if (duration < 1000 / 60) {
    return false;
  }

  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};
/**
 * @return {number} Total distance travelled (pixels).
 */


_ol_Kinetic_.prototype.getDistance = function () {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};
/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */


_ol_Kinetic_.prototype.getAngle = function () {
  return this.angle_;
};

exports.default = _ol_Kinetic_;

},{}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _object = require("../object.js");

var _object2 = _interopRequireDefault(_object);

var _property = require("../layer/property.js");

var _property2 = _interopRequireDefault(_property);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with `ol.layer.Base` and all its subclasses, any property set in
 * the options is set as a {@link ol.Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {olx.layer.BaseOptions} options Layer options.
 * @api
 */
var _ol_layer_Base_ = function (options) {
  _object2.default.call(this);
  /**
   * @type {Object.<string, *>}
   */


  var properties = _obj2.default.assign({}, options);

  properties[_property2.default.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
  properties[_property2.default.VISIBLE] = options.visible !== undefined ? options.visible : true;
  properties[_property2.default.Z_INDEX] = options.zIndex !== undefined ? options.zIndex : 0;
  properties[_property2.default.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
  properties[_property2.default.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
  this.setProperties(properties);
  /**
   * @type {ol.LayerState}
   * @private
   */

  this.state_ =
  /** @type {ol.LayerState} */
  {
    layer:
    /** @type {ol.layer.Layer} */
    this,
    managed: true
  };
  /**
   * The layer type.
   * @type {ol.LayerType}
   * @protected;
   */

  this.type;
};

_index2.default.inherits(_ol_layer_Base_, _object2.default);
/**
 * Get the layer type (used when creating a layer renderer).
 * @return {ol.LayerType} The layer type.
 */


_ol_layer_Base_.prototype.getType = function () {
  return this.type;
};
/**
 * @return {ol.LayerState} Layer state.
 */


_ol_layer_Base_.prototype.getLayerState = function () {
  this.state_.opacity = _math2.default.clamp(this.getOpacity(), 0, 1);
  this.state_.sourceState = this.getSourceState();
  this.state_.visible = this.getVisible();
  this.state_.extent = this.getExtent();
  this.state_.zIndex = this.getZIndex();
  this.state_.maxResolution = this.getMaxResolution();
  this.state_.minResolution = Math.max(this.getMinResolution(), 0);
  return this.state_;
};
/**
 * @abstract
 * @param {Array.<ol.layer.Layer>=} opt_array Array of layers (to be
 *     modified in place).
 * @return {Array.<ol.layer.Layer>} Array of layers.
 */


_ol_layer_Base_.prototype.getLayersArray = function (opt_array) {};
/**
 * @abstract
 * @param {Array.<ol.LayerState>=} opt_states Optional list of layer
 *     states (to be modified in place).
 * @return {Array.<ol.LayerState>} List of layer states.
 */


_ol_layer_Base_.prototype.getLayerStatesArray = function (opt_states) {};
/**
 * Return the {@link ol.Extent extent} of the layer or `undefined` if it
 * will be visible regardless of extent.
 * @return {ol.Extent|undefined} The layer extent.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getExtent = function () {
  return (
    /** @type {ol.Extent|undefined} */
    this.get(_property2.default.EXTENT)
  );
};
/**
 * Return the maximum resolution of the layer.
 * @return {number} The maximum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getMaxResolution = function () {
  return (
    /** @type {number} */
    this.get(_property2.default.MAX_RESOLUTION)
  );
};
/**
 * Return the minimum resolution of the layer.
 * @return {number} The minimum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getMinResolution = function () {
  return (
    /** @type {number} */
    this.get(_property2.default.MIN_RESOLUTION)
  );
};
/**
 * Return the opacity of the layer (between 0 and 1).
 * @return {number} The opacity of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getOpacity = function () {
  return (
    /** @type {number} */
    this.get(_property2.default.OPACITY)
  );
};
/**
 * @abstract
 * @return {ol.source.State} Source state.
 */


_ol_layer_Base_.prototype.getSourceState = function () {};
/**
 * Return the visibility of the layer (`true` or `false`).
 * @return {boolean} The visibility of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getVisible = function () {
  return (
    /** @type {boolean} */
    this.get(_property2.default.VISIBLE)
  );
};
/**
 * Return the Z-index of the layer, which is used to order layers before
 * rendering. The default Z-index is 0.
 * @return {number} The Z-index of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.getZIndex = function () {
  return (
    /** @type {number} */
    this.get(_property2.default.Z_INDEX)
  );
};
/**
 * Set the extent at which the layer is visible.  If `undefined`, the layer
 * will be visible at all extents.
 * @param {ol.Extent|undefined} extent The extent of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setExtent = function (extent) {
  this.set(_property2.default.EXTENT, extent);
};
/**
 * Set the maximum resolution at which the layer is visible.
 * @param {number} maxResolution The maximum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setMaxResolution = function (maxResolution) {
  this.set(_property2.default.MAX_RESOLUTION, maxResolution);
};
/**
 * Set the minimum resolution at which the layer is visible.
 * @param {number} minResolution The minimum resolution of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setMinResolution = function (minResolution) {
  this.set(_property2.default.MIN_RESOLUTION, minResolution);
};
/**
 * Set the opacity of the layer, allowed values range from 0 to 1.
 * @param {number} opacity The opacity of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setOpacity = function (opacity) {
  this.set(_property2.default.OPACITY, opacity);
};
/**
 * Set the visibility of the layer (`true` or `false`).
 * @param {boolean} visible The visibility of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setVisible = function (visible) {
  this.set(_property2.default.VISIBLE, visible);
};
/**
 * Set Z-index of the layer, which is used to order layers before rendering.
 * The default Z-index is 0.
 * @param {number} zindex The z-index of the layer.
 * @observable
 * @api
 */


_ol_layer_Base_.prototype.setZIndex = function (zindex) {
  this.set(_property2.default.Z_INDEX, zindex);
};

exports.default = _ol_layer_Base_;

},{"../index.js":90,"../layer/property.js":110,"../math.js":124,"../obj.js":125,"../object.js":126}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _collection = require("../collection.js");

var _collection2 = _interopRequireDefault(_collection);

var _collectioneventtype = require("../collectioneventtype.js");

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _object = require("../object.js");

var _object2 = _interopRequireDefault(_object);

var _objecteventtype = require("../objecteventtype.js");

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _base = require("../layer/base.js");

var _base2 = _interopRequireDefault(_base);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _state = require("../source/state.js");

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A {@link ol.Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @constructor
 * @extends {ol.layer.Base}
 * @param {olx.layer.GroupOptions=} opt_options Layer options.
 * @api
 */
var _ol_layer_Group_ = function (opt_options) {
  var options = opt_options || {};

  var baseOptions =
  /** @type {olx.layer.GroupOptions} */
  _obj2.default.assign({}, options);

  delete baseOptions.layers;
  var layers = options.layers;

  _base2.default.call(this, baseOptions);
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */


  this.layersListenerKeys_ = [];
  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */

  this.listenerKeys_ = {};

  _events2.default.listen(this, _object2.default.getChangeEventType(_ol_layer_Group_.Property_.LAYERS), this.handleLayersChanged_, this);

  if (layers) {
    if (Array.isArray(layers)) {
      layers = new _collection2.default(layers.slice(), {
        unique: true
      });
    } else {
      _asserts2.default.assert(layers instanceof _collection2.default, 43); // Expected `layers` to be an array or an `ol.Collection`


      layers = layers;
    }
  } else {
    layers = new _collection2.default(undefined, {
      unique: true
    });
  }

  this.setLayers(layers);
};

_index2.default.inherits(_ol_layer_Group_, _base2.default);
/**
 * @private
 */


_ol_layer_Group_.prototype.handleLayerChange_ = function () {
  this.changed();
};
/**
 * @param {ol.events.Event} event Event.
 * @private
 */


_ol_layer_Group_.prototype.handleLayersChanged_ = function (event) {
  this.layersListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.layersListenerKeys_.length = 0;
  var layers = this.getLayers();
  this.layersListenerKeys_.push(_events2.default.listen(layers, _collectioneventtype2.default.ADD, this.handleLayersAdd_, this), _events2.default.listen(layers, _collectioneventtype2.default.REMOVE, this.handleLayersRemove_, this));

  for (var id in this.listenerKeys_) {
    this.listenerKeys_[id].forEach(_events2.default.unlistenByKey);
  }

  _obj2.default.clear(this.listenerKeys_);

  var layersArray = layers.getArray();
  var i, ii, layer;

  for (i = 0, ii = layersArray.length; i < ii; i++) {
    layer = layersArray[i];
    this.listenerKeys_[_index2.default.getUid(layer).toString()] = [_events2.default.listen(layer, _objecteventtype2.default.PROPERTYCHANGE, this.handleLayerChange_, this), _events2.default.listen(layer, _eventtype2.default.CHANGE, this.handleLayerChange_, this)];
  }

  this.changed();
};
/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */


_ol_layer_Group_.prototype.handleLayersAdd_ = function (collectionEvent) {
  var layer =
  /** @type {ol.layer.Base} */
  collectionEvent.element;

  var key = _index2.default.getUid(layer).toString();

  this.listenerKeys_[key] = [_events2.default.listen(layer, _objecteventtype2.default.PROPERTYCHANGE, this.handleLayerChange_, this), _events2.default.listen(layer, _eventtype2.default.CHANGE, this.handleLayerChange_, this)];
  this.changed();
};
/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */


_ol_layer_Group_.prototype.handleLayersRemove_ = function (collectionEvent) {
  var layer =
  /** @type {ol.layer.Base} */
  collectionEvent.element;

  var key = _index2.default.getUid(layer).toString();

  this.listenerKeys_[key].forEach(_events2.default.unlistenByKey);
  delete this.listenerKeys_[key];
  this.changed();
};
/**
 * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @return {!ol.Collection.<ol.layer.Base>} Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */


_ol_layer_Group_.prototype.getLayers = function () {
  return (
    /** @type {!ol.Collection.<ol.layer.Base>} */
    this.get(_ol_layer_Group_.Property_.LAYERS)
  );
};
/**
 * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @param {!ol.Collection.<ol.layer.Base>} layers Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */


_ol_layer_Group_.prototype.setLayers = function (layers) {
  this.set(_ol_layer_Group_.Property_.LAYERS, layers);
};
/**
 * @inheritDoc
 */


_ol_layer_Group_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array !== undefined ? opt_array : [];
  this.getLayers().forEach(function (layer) {
    layer.getLayersArray(array);
  });
  return array;
};
/**
 * @inheritDoc
 */


_ol_layer_Group_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states !== undefined ? opt_states : [];
  var pos = states.length;
  this.getLayers().forEach(function (layer) {
    layer.getLayerStatesArray(states);
  });
  var ownLayerState = this.getLayerState();
  var i, ii, layerState;

  for (i = pos, ii = states.length; i < ii; i++) {
    layerState = states[i];
    layerState.opacity *= ownLayerState.opacity;
    layerState.visible = layerState.visible && ownLayerState.visible;
    layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
    layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);

    if (ownLayerState.extent !== undefined) {
      if (layerState.extent !== undefined) {
        layerState.extent = _extent2.default.getIntersection(layerState.extent, ownLayerState.extent);
      } else {
        layerState.extent = ownLayerState.extent;
      }
    }
  }

  return states;
};
/**
 * @inheritDoc
 */


_ol_layer_Group_.prototype.getSourceState = function () {
  return _state2.default.READY;
};
/**
 * @enum {string}
 * @private
 */


_ol_layer_Group_.Property_ = {
  LAYERS: 'layers'
};
exports.default = _ol_layer_Group_;

},{"../asserts.js":32,"../collection.js":35,"../collectioneventtype.js":36,"../events.js":49,"../events/eventtype.js":53,"../extent.js":55,"../index.js":90,"../layer/base.js":106,"../obj.js":125,"../object.js":126,"../objecteventtype.js":127,"../source/state.js":213}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _layer = require("../layer/layer.js");

var _layer2 = _interopRequireDefault(_layer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.ImageOptions=} opt_options Layer options.
 * @api
 */
var _ol_layer_Image_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  _layer2.default.call(this,
  /** @type {olx.layer.LayerOptions} */
  options);
  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */


  this.type = _layertype2.default.IMAGE;
};

_index2.default.inherits(_ol_layer_Image_, _layer2.default);
/**
 * Return the associated {@link ol.source.Image source} of the image layer.
 * @function
 * @return {ol.source.Image} Source.
 * @api
 */


_ol_layer_Image_.prototype.getSource;
exports.default = _ol_layer_Image_;

},{"../index.js":90,"../layer/layer.js":109,"../layertype.js":114}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _object = require("../object.js");

var _object2 = _interopRequireDefault(_object);

var _base = require("../layer/base.js");

var _base2 = _interopRequireDefault(_base);

var _property = require("../layer/property.js");

var _property2 = _interopRequireDefault(_property);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _eventtype3 = require("../render/eventtype.js");

var _eventtype4 = _interopRequireDefault(_eventtype3);

var _state = require("../source/state.js");

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link ol.Map#addLayer}. Components
 * like {@link ol.interaction.Select} use unmanaged layers internally. These
 * unmanaged layers are associated with the map using
 * {@link ol.layer.Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.layer.Base}
 * @fires ol.render.Event
 * @param {olx.layer.LayerOptions} options Layer options.
 * @api
 */
var _ol_layer_Layer_ = function (options) {
  var baseOptions = _obj2.default.assign({}, options);

  delete baseOptions.source;

  _base2.default.call(this,
  /** @type {olx.layer.BaseOptions} */
  baseOptions);
  /**
   * @private
   * @type {?ol.EventsKey}
   */


  this.mapPrecomposeKey_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.mapRenderKey_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.sourceChangeKey_ = null;

  if (options.map) {
    this.setMap(options.map);
  }

  _events2.default.listen(this, _object2.default.getChangeEventType(_property2.default.SOURCE), this.handleSourcePropertyChange_, this);

  var source = options.source ? options.source : null;
  this.setSource(source);
};

_index2.default.inherits(_ol_layer_Layer_, _base2.default);
/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */


_ol_layer_Layer_.visibleAtResolution = function (layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution && resolution < layerState.maxResolution;
};
/**
 * @inheritDoc
 */


_ol_layer_Layer_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array ? opt_array : [];
  array.push(this);
  return array;
};
/**
 * @inheritDoc
 */


_ol_layer_Layer_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states ? opt_states : [];
  states.push(this.getLayerState());
  return states;
};
/**
 * Get the layer source.
 * @return {ol.source.Source} The layer source (or `null` if not yet set).
 * @observable
 * @api
 */


_ol_layer_Layer_.prototype.getSource = function () {
  var source = this.get(_property2.default.SOURCE);
  return (
    /** @type {ol.source.Source} */
    source || null
  );
};
/**
  * @inheritDoc
  */


_ol_layer_Layer_.prototype.getSourceState = function () {
  var source = this.getSource();
  return !source ? _state2.default.UNDEFINED : source.getState();
};
/**
 * @private
 */


_ol_layer_Layer_.prototype.handleSourceChange_ = function () {
  this.changed();
};
/**
 * @private
 */


_ol_layer_Layer_.prototype.handleSourcePropertyChange_ = function () {
  if (this.sourceChangeKey_) {
    _events2.default.unlistenByKey(this.sourceChangeKey_);

    this.sourceChangeKey_ = null;
  }

  var source = this.getSource();

  if (source) {
    this.sourceChangeKey_ = _events2.default.listen(source, _eventtype2.default.CHANGE, this.handleSourceChange_, this);
  }

  this.changed();
};
/**
 * Sets the layer to be rendered on top of other layers on a map. The map will
 * not manage this layer in its layers collection, and the callback in
 * {@link ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
 * is useful for temporary layers. To remove an unmanaged layer from the map,
 * use `#setMap(null)`.
 *
 * To add the layer to a map and have it managed by the map, use
 * {@link ol.Map#addLayer} instead.
 * @param {ol.PluggableMap} map Map.
 * @api
 */


_ol_layer_Layer_.prototype.setMap = function (map) {
  if (this.mapPrecomposeKey_) {
    _events2.default.unlistenByKey(this.mapPrecomposeKey_);

    this.mapPrecomposeKey_ = null;
  }

  if (!map) {
    this.changed();
  }

  if (this.mapRenderKey_) {
    _events2.default.unlistenByKey(this.mapRenderKey_);

    this.mapRenderKey_ = null;
  }

  if (map) {
    this.mapPrecomposeKey_ = _events2.default.listen(map, _eventtype4.default.PRECOMPOSE, function (evt) {
      var layerState = this.getLayerState();
      layerState.managed = false;
      layerState.zIndex = Infinity;
      evt.frameState.layerStatesArray.push(layerState);
      evt.frameState.layerStates[_index2.default.getUid(this)] = layerState;
    }, this);
    this.mapRenderKey_ = _events2.default.listen(this, _eventtype2.default.CHANGE, map.render, map);
    this.changed();
  }
};
/**
 * Set the layer source.
 * @param {ol.source.Source} source The layer source.
 * @observable
 * @api
 */


_ol_layer_Layer_.prototype.setSource = function (source) {
  this.set(_property2.default.SOURCE, source);
};

exports.default = _ol_layer_Layer_;

},{"../events.js":49,"../events/eventtype.js":53,"../index.js":90,"../layer/base.js":106,"../layer/property.js":110,"../obj.js":125,"../object.js":126,"../render/eventtype.js":161,"../source/state.js":213}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_layer_Property_ = {
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
};
exports.default = _ol_layer_Property_;

},{}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _layer = require("../layer/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _vectorrendertype = require("../layer/vectorrendertype.js");

var _vectorrendertype2 = _interopRequireDefault(_vectorrendertype);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _style = require("../style/style.js");

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.VectorOptions=} opt_options Options.
 * @api
 */
var _ol_layer_Vector_ = function (opt_options) {
  var options = opt_options ? opt_options :
  /** @type {olx.layer.VectorOptions} */
  {};

  var baseOptions = _obj2.default.assign({}, options);

  delete baseOptions.style;
  delete baseOptions.renderBuffer;
  delete baseOptions.updateWhileAnimating;
  delete baseOptions.updateWhileInteracting;

  _layer2.default.call(this,
  /** @type {olx.layer.LayerOptions} */
  baseOptions);
  /**
   * @private
   * @type {boolean}
   */


  this.declutter_ = options.declutter !== undefined ? options.declutter : false;
  /**
   * @type {number}
   * @private
   */

  this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
  /**
   * User provided style.
   * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
   * @private
   */

  this.style_ = null;
  /**
   * Style function for use within the library.
   * @type {ol.StyleFunction|undefined}
   * @private
   */

  this.styleFunction_ = undefined;
  this.setStyle(options.style);
  /**
   * @type {boolean}
   * @private
   */

  this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
  /**
   * @type {boolean}
   * @private
   */

  this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
  /**
   * @private
   * @type {ol.layer.VectorTileRenderType|string}
   */

  this.renderMode_ = options.renderMode || _vectorrendertype2.default.VECTOR;
  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */

  this.type = _layertype2.default.VECTOR;
};

_index2.default.inherits(_ol_layer_Vector_, _layer2.default);
/**
 * @return {boolean} Declutter.
 */


_ol_layer_Vector_.prototype.getDeclutter = function () {
  return this.declutter_;
};
/**
 * @param {boolean} declutter Declutter.
 */


_ol_layer_Vector_.prototype.setDeclutter = function (declutter) {
  this.declutter_ = declutter;
};
/**
 * @return {number|undefined} Render buffer.
 */


_ol_layer_Vector_.prototype.getRenderBuffer = function () {
  return this.renderBuffer_;
};
/**
 * @return {function(ol.Feature, ol.Feature): number|null|undefined} Render
 *     order.
 */


_ol_layer_Vector_.prototype.getRenderOrder = function () {
  return (
    /** @type {ol.RenderOrderFunction|null|undefined} */
    this.get(_ol_layer_Vector_.Property_.RENDER_ORDER)
  );
};
/**
 * Return the associated {@link ol.source.Vector vectorsource} of the layer.
 * @function
 * @return {ol.source.Vector} Source.
 * @api
 */


_ol_layer_Vector_.prototype.getSource;
/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 *     Layer style.
 * @api
 */

_ol_layer_Vector_.prototype.getStyle = function () {
  return this.style_;
};
/**
 * Get the style function.
 * @return {ol.StyleFunction|undefined} Layer style function.
 * @api
 */


_ol_layer_Vector_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};
/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     animating.
 */


_ol_layer_Vector_.prototype.getUpdateWhileAnimating = function () {
  return this.updateWhileAnimating_;
};
/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     interacting.
 */


_ol_layer_Vector_.prototype.getUpdateWhileInteracting = function () {
  return this.updateWhileInteracting_;
};
/**
 * @param {ol.RenderOrderFunction|null|undefined} renderOrder
 *     Render order.
 */


_ol_layer_Vector_.prototype.setRenderOrder = function (renderOrder) {
  this.set(_ol_layer_Vector_.Property_.RENDER_ORDER, renderOrder);
};
/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {@link ol.style} for information on the default style.
 * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|null|undefined}
 *     style Layer style.
 * @api
 */


_ol_layer_Vector_.prototype.setStyle = function (style) {
  this.style_ = style !== undefined ? style : _style2.default.defaultFunction;
  this.styleFunction_ = style === null ? undefined : _style2.default.createFunction(this.style_);
  this.changed();
};
/**
 * @return {ol.layer.VectorRenderType|string} The render mode.
 */


_ol_layer_Vector_.prototype.getRenderMode = function () {
  return this.renderMode_;
};
/**
 * @enum {string}
 * @private
 */


_ol_layer_Vector_.Property_ = {
  RENDER_ORDER: 'renderOrder'
};
exports.default = _ol_layer_Vector_;

},{"../index.js":90,"../layer/layer.js":109,"../layer/vectorrendertype.js":112,"../layertype.js":114,"../obj.js":125,"../style/style.js":235}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
var _ol_layer_VectorRenderType_ = {
  IMAGE: 'image',
  VECTOR: 'vector'
};
exports.default = _ol_layer_VectorRenderType_;

},{}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
var _ol_layer_VectorTileRenderType_ = {
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
};
exports.default = _ol_layer_VectorTileRenderType_;

},{}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * A layer type used when creating layer renderers.
 * @enum {string}
 */
var _ol_LayerType_ = {
  IMAGE: 'IMAGE',
  TILE: 'TILE',
  VECTOR_TILE: 'VECTOR_TILE',
  VECTOR: 'VECTOR'
};
exports.default = _ol_LayerType_;

},{}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_loadingstrategy_ = {};
/**
 * Strategy function for loading all features with a single request.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */

_ol_loadingstrategy_.all = function (extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
};
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */


_ol_loadingstrategy_.bbox = function (extent, resolution) {
  return [extent];
};
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {function(ol.Extent, number): Array.<ol.Extent>} Loading strategy.
 * @api
 */


_ol_loadingstrategy_.tile = function (tileGrid) {
  return (
    /**
         * @param {ol.Extent} extent Extent.
         * @param {number} resolution Resolution.
         * @return {Array.<ol.Extent>} Extents.
         */
    function (extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array.<ol.Extent>} */

      var extents = [];
      /** @type {ol.TileCoord} */

      var tileCoord = [z, 0, 0];

      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }

      return extents;
    }
  );
};

exports.default = _ol_loadingstrategy_;

},{}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _pluggablemap = require("./pluggablemap.js");

var _pluggablemap2 = _interopRequireDefault(_pluggablemap);

var _plugintype = require("./plugintype.js");

var _plugintype2 = _interopRequireDefault(_plugintype);

var _control = require("./control.js");

var _control2 = _interopRequireDefault(_control);

var _interaction = require("./interaction.js");

var _interaction2 = _interopRequireDefault(_interaction);

var _obj = require("./obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _plugins = require("./plugins.js");

var _plugins2 = _interopRequireDefault(_plugins);

var _imagelayer = require("./renderer/canvas/imagelayer.js");

var _imagelayer2 = _interopRequireDefault(_imagelayer);

var _map = require("./renderer/canvas/map.js");

var _map2 = _interopRequireDefault(_map);

var _tilelayer = require("./renderer/canvas/tilelayer.js");

var _tilelayer2 = _interopRequireDefault(_tilelayer);

var _vectorlayer = require("./renderer/canvas/vectorlayer.js");

var _vectorlayer2 = _interopRequireDefault(_vectorlayer);

var _vectortilelayer = require("./renderer/canvas/vectortilelayer.js");

var _vectortilelayer2 = _interopRequireDefault(_vectortilelayer);

var _imagelayer3 = require("./renderer/webgl/imagelayer.js");

var _imagelayer4 = _interopRequireDefault(_imagelayer3);

var _map3 = require("./renderer/webgl/map.js");

var _map4 = _interopRequireDefault(_map3);

var _tilelayer3 = require("./renderer/webgl/tilelayer.js");

var _tilelayer4 = _interopRequireDefault(_tilelayer3);

var _vectorlayer3 = require("./renderer/webgl/vectorlayer.js");

var _vectorlayer4 = _interopRequireDefault(_vectorlayer3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (_index2.default.ENABLE_CANVAS) {
  _plugins2.default.register(_plugintype2.default.MAP_RENDERER, _map2.default);

  _plugins2.default.registerMultiple(_plugintype2.default.LAYER_RENDERER, [_imagelayer2.default, _tilelayer2.default, _vectorlayer2.default, _vectortilelayer2.default]);
}

if (_index2.default.ENABLE_WEBGL) {
  _plugins2.default.register(_plugintype2.default.MAP_RENDERER, _map4.default);

  _plugins2.default.registerMultiple(_plugintype2.default.LAYER_RENDERER, [_imagelayer4.default, _tilelayer4.default, _vectorlayer4.default]);
}
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     var map = new ol.Map({
 *       view: new ol.View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new ol.layer.Tile({
 *           source: new ol.source.OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link ol.layer.Tile} to display
 * {@link ol.source.OSM} OSM data and render it to a DOM element with the
 * id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link ol.Overlay} for the difference). The map itself is placed in
 * a further element within the viewport.
 *
 * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
 * provided by the library. This is what is accessed by `getLayerGroup` and
 * `setLayerGroup`. Layers entered in the options are added to this group, and
 * `addLayer` and `removeLayer` change the layer collection in the group.
 * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
 * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
 * entered in the options or added with `addLayer` can be groups, which can
 * contain further groups, and so on.
 *
 * @constructor
 * @extends {ol.PluggableMap}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */


var _ol_Map_ = function (options) {
  options = _obj2.default.assign({}, options);

  if (!options.controls) {
    options.controls = _control2.default.defaults();
  }

  if (!options.interactions) {
    options.interactions = _interaction2.default.defaults();
  }

  _pluggablemap2.default.call(this, options);
};

_index2.default.inherits(_ol_Map_, _pluggablemap2.default);

exports.default = _ol_Map_;

},{"./control.js":39,"./index.js":90,"./interaction.js":91,"./obj.js":125,"./pluggablemap.js":131,"./plugins.js":132,"./plugintype.js":133,"./renderer/canvas/imagelayer.js":184,"./renderer/canvas/map.js":187,"./renderer/canvas/tilelayer.js":188,"./renderer/canvas/vectorlayer.js":189,"./renderer/canvas/vectortilelayer.js":190,"./renderer/webgl/imagelayer.js":197,"./renderer/webgl/map.js":199,"./renderer/webgl/tilelayer.js":200,"./renderer/webgl/vectorlayer.js":203}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _mapevent = require("./mapevent.js");

var _mapevent2 = _interopRequireDefault(_mapevent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link ol.Map} for which events trigger a map browser event.
 *
 * @constructor
 * @extends {ol.MapEvent}
 * @implements {oli.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {Event} browserEvent Browser event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var _ol_MapBrowserEvent_ = function (type, map, browserEvent, opt_dragging, opt_frameState) {
  _mapevent2.default.call(this, type, map, opt_frameState);
  /**
   * The original browser event.
   * @const
   * @type {Event}
   * @api
   */


  this.originalEvent = browserEvent;
  /**
   * The map pixel relative to the viewport corresponding to the original browser event.
   * @type {ol.Pixel}
   * @api
   */

  this.pixel = map.getEventPixel(browserEvent);
  /**
   * The coordinate in view projection corresponding to the original browser event.
   * @type {ol.Coordinate}
   * @api
   */

  this.coordinate = map.getCoordinateFromPixel(this.pixel);
  /**
   * Indicates if the map is currently being dragged. Only set for
   * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
   *
   * @type {boolean}
   * @api
   */

  this.dragging = opt_dragging !== undefined ? opt_dragging : false;
};

_index2.default.inherits(_ol_MapBrowserEvent_, _mapevent2.default);
/**
 * Prevents the default browser action.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault
 * @override
 * @api
 */


_ol_MapBrowserEvent_.prototype.preventDefault = function () {
  _mapevent2.default.prototype.preventDefault.call(this);

  this.originalEvent.preventDefault();
};
/**
 * Prevents further propagation of the current event.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation
 * @override
 * @api
 */


_ol_MapBrowserEvent_.prototype.stopPropagation = function () {
  _mapevent2.default.prototype.stopPropagation.call(this);

  this.originalEvent.stopPropagation();
};

exports.default = _ol_MapBrowserEvent_;

},{"./index.js":90,"./mapevent.js":121}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _has = require("./has.js");

var _has2 = _interopRequireDefault(_has);

var _mapbrowsereventtype = require("./mapbrowsereventtype.js");

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _mapbrowserpointerevent = require("./mapbrowserpointerevent.js");

var _mapbrowserpointerevent2 = _interopRequireDefault(_mapbrowserpointerevent);

var _events = require("./events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require("./events/eventtarget.js");

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require("./pointer/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _pointereventhandler = require("./pointer/pointereventhandler.js");

var _pointereventhandler2 = _interopRequireDefault(_pointereventhandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {ol.PluggableMap} map The map with the viewport to listen to events on.
 * @param {number|undefined} moveTolerance The minimal distance the pointer must travel to trigger a move.
 * @constructor
 * @extends {ol.events.EventTarget}
 */
var _ol_MapBrowserEventHandler_ = function (map, moveTolerance) {
  _eventtarget2.default.call(this);
  /**
   * This is the element that we will listen to the real events on.
   * @type {ol.PluggableMap}
   * @private
   */


  this.map_ = map;
  /**
   * @type {number}
   * @private
   */

  this.clickTimeoutId_ = 0;
  /**
   * @type {boolean}
   * @private
   */

  this.dragging_ = false;
  /**
   * @type {!Array.<ol.EventsKey>}
   * @private
   */

  this.dragListenerKeys_ = [];
  /**
   * @type {number}
   * @private
   */

  this.moveTolerance_ = moveTolerance ? moveTolerance * _has2.default.DEVICE_PIXEL_RATIO : _has2.default.DEVICE_PIXEL_RATIO;
  /**
   * The most recent "down" type event (or null if none have occurred).
   * Set on pointerdown.
   * @type {ol.pointer.PointerEvent}
   * @private
   */

  this.down_ = null;
  var element = this.map_.getViewport();
  /**
   * @type {number}
   * @private
   */

  this.activePointers_ = 0;
  /**
   * @type {!Object.<number, boolean>}
   * @private
   */

  this.trackedTouches_ = {};
  /**
   * Event handler which generates pointer events for
   * the viewport element.
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */

  this.pointerEventHandler_ = new _pointereventhandler2.default(element);
  /**
   * Event handler which generates pointer events for
   * the document (used when dragging).
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */

  this.documentPointerEventHandler_ = null;
  /**
   * @type {?ol.EventsKey}
   * @private
   */

  this.pointerdownListenerKey_ = _events2.default.listen(this.pointerEventHandler_, _eventtype2.default.POINTERDOWN, this.handlePointerDown_, this);
  /**
   * @type {?ol.EventsKey}
   * @private
   */

  this.relayedListenerKey_ = _events2.default.listen(this.pointerEventHandler_, _eventtype2.default.POINTERMOVE, this.relayEvent_, this);
};

_index2.default.inherits(_ol_MapBrowserEventHandler_, _eventtarget2.default);
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.emulateClick_ = function (pointerEvent) {
  var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.CLICK, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);

  if (this.clickTimeoutId_ !== 0) {
    // double-click
    clearTimeout(this.clickTimeoutId_);
    this.clickTimeoutId_ = 0;
    newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.DBLCLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
  } else {
    // click
    this.clickTimeoutId_ = setTimeout(function () {
      this.clickTimeoutId_ = 0;
      var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.SINGLECLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    }.bind(this), 250);
  }
};
/**
 * Keeps track on how many pointers are currently active.
 *
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.updateActivePointers_ = function (pointerEvent) {
  var event = pointerEvent;

  if (event.type == _mapbrowsereventtype2.default.POINTERUP || event.type == _mapbrowsereventtype2.default.POINTERCANCEL) {
    delete this.trackedTouches_[event.pointerId];
  } else if (event.type == _mapbrowsereventtype2.default.POINTERDOWN) {
    this.trackedTouches_[event.pointerId] = true;
  }

  this.activePointers_ = Object.keys(this.trackedTouches_).length;
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.handlePointerUp_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.POINTERUP, this.map_, pointerEvent);
  this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen
  // contact. isMouseActionButton returns true in these cases (evt.button is set
  // to 0).
  // See http://www.w3.org/TR/pointerevents/#button-states
  // We only fire click, singleclick, and doubleclick if nobody has called
  // event.stopPropagation() or event.preventDefault().

  if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
    this.emulateClick_(this.down_);
  }

  if (this.activePointers_ === 0) {
    this.dragListenerKeys_.forEach(_events2.default.unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.dragging_ = false;
    this.down_ = null;
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} If the left mouse button was pressed.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.isMouseActionButton_ = function (pointerEvent) {
  return pointerEvent.button === 0;
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.handlePointerDown_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.POINTERDOWN, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);
  this.down_ = pointerEvent;

  if (this.dragListenerKeys_.length === 0) {
    /* Set up a pointer event handler on the `document`,
     * which is required when the pointer is moved outside
     * the viewport when dragging.
     */
    this.documentPointerEventHandler_ = new _pointereventhandler2.default(document);
    this.dragListenerKeys_.push(_events2.default.listen(this.documentPointerEventHandler_, _mapbrowsereventtype2.default.POINTERMOVE, this.handlePointerMove_, this), _events2.default.listen(this.documentPointerEventHandler_, _mapbrowsereventtype2.default.POINTERUP, this.handlePointerUp_, this),
    /* Note that the listener for `pointercancel is set up on
    * `pointerEventHandler_` and not `documentPointerEventHandler_` like
    * the `pointerup` and `pointermove` listeners.
    *
    * The reason for this is the following: `TouchSource.vacuumTouches_()`
    * issues `pointercancel` events, when there was no `touchend` for a
    * `touchstart`. Now, let's say a first `touchstart` is registered on
    * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
    * But `documentPointerEventHandler_` doesn't know about the first
    * `touchstart`. If there is no `touchend` for the `touchstart`, we can
    * only receive a `touchcancel` from `pointerEventHandler_`, because it is
    * only registered there.
    */
    _events2.default.listen(this.pointerEventHandler_, _mapbrowsereventtype2.default.POINTERCANCEL, this.handlePointerUp_, this));
  }
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.handlePointerMove_ = function (pointerEvent) {
  // Between pointerdown and pointerup, pointermove events are triggered.
  // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
  // moved a significant distance.
  if (this.isMoving_(pointerEvent)) {
    this.dragging_ = true;
    var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
    this.dispatchEvent(newEvent);
  } // Some native android browser triggers mousemove events during small period
  // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
  // https://code.google.com/p/android/issues/detail?id=19827
  // ex: Galaxy Tab P3110 + Android 4.1.1


  pointerEvent.preventDefault();
};
/**
 * Wrap and relay a pointer event.  Note that this requires that the type
 * string for the MapBrowserPointerEvent matches the PointerEvent type.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.relayEvent_ = function (pointerEvent) {
  var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
  this.dispatchEvent(new _mapbrowserpointerevent2.default(pointerEvent.type, this.map_, pointerEvent, dragging));
};
/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} Is moving.
 * @private
 */


_ol_MapBrowserEventHandler_.prototype.isMoving_ = function (pointerEvent) {
  return Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
};
/**
 * @inheritDoc
 */


_ol_MapBrowserEventHandler_.prototype.disposeInternal = function () {
  if (this.relayedListenerKey_) {
    _events2.default.unlistenByKey(this.relayedListenerKey_);

    this.relayedListenerKey_ = null;
  }

  if (this.pointerdownListenerKey_) {
    _events2.default.unlistenByKey(this.pointerdownListenerKey_);

    this.pointerdownListenerKey_ = null;
  }

  this.dragListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.dragListenerKeys_.length = 0;

  if (this.documentPointerEventHandler_) {
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }

  if (this.pointerEventHandler_) {
    this.pointerEventHandler_.dispose();
    this.pointerEventHandler_ = null;
  }

  _eventtarget2.default.prototype.disposeInternal.call(this);
};

exports.default = _ol_MapBrowserEventHandler_;

},{"./events.js":49,"./events/eventtarget.js":52,"./has.js":85,"./index.js":90,"./mapbrowsereventtype.js":119,"./mapbrowserpointerevent.js":120,"./pointer/eventtype.js":135,"./pointer/pointereventhandler.js":140}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventtype = require("./events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Constants for event names.
 * @enum {string}
 */
var _ol_MapBrowserEventType_ = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event ol.MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event ol.MapBrowserEvent#click
   * @api
   */
  CLICK: _eventtype2.default.CLICK,

  /**
   * A true double click, with no dragging.
   * @event ol.MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _eventtype2.default.DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event ol.MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event ol.MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
exports.default = _ol_MapBrowserEventType_;

},{"./events/eventtype.js":53}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _mapbrowserevent = require("./mapbrowserevent.js");

var _mapbrowserevent2 = _interopRequireDefault(_mapbrowserevent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var _ol_MapBrowserPointerEvent_ = function (type, map, pointerEvent, opt_dragging, opt_frameState) {
  _mapbrowserevent2.default.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);
  /**
   * @const
   * @type {ol.pointer.PointerEvent}
   */


  this.pointerEvent = pointerEvent;
};

_index2.default.inherits(_ol_MapBrowserPointerEvent_, _mapbrowserevent2.default);

exports.default = _ol_MapBrowserPointerEvent_;

},{"./index.js":90,"./mapbrowserevent.js":117}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _event = require("./events/event.js");

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link ol.Map} for which events trigger a map event.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.MapEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var _ol_MapEvent_ = function (type, map, opt_frameState) {
  _event2.default.call(this, type);
  /**
   * The map where the event occurred.
   * @type {ol.PluggableMap}
   * @api
   */


  this.map = map;
  /**
   * The frame state at the time of the event.
   * @type {?olx.FrameState}
   * @api
   */

  this.frameState = opt_frameState !== undefined ? opt_frameState : null;
};

_index2.default.inherits(_ol_MapEvent_, _event2.default);

exports.default = _ol_MapEvent_;

},{"./events/event.js":51,"./index.js":90}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_MapEventType_ = {
  /**
   * Triggered after a map frame is rendered.
   * @event ol.MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event ol.MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event ol.MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'
};
exports.default = _ol_MapEventType_;

},{}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_MapProperty_ = {
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
};
exports.default = _ol_MapProperty_;

},{}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require("./asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_math_ = {};
/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */

_ol_math_.clamp = function (value, min, max) {
  return Math.min(Math.max(value, min), max);
};
/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */


_ol_math_.cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;

  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function (x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }

  return cosh;
}();
/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */


_ol_math_.roundUpToPowerOfTwo = function (x) {
  _asserts2.default.assert(0 < x, 29); // `x` must be greater than `0`


  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
};
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


_ol_math_.squaredSegmentDistance = function (x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;

  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return _ol_math_.squaredDistance(x, y, x1, y1);
};
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


_ol_math_.squaredDistance = function (x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
};
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */


_ol_math_.solveLinearSystem = function (mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);

    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);

      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    } // Swap max row with i-th (current) row


    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column

    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];

      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  } // Solve Ax=b for upper triangular matrix A (mat)


  var x = new Array(n);

  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];

    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }

  return x;
};
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */


_ol_math_.toDegrees = function (angleInRadians) {
  return angleInRadians * 180 / Math.PI;
};
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */


_ol_math_.toRadians = function (angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
};
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */


_ol_math_.modulo = function (a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */


_ol_math_.lerp = function (a, b, x) {
  return a + x * (b - a);
};

exports.default = _ol_math_;

},{"./asserts.js":32}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_obj_ = {};
/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */

_ol_obj_.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);

  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];

    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }

  return output;
};
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */

_ol_obj_.clear = function (object) {
  for (var property in object) {
    delete object[property];
  }
};
/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */


_ol_obj_.getValues = function (object) {
  var values = [];

  for (var property in object) {
    values.push(object[property]);
  }

  return values;
};
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */


_ol_obj_.isEmpty = function (object) {
  var property;

  for (property in object) {
    return false;
  }

  return !property;
};

exports.default = _ol_obj_;

},{}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _objecteventtype = require("./objecteventtype.js");

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _observable = require("./observable.js");

var _observable2 = _interopRequireDefault(_observable);

var _event = require("./events/event.js");

var _event2 = _interopRequireDefault(_event);

var _obj = require("./obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link ol.Observable} with observable properties, where each
 * property is observable as well as the object as a whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link ol.Map} has a `target` property, accessed with `getTarget()`  and
 * changed with `setTarget()`. Not all properties are however settable. There
 * are also general-purpose accessors `get()` and `set()`. For example,
 * `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link ol.View} has a `center`
 * property, so `view.on('change:center', function(evt) {...});` would call the
 * function whenever the value of the center property changes. Within the
 * function, `evt.target` would be the view, so `evt.target.getCenter()` would
 * return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link ol.Object#getProperties object.getProperties()}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @constructor
 * @extends {ol.Observable}
 * @param {Object.<string, *>=} opt_values An object with key-value pairs.
 * @fires ol.Object.Event
 * @api
 */
var _ol_Object_ = function (opt_values) {
  _observable2.default.call(this); // Call ol.getUid to ensure that the order of objects' ids is the same as
  // the order in which they were created.  This also helps to ensure that
  // object properties are always added in the same order, which helps many
  // JavaScript engines generate faster code.


  _index2.default.getUid(this);
  /**
   * @private
   * @type {!Object.<string, *>}
   */


  this.values_ = {};

  if (opt_values !== undefined) {
    this.setProperties(opt_values);
  }
};

_index2.default.inherits(_ol_Object_, _observable2.default);
/**
 * @private
 * @type {Object.<string, string>}
 */


_ol_Object_.changeEventTypeCache_ = {};
/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */

_ol_Object_.getChangeEventType = function (key) {
  return _ol_Object_.changeEventTypeCache_.hasOwnProperty(key) ? _ol_Object_.changeEventTypeCache_[key] : _ol_Object_.changeEventTypeCache_[key] = 'change:' + key;
};
/**
 * Gets a value.
 * @param {string} key Key name.
 * @return {*} Value.
 * @api
 */


_ol_Object_.prototype.get = function (key) {
  var value;

  if (this.values_.hasOwnProperty(key)) {
    value = this.values_[key];
  }

  return value;
};
/**
 * Get a list of object property names.
 * @return {Array.<string>} List of property names.
 * @api
 */


_ol_Object_.prototype.getKeys = function () {
  return Object.keys(this.values_);
};
/**
 * Get an object of all property names and values.
 * @return {Object.<string, *>} Object.
 * @api
 */


_ol_Object_.prototype.getProperties = function () {
  return _obj2.default.assign({}, this.values_);
};
/**
 * @param {string} key Key name.
 * @param {*} oldValue Old value.
 */


_ol_Object_.prototype.notify = function (key, oldValue) {
  var eventType;
  eventType = _ol_Object_.getChangeEventType(key);
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
  eventType = _objecteventtype2.default.PROPERTYCHANGE;
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
};
/**
 * Sets a value.
 * @param {string} key Key name.
 * @param {*} value Value.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */


_ol_Object_.prototype.set = function (key, value, opt_silent) {
  if (opt_silent) {
    this.values_[key] = value;
  } else {
    var oldValue = this.values_[key];
    this.values_[key] = value;

    if (oldValue !== value) {
      this.notify(key, oldValue);
    }
  }
};
/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * @param {Object.<string, *>} values Values.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */


_ol_Object_.prototype.setProperties = function (values, opt_silent) {
  var key;

  for (key in values) {
    this.set(key, values[key], opt_silent);
  }
};
/**
 * Unsets a property.
 * @param {string} key Key name.
 * @param {boolean=} opt_silent Unset without triggering an event.
 * @api
 */


_ol_Object_.prototype.unset = function (key, opt_silent) {
  if (key in this.values_) {
    var oldValue = this.values_[key];
    delete this.values_[key];

    if (!opt_silent) {
      this.notify(key, oldValue);
    }
  }
};
/**
 * @classdesc
 * Events emitted by {@link ol.Object} instances are instances of this type.
 *
 * @param {string} type The event type.
 * @param {string} key The property name.
 * @param {*} oldValue The old value for `key`.
 * @extends {ol.events.Event}
 * @implements {oli.Object.Event}
 * @constructor
 */


_ol_Object_.Event = function (type, key, oldValue) {
  _event2.default.call(this, type);
  /**
   * The name of the property whose value is changing.
   * @type {string}
   * @api
   */


  this.key = key;
  /**
   * The old value. To get the new value use `e.target.get(e.key)` where
   * `e` is the event object.
   * @type {*}
   * @api
   */

  this.oldValue = oldValue;
};

_index2.default.inherits(_ol_Object_.Event, _event2.default);

exports.default = _ol_Object_;

},{"./events/event.js":51,"./index.js":90,"./obj.js":125,"./objecteventtype.js":127,"./observable.js":128}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_ObjectEventType_ = {
  /**
   * Triggered when a property is changed.
   * @event ol.Object.Event#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};
exports.default = _ol_ObjectEventType_;

},{}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _events = require("./events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require("./events/eventtarget.js");

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require("./events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link ol.Observable#changed}.
 *
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @api
 */
var _ol_Observable_ = function () {
  _eventtarget2.default.call(this);
  /**
   * @private
   * @type {number}
   */


  this.revision_ = 0;
};

_index2.default.inherits(_ol_Observable_, _eventtarget2.default);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {ol.EventsKey|Array.<ol.EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */


_ol_Observable_.unByKey = function (key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      _events2.default.unlistenByKey(key[i]);
    }
  } else {
    _events2.default.unlistenByKey(
    /** @type {ol.EventsKey} */
    key);
  }
};
/**
 * Increases the revision counter and dispatches a 'change' event.
 * @api
 */


_ol_Observable_.prototype.changed = function () {
  ++this.revision_;
  this.dispatchEvent(_eventtype2.default.CHANGE);
};
/**
 * Dispatches an event and calls all listeners listening for events
 * of this type. The event parameter can either be a string or an
 * Object with a `type` property.
 *
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event object.
 * @function
 * @api
 */


_ol_Observable_.prototype.dispatchEvent;
/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * @return {number} Revision.
 * @api
 */

_ol_Observable_.prototype.getRevision = function () {
  return this.revision_;
};
/**
 * Listen for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */


_ol_Observable_.prototype.on = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);

    for (var i = 0; i < len; ++i) {
      keys[i] = _events2.default.listen(this, type[i], listener, opt_this);
    }

    return keys;
  } else {
    return _events2.default.listen(this,
    /** @type {string} */
    type, listener, opt_this);
  }
};
/**
 * Listen once for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */


_ol_Observable_.prototype.once = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);

    for (var i = 0; i < len; ++i) {
      keys[i] = _events2.default.listenOnce(this, type[i], listener, opt_this);
    }

    return keys;
  } else {
    return _events2.default.listenOnce(this,
    /** @type {string} */
    type, listener, opt_this);
  }
};
/**
 * Unlisten for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object which was used as `this` by the
 * `listener`.
 * @api
 */


_ol_Observable_.prototype.un = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    for (var i = 0, ii = type.length; i < ii; ++i) {
      _events2.default.unlisten(this, type[i], listener, opt_this);
    }

    return;
  } else {
    _events2.default.unlisten(this,
    /** @type {string} */
    type, listener, opt_this);
  }
};

exports.default = _ol_Observable_;

},{"./events.js":49,"./events/eventtarget.js":52,"./events/eventtype.js":53,"./index.js":90}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _mapeventtype = require("./mapeventtype.js");

var _mapeventtype2 = _interopRequireDefault(_mapeventtype);

var _object = require("./object.js");

var _object2 = _interopRequireDefault(_object);

var _overlaypositioning = require("./overlaypositioning.js");

var _overlaypositioning2 = _interopRequireDefault(_overlaypositioning);

var _css = require("./css.js");

var _css2 = _interopRequireDefault(_css);

var _dom = require("./dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("./events.js");

var _events2 = _interopRequireDefault(_events);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link ol.control.Control}, Overlays are visible widgets.
 * Unlike Controls, they are not in a fixed position on the screen, but are tied
 * to a geographical coordinate, so panning the map will move an Overlay but not
 * a Control.
 *
 * Example:
 *
 *     var popup = new ol.Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.OverlayOptions} options Overlay options.
 * @api
 */
var _ol_Overlay_ = function (options) {
  _object2.default.call(this);
  /**
   * @protected
   * @type {olx.OverlayOptions}
   */


  this.options = options;
  /**
   * @protected
   * @type {number|string|undefined}
   */

  this.id = options.id;
  /**
   * @protected
   * @type {boolean}
   */

  this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
  /**
   * @protected
   * @type {boolean}
   */

  this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
  /**
   * @protected
   * @type {Element}
   */

  this.element = document.createElement('DIV');
  this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + _css2.default.CLASS_SELECTABLE;
  this.element.style.position = 'absolute';
  /**
   * @protected
   * @type {boolean}
   */

  this.autoPan = options.autoPan !== undefined ? options.autoPan : false;
  /**
   * @protected
   * @type {olx.OverlayPanOptions}
   */

  this.autoPanAnimation = options.autoPanAnimation ||
  /** @type {olx.OverlayPanOptions} */
  {};
  /**
   * @protected
   * @type {number}
   */

  this.autoPanMargin = options.autoPanMargin !== undefined ? options.autoPanMargin : 20;
  /**
   * @protected
   * @type {{bottom_: string,
   *         left_: string,
   *         right_: string,
   *         top_: string,
   *         visible: boolean}}
   */

  this.rendered = {
    bottom_: '',
    left_: '',
    right_: '',
    top_: '',
    visible: true
  };
  /**
   * @protected
   * @type {?ol.EventsKey}
   */

  this.mapPostrenderListenerKey = null;

  _events2.default.listen(this, _object2.default.getChangeEventType(_ol_Overlay_.Property.ELEMENT), this.handleElementChanged, this);

  _events2.default.listen(this, _object2.default.getChangeEventType(_ol_Overlay_.Property.MAP), this.handleMapChanged, this);

  _events2.default.listen(this, _object2.default.getChangeEventType(_ol_Overlay_.Property.OFFSET), this.handleOffsetChanged, this);

  _events2.default.listen(this, _object2.default.getChangeEventType(_ol_Overlay_.Property.POSITION), this.handlePositionChanged, this);

  _events2.default.listen(this, _object2.default.getChangeEventType(_ol_Overlay_.Property.POSITIONING), this.handlePositioningChanged, this);

  if (options.element !== undefined) {
    this.setElement(options.element);
  }

  this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
  this.setPositioning(options.positioning !== undefined ?
  /** @type {ol.OverlayPositioning} */
  options.positioning : _overlaypositioning2.default.TOP_LEFT);

  if (options.position !== undefined) {
    this.setPosition(options.position);
  }
};

_index2.default.inherits(_ol_Overlay_, _object2.default);
/**
 * Get the DOM element of this overlay.
 * @return {Element|undefined} The Element containing the overlay.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getElement = function () {
  return (
    /** @type {Element|undefined} */
    this.get(_ol_Overlay_.Property.ELEMENT)
  );
};
/**
 * Get the overlay identifier which is set on constructor.
 * @return {number|string|undefined} Id.
 * @api
 */


_ol_Overlay_.prototype.getId = function () {
  return this.id;
};
/**
 * Get the map associated with this overlay.
 * @return {ol.PluggableMap|undefined} The map that the overlay is part of.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getMap = function () {
  return (
    /** @type {ol.PluggableMap|undefined} */
    this.get(_ol_Overlay_.Property.MAP)
  );
};
/**
 * Get the offset of this overlay.
 * @return {Array.<number>} The offset.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getOffset = function () {
  return (
    /** @type {Array.<number>} */
    this.get(_ol_Overlay_.Property.OFFSET)
  );
};
/**
 * Get the current position of this overlay.
 * @return {ol.Coordinate|undefined} The spatial point that the overlay is
 *     anchored at.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getPosition = function () {
  return (
    /** @type {ol.Coordinate|undefined} */
    this.get(_ol_Overlay_.Property.POSITION)
  );
};
/**
 * Get the current positioning of this overlay.
 * @return {ol.OverlayPositioning} How the overlay is positioned
 *     relative to its point on the map.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.getPositioning = function () {
  return (
    /** @type {ol.OverlayPositioning} */
    this.get(_ol_Overlay_.Property.POSITIONING)
  );
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handleElementChanged = function () {
  _dom2.default.removeChildren(this.element);

  var element = this.getElement();

  if (element) {
    this.element.appendChild(element);
  }
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handleMapChanged = function () {
  if (this.mapPostrenderListenerKey) {
    _dom2.default.removeNode(this.element);

    _events2.default.unlistenByKey(this.mapPostrenderListenerKey);

    this.mapPostrenderListenerKey = null;
  }

  var map = this.getMap();

  if (map) {
    this.mapPostrenderListenerKey = _events2.default.listen(map, _mapeventtype2.default.POSTRENDER, this.render, this);
    this.updatePixelPosition();
    var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();

    if (this.insertFirst) {
      container.insertBefore(this.element, container.childNodes[0] || null);
    } else {
      container.appendChild(this.element);
    }
  }
};
/**
 * @protected
 */


_ol_Overlay_.prototype.render = function () {
  this.updatePixelPosition();
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handleOffsetChanged = function () {
  this.updatePixelPosition();
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handlePositionChanged = function () {
  this.updatePixelPosition();

  if (this.get(_ol_Overlay_.Property.POSITION) && this.autoPan) {
    this.panIntoView();
  }
};
/**
 * @protected
 */


_ol_Overlay_.prototype.handlePositioningChanged = function () {
  this.updatePixelPosition();
};
/**
 * Set the DOM element to be associated with this overlay.
 * @param {Element|undefined} element The Element containing the overlay.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setElement = function (element) {
  this.set(_ol_Overlay_.Property.ELEMENT, element);
};
/**
 * Set the map to be associated with this overlay.
 * @param {ol.PluggableMap|undefined} map The map that the overlay is part of.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setMap = function (map) {
  this.set(_ol_Overlay_.Property.MAP, map);
};
/**
 * Set the offset for this overlay.
 * @param {Array.<number>} offset Offset.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setOffset = function (offset) {
  this.set(_ol_Overlay_.Property.OFFSET, offset);
};
/**
 * Set the position for this overlay. If the position is `undefined` the
 * overlay is hidden.
 * @param {ol.Coordinate|undefined} position The spatial point that the overlay
 *     is anchored at.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setPosition = function (position) {
  this.set(_ol_Overlay_.Property.POSITION, position);
};
/**
 * Pan the map so that the overlay is entirely visible in the current viewport
 * (if necessary).
 * @protected
 */


_ol_Overlay_.prototype.panIntoView = function () {
  var map = this.getMap();

  if (!map || !map.getTargetElement()) {
    return;
  }

  var mapRect = this.getRect(map.getTargetElement(), map.getSize());
  var element =
  /** @type {!Element} */
  this.getElement();
  var overlayRect = this.getRect(element, [_dom2.default.outerWidth(element), _dom2.default.outerHeight(element)]);
  var margin = this.autoPanMargin;

  if (!_extent2.default.containsExtent(mapRect, overlayRect)) {
    // the overlay is not completely inside the viewport, so pan the map
    var offsetLeft = overlayRect[0] - mapRect[0];
    var offsetRight = mapRect[2] - overlayRect[2];
    var offsetTop = overlayRect[1] - mapRect[1];
    var offsetBottom = mapRect[3] - overlayRect[3];
    var delta = [0, 0];

    if (offsetLeft < 0) {
      // move map to the left
      delta[0] = offsetLeft - margin;
    } else if (offsetRight < 0) {
      // move map to the right
      delta[0] = Math.abs(offsetRight) + margin;
    }

    if (offsetTop < 0) {
      // move map up
      delta[1] = offsetTop - margin;
    } else if (offsetBottom < 0) {
      // move map down
      delta[1] = Math.abs(offsetBottom) + margin;
    }

    if (delta[0] !== 0 || delta[1] !== 0) {
      var center =
      /** @type {ol.Coordinate} */
      map.getView().getCenter();
      var centerPx = map.getPixelFromCoordinate(center);
      var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
      map.getView().animate({
        center: map.getCoordinateFromPixel(newCenterPx),
        duration: this.autoPanAnimation.duration,
        easing: this.autoPanAnimation.easing
      });
    }
  }
};
/**
 * Get the extent of an element relative to the document
 * @param {Element|undefined} element The element.
 * @param {ol.Size|undefined} size The size of the element.
 * @return {ol.Extent} The extent.
 * @protected
 */


_ol_Overlay_.prototype.getRect = function (element, size) {
  var box = element.getBoundingClientRect();
  var offsetX = box.left + window.pageXOffset;
  var offsetY = box.top + window.pageYOffset;
  return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
};
/**
 * Set the positioning for this overlay.
 * @param {ol.OverlayPositioning} positioning how the overlay is
 *     positioned relative to its point on the map.
 * @observable
 * @api
 */


_ol_Overlay_.prototype.setPositioning = function (positioning) {
  this.set(_ol_Overlay_.Property.POSITIONING, positioning);
};
/**
 * Modify the visibility of the element.
 * @param {boolean} visible Element visibility.
 * @protected
 */


_ol_Overlay_.prototype.setVisible = function (visible) {
  if (this.rendered.visible !== visible) {
    this.element.style.display = visible ? '' : 'none';
    this.rendered.visible = visible;
  }
};
/**
 * Update pixel position.
 * @protected
 */


_ol_Overlay_.prototype.updatePixelPosition = function () {
  var map = this.getMap();
  var position = this.getPosition();

  if (!map || !map.isRendered() || !position) {
    this.setVisible(false);
    return;
  }

  var pixel = map.getPixelFromCoordinate(position);
  var mapSize = map.getSize();
  this.updateRenderedPosition(pixel, mapSize);
};
/**
 * @param {ol.Pixel} pixel The pixel location.
 * @param {ol.Size|undefined} mapSize The map size.
 * @protected
 */


_ol_Overlay_.prototype.updateRenderedPosition = function (pixel, mapSize) {
  var style = this.element.style;
  var offset = this.getOffset();
  var positioning = this.getPositioning();
  this.setVisible(true);
  var offsetX = offset[0];
  var offsetY = offset[1];

  if (positioning == _overlaypositioning2.default.BOTTOM_RIGHT || positioning == _overlaypositioning2.default.CENTER_RIGHT || positioning == _overlaypositioning2.default.TOP_RIGHT) {
    if (this.rendered.left_ !== '') {
      this.rendered.left_ = style.left = '';
    }

    var right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';

    if (this.rendered.right_ != right) {
      this.rendered.right_ = style.right = right;
    }
  } else {
    if (this.rendered.right_ !== '') {
      this.rendered.right_ = style.right = '';
    }

    if (positioning == _overlaypositioning2.default.BOTTOM_CENTER || positioning == _overlaypositioning2.default.CENTER_CENTER || positioning == _overlaypositioning2.default.TOP_CENTER) {
      offsetX -= this.element.offsetWidth / 2;
    }

    var left = Math.round(pixel[0] + offsetX) + 'px';

    if (this.rendered.left_ != left) {
      this.rendered.left_ = style.left = left;
    }
  }

  if (positioning == _overlaypositioning2.default.BOTTOM_LEFT || positioning == _overlaypositioning2.default.BOTTOM_CENTER || positioning == _overlaypositioning2.default.BOTTOM_RIGHT) {
    if (this.rendered.top_ !== '') {
      this.rendered.top_ = style.top = '';
    }

    var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';

    if (this.rendered.bottom_ != bottom) {
      this.rendered.bottom_ = style.bottom = bottom;
    }
  } else {
    if (this.rendered.bottom_ !== '') {
      this.rendered.bottom_ = style.bottom = '';
    }

    if (positioning == _overlaypositioning2.default.CENTER_LEFT || positioning == _overlaypositioning2.default.CENTER_CENTER || positioning == _overlaypositioning2.default.CENTER_RIGHT) {
      offsetY -= this.element.offsetHeight / 2;
    }

    var top = Math.round(pixel[1] + offsetY) + 'px';

    if (this.rendered.top_ != top) {
      this.rendered.top_ = style.top = top;
    }
  }
};
/**
 * returns the options this Overlay has been created with
 * @public
 * @return {olx.OverlayOptions} overlay options
 */


_ol_Overlay_.prototype.getOptions = function () {
  return this.options;
};
/**
 * @enum {string}
 * @protected
 */


_ol_Overlay_.Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};
exports.default = _ol_Overlay_;

},{"./css.js":45,"./dom.js":47,"./events.js":49,"./extent.js":55,"./index.js":90,"./mapeventtype.js":122,"./object.js":126,"./overlaypositioning.js":130}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */
var _ol_OverlayPositioning_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_CENTER: 'bottom-center',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER_LEFT: 'center-left',
  CENTER_CENTER: 'center-center',
  CENTER_RIGHT: 'center-right',
  TOP_LEFT: 'top-left',
  TOP_CENTER: 'top-center',
  TOP_RIGHT: 'top-right'
};
exports.default = _ol_OverlayPositioning_;

},{}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _collection = require("./collection.js");

var _collection2 = _interopRequireDefault(_collection);

var _collectioneventtype = require("./collectioneventtype.js");

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _mapbrowserevent = require("./mapbrowserevent.js");

var _mapbrowserevent2 = _interopRequireDefault(_mapbrowserevent);

var _mapbrowsereventhandler = require("./mapbrowsereventhandler.js");

var _mapbrowsereventhandler2 = _interopRequireDefault(_mapbrowsereventhandler);

var _mapbrowsereventtype = require("./mapbrowsereventtype.js");

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _mapevent = require("./mapevent.js");

var _mapevent2 = _interopRequireDefault(_mapevent);

var _mapeventtype = require("./mapeventtype.js");

var _mapeventtype2 = _interopRequireDefault(_mapeventtype);

var _mapproperty = require("./mapproperty.js");

var _mapproperty2 = _interopRequireDefault(_mapproperty);

var _object = require("./object.js");

var _object2 = _interopRequireDefault(_object);

var _objecteventtype = require("./objecteventtype.js");

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _tilequeue = require("./tilequeue.js");

var _tilequeue2 = _interopRequireDefault(_tilequeue);

var _view = require("./view.js");

var _view2 = _interopRequireDefault(_view);

var _viewhint = require("./viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _asserts = require("./asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _dom = require("./dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("./events.js");

var _events2 = _interopRequireDefault(_events);

var _event = require("./events/event.js");

var _event2 = _interopRequireDefault(_event);

var _eventtype = require("./events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _functions = require("./functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _has = require("./has.js");

var _has2 = _interopRequireDefault(_has);

var _group = require("./layer/group.js");

var _group2 = _interopRequireDefault(_group);

var _obj = require("./obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _plugins = require("./plugins.js");

var _plugins2 = _interopRequireDefault(_plugins);

var _type = require("./renderer/type.js");

var _type2 = _interopRequireDefault(_type);

var _size = require("./size.js");

var _size2 = _interopRequireDefault(_size);

var _priorityqueue = require("./structs/priorityqueue.js");

var _priorityqueue2 = _interopRequireDefault(_priorityqueue);

var _transform = require("./transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.Object}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */
var _ol_PluggableMap_ = function (options) {
  _object2.default.call(this);

  var optionsInternal = _ol_PluggableMap_.createOptionsInternal(options);
  /**
   * @type {boolean}
   * @private
   */


  this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;
  /**
   * @type {boolean}
   * @private
   */

  this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _has2.default.DEVICE_PIXEL_RATIO;
  /**
   * @private
   * @type {Object.<string, string>}
   */

  this.logos_ = optionsInternal.logos;
  /**
   * @private
   * @type {number|undefined}
   */

  this.animationDelayKey_;
  /**
   * @private
   */

  this.animationDelay_ = function () {
    this.animationDelayKey_ = undefined;
    this.renderFrame_.call(this, Date.now());
  }.bind(this);
  /**
   * @private
   * @type {ol.Transform}
   */


  this.coordinateToPixelTransform_ = _transform2.default.create();
  /**
   * @private
   * @type {ol.Transform}
   */

  this.pixelToCoordinateTransform_ = _transform2.default.create();
  /**
   * @private
   * @type {number}
   */

  this.frameIndex_ = 0;
  /**
   * @private
   * @type {?olx.FrameState}
   */

  this.frameState_ = null;
  /**
   * The extent at the previous 'moveend' event.
   * @private
   * @type {ol.Extent}
   */

  this.previousExtent_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.viewPropertyListenerKey_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.viewChangeListenerKey_ = null;
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */

  this.layerGroupPropertyListenerKeys_ = null;
  /**
   * @private
   * @type {Element}
   */

  this.viewport_ = document.createElement('DIV');
  this.viewport_.className = 'ol-viewport' + (_has2.default.TOUCH ? ' ol-touch' : '');
  this.viewport_.style.position = 'relative';
  this.viewport_.style.overflow = 'hidden';
  this.viewport_.style.width = '100%';
  this.viewport_.style.height = '100%'; // prevent page zoom on IE >= 10 browsers

  this.viewport_.style.msTouchAction = 'none';
  this.viewport_.style.touchAction = 'none';
  /**
   * @private
   * @type {!Element}
   */

  this.overlayContainer_ = document.createElement('DIV');
  this.overlayContainer_.className = 'ol-overlaycontainer';
  this.viewport_.appendChild(this.overlayContainer_);
  /**
   * @private
   * @type {!Element}
   */

  this.overlayContainerStopEvent_ = document.createElement('DIV');
  this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
  var overlayEvents = [_eventtype2.default.CLICK, _eventtype2.default.DBLCLICK, _eventtype2.default.MOUSEDOWN, _eventtype2.default.TOUCHSTART, _eventtype2.default.MSPOINTERDOWN, _mapbrowsereventtype2.default.POINTERDOWN, _eventtype2.default.MOUSEWHEEL, _eventtype2.default.WHEEL];

  for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
    _events2.default.listen(this.overlayContainerStopEvent_, overlayEvents[i], _event2.default.stopPropagation);
  }

  this.viewport_.appendChild(this.overlayContainerStopEvent_);
  /**
   * @private
   * @type {ol.MapBrowserEventHandler}
   */

  this.mapBrowserEventHandler_ = new _mapbrowsereventhandler2.default(this, options.moveTolerance);

  for (var key in _mapbrowsereventtype2.default) {
    _events2.default.listen(this.mapBrowserEventHandler_, _mapbrowsereventtype2.default[key], this.handleMapBrowserEvent, this);
  }
  /**
   * @private
   * @type {Element|Document}
   */


  this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */

  this.keyHandlerKeys_ = null;

  _events2.default.listen(this.viewport_, _eventtype2.default.WHEEL, this.handleBrowserEvent, this);

  _events2.default.listen(this.viewport_, _eventtype2.default.MOUSEWHEEL, this.handleBrowserEvent, this);
  /**
   * @type {ol.Collection.<ol.control.Control>}
   * @protected
   */


  this.controls = optionsInternal.controls || new _collection2.default();
  /**
   * @type {ol.Collection.<ol.interaction.Interaction>}
   * @protected
   */

  this.interactions = optionsInternal.interactions || new _collection2.default();
  /**
   * @type {ol.Collection.<ol.Overlay>}
   * @private
   */

  this.overlays_ = optionsInternal.overlays;
  /**
   * A lookup of overlays by id.
   * @private
   * @type {Object.<string, ol.Overlay>}
   */

  this.overlayIdIndex_ = {};
  /**
   * @type {ol.renderer.Map}
   * @private
   */

  this.renderer_ = optionsInternal.mapRendererPlugin['create'](this.viewport_, this);
  /**
   * @type {function(Event)|undefined}
   * @private
   */

  this.handleResize_;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.focus_ = null;
  /**
   * @private
   * @type {Array.<ol.PostRenderFunction>}
   */

  this.postRenderFunctions_ = [];
  /**
   * @private
   * @type {ol.TileQueue}
   */

  this.tileQueue_ = new _tilequeue2.default(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));
  /**
   * Uids of features to skip at rendering time.
   * @type {Object.<string, boolean>}
   * @private
   */

  this.skippedFeatureUids_ = {};

  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.LAYERGROUP), this.handleLayerGroupChanged_, this);

  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.VIEW), this.handleViewChanged_, this);

  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.SIZE), this.handleSizeChanged_, this);

  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.TARGET), this.handleTargetChanged_, this); // setProperties will trigger the rendering of the map if the map
  // is "defined" already.


  this.setProperties(optionsInternal.values);
  this.controls.forEach(
  /**
   * @param {ol.control.Control} control Control.
   * @this {ol.PluggableMap}
   */
  function (control) {
    control.setMap(this);
  }, this);

  _events2.default.listen(this.controls, _collectioneventtype2.default.ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  _events2.default.listen(this.controls, _collectioneventtype2.default.REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.interactions.forEach(
  /**
   * @param {ol.interaction.Interaction} interaction Interaction.
   * @this {ol.PluggableMap}
   */
  function (interaction) {
    interaction.setMap(this);
  }, this);

  _events2.default.listen(this.interactions, _collectioneventtype2.default.ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  _events2.default.listen(this.interactions, _collectioneventtype2.default.REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.overlays_.forEach(this.addOverlayInternal_, this);

  _events2.default.listen(this.overlays_, _collectioneventtype2.default.ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    this.addOverlayInternal_(
    /** @type {ol.Overlay} */
    event.element);
  }, this);

  _events2.default.listen(this.overlays_, _collectioneventtype2.default.REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    var overlay =
    /** @type {ol.Overlay} */
    event.element;
    var id = overlay.getId();

    if (id !== undefined) {
      delete this.overlayIdIndex_[id.toString()];
    }

    event.element.setMap(null);
  }, this);
};

_index2.default.inherits(_ol_PluggableMap_, _object2.default);
/**
 * Add the given control to the map.
 * @param {ol.control.Control} control Control.
 * @api
 */


_ol_PluggableMap_.prototype.addControl = function (control) {
  this.getControls().push(control);
};
/**
 * Add the given interaction to the map.
 * @param {ol.interaction.Interaction} interaction Interaction to add.
 * @api
 */


_ol_PluggableMap_.prototype.addInteraction = function (interaction) {
  this.getInteractions().push(interaction);
};
/**
 * Adds the given layer to the top of this map. If you want to add a layer
 * elsewhere in the stack, use `getLayers()` and the methods available on
 * {@link ol.Collection}.
 * @param {ol.layer.Base} layer Layer.
 * @api
 */


_ol_PluggableMap_.prototype.addLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  layers.push(layer);
};
/**
 * Add the given overlay to the map.
 * @param {ol.Overlay} overlay Overlay.
 * @api
 */


_ol_PluggableMap_.prototype.addOverlay = function (overlay) {
  this.getOverlays().push(overlay);
};
/**
 * This deals with map's overlay collection changes.
 * @param {ol.Overlay} overlay Overlay.
 * @private
 */


_ol_PluggableMap_.prototype.addOverlayInternal_ = function (overlay) {
  var id = overlay.getId();

  if (id !== undefined) {
    this.overlayIdIndex_[id.toString()] = overlay;
  }

  overlay.setMap(this);
};
/**
 *
 * @inheritDoc
 */


_ol_PluggableMap_.prototype.disposeInternal = function () {
  this.mapBrowserEventHandler_.dispose();

  _events2.default.unlisten(this.viewport_, _eventtype2.default.WHEEL, this.handleBrowserEvent, this);

  _events2.default.unlisten(this.viewport_, _eventtype2.default.MOUSEWHEEL, this.handleBrowserEvent, this);

  if (this.handleResize_ !== undefined) {
    window.removeEventListener(_eventtype2.default.RESIZE, this.handleResize_, false);
    this.handleResize_ = undefined;
  }

  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
    this.animationDelayKey_ = undefined;
  }

  this.setTarget(null);

  _object2.default.prototype.disposeInternal.call(this);
};
/**
 * Detect features that intersect a pixel on the viewport, and execute a
 * callback with each intersecting feature. Layers included in the detection can
 * be configured through the `layerFilter` option in `opt_options`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback. The callback will be
 *     called with two arguments. The first argument is one
 *     {@link ol.Feature feature} or
 *     {@link ol.render.Feature render feature} at the pixel, the second is
 *     the {@link ol.layer.Layer layer} of the feature and will be null for
 *     unmanaged layers. To stop detection, callback functions can return a
 *     truthy value.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T
 * @api
 */


_ol_PluggableMap_.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
  if (!this.frameState_) {
    return;
  }

  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions2.default.TRUE;
  return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);
};
/**
 * Get all features that intersect a pixel on the viewport.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {Array.<ol.Feature|ol.render.Feature>} The detected features or
 * `null` if none were found.
 * @api
 */


_ol_PluggableMap_.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
  var features = null;
  this.forEachFeatureAtPixel(pixel, function (feature) {
    if (!features) {
      features = [];
    }

    features.push(feature);
  }, opt_options);
  return features;
};
/**
 * Detect layers that have a color value at a pixel on the viewport, and
 * execute a callback with each matching layer. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback
 *     Layer callback. This callback will receive two arguments: first is the
 *     {@link ol.layer.Layer layer}, second argument is an array representing
 *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
 *     that do not currently support this argument. To stop detection, callback
 *     functions can return a truthy value.
 * @param {S=} opt_this Value to use as `this` when executing `callback`.
 * @param {(function(this: U, ol.layer.Layer): boolean)=} opt_layerFilter Layer
 *     filter function. The filter function will receive one argument, the
 *     {@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * @param {U=} opt_this2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T,U
 * @api
 */


_ol_PluggableMap_.prototype.forEachLayerAtPixel = function (pixel, callback, opt_this, opt_layerFilter, opt_this2) {
  if (!this.frameState_) {
    return;
  }

  var thisArg = opt_this !== undefined ? opt_this : null;
  var layerFilter = opt_layerFilter !== undefined ? opt_layerFilter : _functions2.default.TRUE;
  var thisArg2 = opt_this2 !== undefined ? opt_this2 : null;
  return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, callback, thisArg, layerFilter, thisArg2);
};
/**
 * Detect if features intersect a pixel on the viewport. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {boolean} Is there a feature at the given pixel?
 * @template U
 * @api
 */


_ol_PluggableMap_.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
  if (!this.frameState_) {
    return false;
  }

  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions2.default.TRUE;
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);
};
/**
 * Returns the coordinate in view projection for a browser event.
 * @param {Event} event Event.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_PluggableMap_.prototype.getEventCoordinate = function (event) {
  return this.getCoordinateFromPixel(this.getEventPixel(event));
};
/**
 * Returns the map pixel position for a browser event relative to the viewport.
 * @param {Event} event Event.
 * @return {ol.Pixel} Pixel.
 * @api
 */


_ol_PluggableMap_.prototype.getEventPixel = function (event) {
  var viewportPosition = this.viewport_.getBoundingClientRect();
  var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
  return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
};
/**
 * Get the target in which this map is rendered.
 * Note that this returns what is entered as an option or in setTarget:
 * if that was an element, it returns an element; if a string, it returns that.
 * @return {Element|string|undefined} The Element or id of the Element that the
 *     map is rendered in.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getTarget = function () {
  return (
    /** @type {Element|string|undefined} */
    this.get(_mapproperty2.default.TARGET)
  );
};
/**
 * Get the DOM element into which this map is rendered. In contrast to
 * `getTarget` this method always return an `Element`, or `null` if the
 * map has no target.
 * @return {Element} The element that the map is rendered in.
 * @api
 */


_ol_PluggableMap_.prototype.getTargetElement = function () {
  var target = this.getTarget();

  if (target !== undefined) {
    return typeof target === 'string' ? document.getElementById(target) : target;
  } else {
    return null;
  }
};
/**
 * Get the coordinate for a given pixel.  This returns a coordinate in the
 * map view projection.
 * @param {ol.Pixel} pixel Pixel position in the map viewport.
 * @return {ol.Coordinate} The coordinate for the pixel position.
 * @api
 */


_ol_PluggableMap_.prototype.getCoordinateFromPixel = function (pixel) {
  var frameState = this.frameState_;

  if (!frameState) {
    return null;
  } else {
    return _transform2.default.apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
};
/**
 * Get the map controls. Modifying this collection changes the controls
 * associated with the map.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */


_ol_PluggableMap_.prototype.getControls = function () {
  return this.controls;
};
/**
 * Get the map overlays. Modifying this collection changes the overlays
 * associated with the map.
 * @return {ol.Collection.<ol.Overlay>} Overlays.
 * @api
 */


_ol_PluggableMap_.prototype.getOverlays = function () {
  return this.overlays_;
};
/**
 * Get an overlay by its identifier (the value returned by overlay.getId()).
 * Note that the index treats string and numeric identifiers as the same. So
 * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
 * @param {string|number} id Overlay identifier.
 * @return {ol.Overlay} Overlay.
 * @api
 */


_ol_PluggableMap_.prototype.getOverlayById = function (id) {
  var overlay = this.overlayIdIndex_[id.toString()];
  return overlay !== undefined ? overlay : null;
};
/**
 * Get the map interactions. Modifying this collection changes the interactions
 * associated with the map.
 *
 * Interactions are used for e.g. pan, zoom and rotate.
 * @return {ol.Collection.<ol.interaction.Interaction>} Interactions.
 * @api
 */


_ol_PluggableMap_.prototype.getInteractions = function () {
  return this.interactions;
};
/**
 * Get the layergroup associated with this map.
 * @return {ol.layer.Group} A layer group containing the layers in this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getLayerGroup = function () {
  return (
    /** @type {ol.layer.Group} */
    this.get(_mapproperty2.default.LAYERGROUP)
  );
};
/**
 * Get the collection of layers associated with this map.
 * @return {!ol.Collection.<ol.layer.Base>} Layers.
 * @api
 */


_ol_PluggableMap_.prototype.getLayers = function () {
  var layers = this.getLayerGroup().getLayers();
  return layers;
};
/**
 * Get the pixel for a coordinate.  This takes a coordinate in the map view
 * projection and returns the corresponding pixel.
 * @param {ol.Coordinate} coordinate A map coordinate.
 * @return {ol.Pixel} A pixel position in the map viewport.
 * @api
 */


_ol_PluggableMap_.prototype.getPixelFromCoordinate = function (coordinate) {
  var frameState = this.frameState_;

  if (!frameState) {
    return null;
  } else {
    return _transform2.default.apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
  }
};
/**
 * Get the map renderer.
 * @return {ol.renderer.Map} Renderer
 */


_ol_PluggableMap_.prototype.getRenderer = function () {
  return this.renderer_;
};
/**
 * Get the size of this map.
 * @return {ol.Size|undefined} The size in pixels of the map in the DOM.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getSize = function () {
  return (
    /** @type {ol.Size|undefined} */
    this.get(_mapproperty2.default.SIZE)
  );
};
/**
 * Get the view associated with this map. A view manages properties such as
 * center and resolution.
 * @return {ol.View} The view that controls this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.getView = function () {
  return (
    /** @type {ol.View} */
    this.get(_mapproperty2.default.VIEW)
  );
};
/**
 * Get the element that serves as the map viewport.
 * @return {Element} Viewport.
 * @api
 */


_ol_PluggableMap_.prototype.getViewport = function () {
  return this.viewport_;
};
/**
 * Get the element that serves as the container for overlays.  Elements added to
 * this container will let mousedown and touchstart events through to the map,
 * so clicks and gestures on an overlay will trigger {@link ol.MapBrowserEvent}
 * events.
 * @return {!Element} The map's overlay container.
 */


_ol_PluggableMap_.prototype.getOverlayContainer = function () {
  return this.overlayContainer_;
};
/**
 * Get the element that serves as a container for overlays that don't allow
 * event propagation. Elements added to this container won't let mousedown and
 * touchstart events through to the map, so clicks and gestures on an overlay
 * don't trigger any {@link ol.MapBrowserEvent}.
 * @return {!Element} The map's overlay container that stops events.
 */


_ol_PluggableMap_.prototype.getOverlayContainerStopEvent = function () {
  return this.overlayContainerStopEvent_;
};
/**
 * @param {ol.Tile} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {ol.Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */


_ol_PluggableMap_.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  var frameState = this.frameState_;

  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _priorityqueue2.default.DROP;
  }

  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _priorityqueue2.default.DROP;
  } // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels
  // between the center of the tile and the focus.  The factor of 65536 means
  // that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.


  var deltaX = tileCenter[0] - frameState.focus[0];
  var deltaY = tileCenter[1] - frameState.focus[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
};
/**
 * @param {Event} browserEvent Browser event.
 * @param {string=} opt_type Type.
 */


_ol_PluggableMap_.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
  var type = opt_type || browserEvent.type;
  var mapBrowserEvent = new _mapbrowserevent2.default(type, this, browserEvent);
  this.handleMapBrowserEvent(mapBrowserEvent);
};
/**
 * @param {ol.MapBrowserEvent} mapBrowserEvent The event to handle.
 */


_ol_PluggableMap_.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
  if (!this.frameState_) {
    // With no view defined, we cannot translate pixels into geographical
    // coordinates so interactions cannot be used.
    return;
  }

  this.focus_ = mapBrowserEvent.coordinate;
  mapBrowserEvent.frameState = this.frameState_;
  var interactionsArray = this.getInteractions().getArray();
  var i;

  if (this.dispatchEvent(mapBrowserEvent) !== false) {
    for (i = interactionsArray.length - 1; i >= 0; i--) {
      var interaction = interactionsArray[i];

      if (!interaction.getActive()) {
        continue;
      }

      var cont = interaction.handleEvent(mapBrowserEvent);

      if (!cont) {
        break;
      }
    }
  }
};
/**
 * @protected
 */


_ol_PluggableMap_.prototype.handlePostRender = function () {
  var frameState = this.frameState_; // Manage the tile queue
  // Image loads are expensive and a limited resource, so try to use them
  // efficiently:
  // * When the view is static we allow a large number of parallel tile loads
  //   to complete the frame as quickly as possible.
  // * When animating or interacting, image loads can cause janks, so we reduce
  //   the maximum number of loads per frame and limit the number of parallel
  //   tile loads to remain reactive to view changes and to reduce the chance of
  //   loading tiles that will quickly disappear from view.

  var tileQueue = this.tileQueue_;

  if (!tileQueue.isEmpty()) {
    var maxTotalLoading = 16;
    var maxNewLoads = maxTotalLoading;

    if (frameState) {
      var hints = frameState.viewHints;

      if (hints[_viewhint2.default.ANIMATING]) {
        maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
        maxNewLoads = 2;
      }

      if (hints[_viewhint2.default.INTERACTING]) {
        maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
        maxNewLoads = 2;
      }
    }

    if (tileQueue.getTilesLoading() < maxTotalLoading) {
      tileQueue.reprioritize(); // FIXME only call if view has changed

      tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
    }
  }

  var postRenderFunctions = this.postRenderFunctions_;
  var i, ii;

  for (i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
    postRenderFunctions[i](this, frameState);
  }

  postRenderFunctions.length = 0;
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleSizeChanged_ = function () {
  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleTargetChanged_ = function () {
  // target may be undefined, null, a string or an Element.
  // If it's a string we convert it to an Element before proceeding.
  // If it's not now an Element we remove the viewport from the DOM.
  // If it's an Element we append the viewport element to it.
  var targetElement;

  if (this.getTarget()) {
    targetElement = this.getTargetElement();
  }

  if (this.keyHandlerKeys_) {
    for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
      _events2.default.unlistenByKey(this.keyHandlerKeys_[i]);
    }

    this.keyHandlerKeys_ = null;
  }

  if (!targetElement) {
    this.renderer_.removeLayerRenderers();

    _dom2.default.removeNode(this.viewport_);

    if (this.handleResize_ !== undefined) {
      window.removeEventListener(_eventtype2.default.RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
  } else {
    targetElement.appendChild(this.viewport_);
    var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
    this.keyHandlerKeys_ = [_events2.default.listen(keyboardEventTarget, _eventtype2.default.KEYDOWN, this.handleBrowserEvent, this), _events2.default.listen(keyboardEventTarget, _eventtype2.default.KEYPRESS, this.handleBrowserEvent, this)];

    if (!this.handleResize_) {
      this.handleResize_ = this.updateSize.bind(this);
      window.addEventListener(_eventtype2.default.RESIZE, this.handleResize_, false);
    }
  }

  this.updateSize(); // updateSize calls setSize, so no need to call this.render
  // ourselves here.
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleTileChange_ = function () {
  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleViewPropertyChanged_ = function () {
  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleViewChanged_ = function () {
  if (this.viewPropertyListenerKey_) {
    _events2.default.unlistenByKey(this.viewPropertyListenerKey_);

    this.viewPropertyListenerKey_ = null;
  }

  if (this.viewChangeListenerKey_) {
    _events2.default.unlistenByKey(this.viewChangeListenerKey_);

    this.viewChangeListenerKey_ = null;
  }

  var view = this.getView();

  if (view) {
    this.viewport_.setAttribute('data-view', _index2.default.getUid(view));
    this.viewPropertyListenerKey_ = _events2.default.listen(view, _objecteventtype2.default.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
    this.viewChangeListenerKey_ = _events2.default.listen(view, _eventtype2.default.CHANGE, this.handleViewPropertyChanged_, this);
  }

  this.render();
};
/**
 * @private
 */


_ol_PluggableMap_.prototype.handleLayerGroupChanged_ = function () {
  if (this.layerGroupPropertyListenerKeys_) {
    this.layerGroupPropertyListenerKeys_.forEach(_events2.default.unlistenByKey);
    this.layerGroupPropertyListenerKeys_ = null;
  }

  var layerGroup = this.getLayerGroup();

  if (layerGroup) {
    this.layerGroupPropertyListenerKeys_ = [_events2.default.listen(layerGroup, _objecteventtype2.default.PROPERTYCHANGE, this.render, this), _events2.default.listen(layerGroup, _eventtype2.default.CHANGE, this.render, this)];
  }

  this.render();
};
/**
 * @return {boolean} Is rendered.
 */


_ol_PluggableMap_.prototype.isRendered = function () {
  return !!this.frameState_;
};
/**
 * Requests an immediate render in a synchronous manner.
 * @api
 */


_ol_PluggableMap_.prototype.renderSync = function () {
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
  }

  this.animationDelay_();
};
/**
 * Request a map rendering (at the next animation frame).
 * @api
 */


_ol_PluggableMap_.prototype.render = function () {
  if (this.animationDelayKey_ === undefined) {
    this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
  }
};
/**
 * Remove the given control from the map.
 * @param {ol.control.Control} control Control.
 * @return {ol.control.Control|undefined} The removed control (or undefined
 *     if the control was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeControl = function (control) {
  return this.getControls().remove(control);
};
/**
 * Remove the given interaction from the map.
 * @param {ol.interaction.Interaction} interaction Interaction to remove.
 * @return {ol.interaction.Interaction|undefined} The removed interaction (or
 *     undefined if the interaction was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeInteraction = function (interaction) {
  return this.getInteractions().remove(interaction);
};
/**
 * Removes the given layer from the map.
 * @param {ol.layer.Base} layer Layer.
 * @return {ol.layer.Base|undefined} The removed layer (or undefined if the
 *     layer was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  return layers.remove(layer);
};
/**
 * Remove the given overlay from the map.
 * @param {ol.Overlay} overlay Overlay.
 * @return {ol.Overlay|undefined} The removed overlay (or undefined
 *     if the overlay was not found).
 * @api
 */


_ol_PluggableMap_.prototype.removeOverlay = function (overlay) {
  return this.getOverlays().remove(overlay);
};
/**
 * @param {number} time Time.
 * @private
 */


_ol_PluggableMap_.prototype.renderFrame_ = function (time) {
  var i, ii, viewState;
  var size = this.getSize();
  var view = this.getView();

  var extent = _extent2.default.createEmpty();

  var previousFrameState = this.frameState_;
  /** @type {?olx.FrameState} */

  var frameState = null;

  if (size !== undefined && _size2.default.hasArea(size) && view && view.isDef()) {
    var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    var layerStates = {};

    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerStates[_index2.default.getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
    }

    viewState = view.getState();
    var center = viewState.center;
    var pixelResolution = viewState.resolution / this.pixelRatio_;
    center[0] = Math.round(center[0] / pixelResolution) * pixelResolution;
    center[1] = Math.round(center[1] / pixelResolution) * pixelResolution;
    frameState =
    /** @type {olx.FrameState} */
    {
      animate: false,
      coordinateToPixelTransform: this.coordinateToPixelTransform_,
      extent: extent,
      focus: !this.focus_ ? center : this.focus_,
      index: this.frameIndex_++,
      layerStates: layerStates,
      layerStatesArray: layerStatesArray,
      logos: _obj2.default.assign({}, this.logos_),
      pixelRatio: this.pixelRatio_,
      pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
      postRenderFunctions: [],
      size: size,
      skippedFeatureUids: this.skippedFeatureUids_,
      tileQueue: this.tileQueue_,
      time: time,
      usedTiles: {},
      viewState: viewState,
      viewHints: viewHints,
      wantedTiles: {}
    };
  }

  if (frameState) {
    frameState.extent = _extent2.default.getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);
  }

  this.frameState_ = frameState;
  this.renderer_.renderFrame(frameState);

  if (frameState) {
    if (frameState.animate) {
      this.render();
    }

    Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

    if (previousFrameState) {
      var moveStart = !this.previousExtent_ || !_extent2.default.isEmpty(this.previousExtent_) && !_extent2.default.equals(frameState.extent, this.previousExtent_);

      if (moveStart) {
        this.dispatchEvent(new _mapevent2.default(_mapeventtype2.default.MOVESTART, this, previousFrameState));
        this.previousExtent_ = _extent2.default.createOrUpdateEmpty(this.previousExtent_);
      }
    }

    var idle = this.previousExtent_ && !frameState.viewHints[_viewhint2.default.ANIMATING] && !frameState.viewHints[_viewhint2.default.INTERACTING] && !_extent2.default.equals(frameState.extent, this.previousExtent_);

    if (idle) {
      this.dispatchEvent(new _mapevent2.default(_mapeventtype2.default.MOVEEND, this, frameState));

      _extent2.default.clone(frameState.extent, this.previousExtent_);
    }
  }

  this.dispatchEvent(new _mapevent2.default(_mapeventtype2.default.POSTRENDER, this, frameState));
  setTimeout(this.handlePostRender.bind(this), 0);
};
/**
 * Sets the layergroup of this map.
 * @param {ol.layer.Group} layerGroup A layer group containing the layers in
 *     this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setLayerGroup = function (layerGroup) {
  this.set(_mapproperty2.default.LAYERGROUP, layerGroup);
};
/**
 * Set the size of this map.
 * @param {ol.Size|undefined} size The size in pixels of the map in the DOM.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setSize = function (size) {
  this.set(_mapproperty2.default.SIZE, size);
};
/**
 * Set the target element to render this map into.
 * @param {Element|string|undefined} target The Element or id of the Element
 *     that the map is rendered in.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setTarget = function (target) {
  this.set(_mapproperty2.default.TARGET, target);
};
/**
 * Set the view for this map.
 * @param {ol.View} view The view that controls this map.
 * @observable
 * @api
 */


_ol_PluggableMap_.prototype.setView = function (view) {
  this.set(_mapproperty2.default.VIEW, view);
};
/**
 * @param {ol.Feature} feature Feature.
 */


_ol_PluggableMap_.prototype.skipFeature = function (feature) {
  var featureUid = _index2.default.getUid(feature).toString();

  this.skippedFeatureUids_[featureUid] = true;
  this.render();
};
/**
 * Force a recalculation of the map viewport size.  This should be called when
 * third-party code changes the size of the map viewport.
 * @api
 */


_ol_PluggableMap_.prototype.updateSize = function () {
  var targetElement = this.getTargetElement();

  if (!targetElement) {
    this.setSize(undefined);
  } else {
    var computedStyle = getComputedStyle(targetElement);
    this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);
  }
};
/**
 * @param {ol.Feature} feature Feature.
 */


_ol_PluggableMap_.prototype.unskipFeature = function (feature) {
  var featureUid = _index2.default.getUid(feature).toString();

  delete this.skippedFeatureUids_[featureUid];
  this.render();
};
/**
 * @type {Array.<ol.renderer.Type>}
 * @const
 */


_ol_PluggableMap_.DEFAULT_RENDERER_TYPES = [_type2.default.CANVAS, _type2.default.WEBGL];
/**
 * @const
 * @type {string}
 */

_ol_PluggableMap_.LOGO_URL = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBI' + 'WXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAA' + 'AhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszW' + 'WMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvY' + 'asvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvX' + 'H1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1Vk' + 'bMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW' + '2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLP' + 'VcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqT' + 'acrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaar' + 'ldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+Hi' + 'zeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDn' + 'BAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSF' + 'hYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJ' + 'REFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxC' + 'Brb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe' + '0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8' + 'a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7a' + 'hgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCn' + 'B3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDg' + 'q82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC';
/**
 * @param {olx.MapOptions} options Map options.
 * @return {ol.MapOptionsInternal} Internal map options.
 */

_ol_PluggableMap_.createOptionsInternal = function (options) {
  /**
   * @type {Element|Document}
   */
  var keyboardEventTarget = null;

  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  /**
   * @type {Object.<string, *>}
   */


  var values = {};
  var logos = {};

  if (options.logo === undefined || typeof options.logo === 'boolean' && options.logo) {
    logos[_ol_PluggableMap_.LOGO_URL] = 'https://openlayers.org/';
  } else {
    var logo = options.logo;

    if (typeof logo === 'string') {
      logos[logo] = '';
    } else if (logo instanceof HTMLElement) {
      logos[_index2.default.getUid(logo).toString()] = logo;
    } else if (logo) {
      _asserts2.default.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.


      _asserts2.default.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.


      logos[logo.src] = logo.href;
    }
  }

  var layerGroup = options.layers instanceof _group2.default ? options.layers : new _group2.default({
    layers: options.layers
  });
  values[_mapproperty2.default.LAYERGROUP] = layerGroup;
  values[_mapproperty2.default.TARGET] = options.target;
  values[_mapproperty2.default.VIEW] = options.view !== undefined ? options.view : new _view2.default();
  /**
   * @type {Array.<ol.renderer.Type>}
   */

  var rendererTypes;

  if (options.renderer !== undefined) {
    if (Array.isArray(options.renderer)) {
      rendererTypes = options.renderer;
    } else if (typeof options.renderer === 'string') {
      rendererTypes = [options.renderer];
    } else {
      _asserts2.default.assert(false, 46); // Incorrect format for `renderer` option

    }

    if (rendererTypes.indexOf(
    /** @type {ol.renderer.Type} */
    'dom') >= 0) {
      rendererTypes = rendererTypes.concat(_ol_PluggableMap_.DEFAULT_RENDERER_TYPES);
    }
  } else {
    rendererTypes = _ol_PluggableMap_.DEFAULT_RENDERER_TYPES;
  }
  /**
   * @type {olx.MapRendererPlugin}
   */


  var mapRendererPlugin;

  var mapRendererPlugins = _plugins2.default.getMapRendererPlugins();

  outer: for (var i = 0, ii = rendererTypes.length; i < ii; ++i) {
    var rendererType = rendererTypes[i];

    for (var j = 0, jj = mapRendererPlugins.length; j < jj; ++j) {
      var candidate = mapRendererPlugins[j];

      if (candidate['handles'](rendererType)) {
        mapRendererPlugin = candidate;
        break outer;
      }
    }
  }

  if (!mapRendererPlugin) {
    throw new Error('Unable to create a map renderer for types: ' + rendererTypes.join(', '));
  }

  var controls;

  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _collection2.default(options.controls.slice());
    } else {
      _asserts2.default.assert(options.controls instanceof _collection2.default, 47); // Expected `controls` to be an array or an `ol.Collection`


      controls = options.controls;
    }
  }

  var interactions;

  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _collection2.default(options.interactions.slice());
    } else {
      _asserts2.default.assert(options.interactions instanceof _collection2.default, 48); // Expected `interactions` to be an array or an `ol.Collection`


      interactions = options.interactions;
    }
  }

  var overlays;

  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _collection2.default(options.overlays.slice());
    } else {
      _asserts2.default.assert(options.overlays instanceof _collection2.default, 49); // Expected `overlays` to be an array or an `ol.Collection`


      overlays = options.overlays;
    }
  } else {
    overlays = new _collection2.default();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    logos: logos,
    overlays: overlays,
    mapRendererPlugin: mapRendererPlugin,
    values: values
  };
};

exports.default = _ol_PluggableMap_;

},{"./asserts.js":32,"./collection.js":35,"./collectioneventtype.js":36,"./dom.js":47,"./events.js":49,"./events/event.js":51,"./events/eventtype.js":53,"./extent.js":55,"./functions.js":61,"./has.js":85,"./index.js":90,"./layer/group.js":107,"./mapbrowserevent.js":117,"./mapbrowsereventhandler.js":118,"./mapbrowsereventtype.js":119,"./mapevent.js":121,"./mapeventtype.js":122,"./mapproperty.js":123,"./obj.js":125,"./object.js":126,"./objecteventtype.js":127,"./plugins.js":132,"./renderer/type.js":193,"./size.js":209,"./structs/priorityqueue.js":220,"./tilequeue.js":241,"./transform.js":244,"./view.js":246,"./viewhint.js":247}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _plugintype = require("./plugintype.js");

var _plugintype2 = _interopRequireDefault(_plugintype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_plugins_ = {};
/**
 * The registry of map renderer plugins.
 * @type {Array<olx.MapRendererPlugin>}
 * @private
 */

_ol_plugins_.mapRendererPlugins_ = [];
/**
 * Get all registered map renderer plugins.
 * @return {Array<olx.MapRendererPlugin>} The registered map renderer plugins.
 */

_ol_plugins_.getMapRendererPlugins = function () {
  return _ol_plugins_.mapRendererPlugins_;
};
/**
 * The registry of layer renderer plugins.
 * @type {Array<olx.LayerRendererPlugin>}
 * @private
 */


_ol_plugins_.layerRendererPlugins_ = [];
/**
 * Get all registered layer renderer plugins.
 * @return {Array<olx.LayerRendererPlugin>} The registered layer renderer plugins.
 */

_ol_plugins_.getLayerRendererPlugins = function () {
  return _ol_plugins_.layerRendererPlugins_;
};
/**
 * Register a plugin.
 * @param {ol.PluginType} type The plugin type.
 * @param {*} plugin The plugin.
 */


_ol_plugins_.register = function (type, plugin) {
  var plugins;

  switch (type) {
    case _plugintype2.default.MAP_RENDERER:
      {
        plugins = _ol_plugins_.mapRendererPlugins_;
        plugins.push(
        /** @type {olx.MapRendererPlugin} */
        plugin);
        break;
      }

    case _plugintype2.default.LAYER_RENDERER:
      {
        plugins = _ol_plugins_.layerRendererPlugins_;
        plugins.push(
        /** @type {olx.LayerRendererPlugin} */
        plugin);
        break;
      }

    default:
      {
        throw new Error('Unsupported plugin type: ' + type);
      }
  }
};
/**
 * Register multiple plugins.
 * @param {ol.PluginType} type The plugin type.
 * @param {Array} plugins The plugins.
 */


_ol_plugins_.registerMultiple = function (type, plugins) {
  for (var i = 0, ii = plugins.length; i < ii; ++i) {
    _ol_plugins_.register(type, plugins[i]);
  }
};

exports.default = _ol_plugins_;

},{"./plugintype.js":133}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * A plugin type used when registering a plugin.  The supported plugin types are
 * 'MAP_RENDERER', and 'LAYER_RENDERER'.
 * @enum {string}
 */
var _ol_PluginType_ = {
  MAP_RENDERER: 'MAP_RENDERER',
  LAYER_RENDERER: 'LAYER_RENDERER'
};
exports.default = _ol_PluginType_;

},{}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @param {!Object.<string, function(Event)>} mapping Event
 *     mapping.
 * @constructor
 */
var _ol_pointer_EventSource_ = function (dispatcher, mapping) {
  /**
   * @type {ol.pointer.PointerEventHandler}
   */
  this.dispatcher = dispatcher;
  /**
   * @private
   * @const
   * @type {!Object.<string, function(Event)>}
   */

  this.mapping_ = mapping;
};
/**
 * List of events supported by this source.
 * @return {Array.<string>} Event names
 */


_ol_pointer_EventSource_.prototype.getEvents = function () {
  return Object.keys(this.mapping_);
};
/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */


_ol_pointer_EventSource_.prototype.getHandlerForEvent = function (eventType) {
  return this.mapping_[eventType];
};

exports.default = _ol_pointer_EventSource_;

},{}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Constants for event names.
 * @enum {string}
 */
var _ol_pointer_EventType_ = {
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
exports.default = _ol_pointer_EventType_;

},{}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _eventsource = require("../pointer/eventsource.js");

var _eventsource2 = _interopRequireDefault(_eventsource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
var _ol_pointer_MouseSource_ = function (dispatcher) {
  var mapping = {
    'mousedown': this.mousedown,
    'mousemove': this.mousemove,
    'mouseup': this.mouseup,
    'mouseover': this.mouseover,
    'mouseout': this.mouseout
  };

  _eventsource2.default.call(this, dispatcher, mapping);
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */


  this.pointerMap = dispatcher.pointerMap;
  /**
   * @const
   * @type {Array.<ol.Pixel>}
   */

  this.lastTouches = [];
};

_index2.default.inherits(_ol_pointer_MouseSource_, _eventsource2.default);
/**
 * @const
 * @type {number}
 */


_ol_pointer_MouseSource_.POINTER_ID = 1;
/**
 * @const
 * @type {string}
 */

_ol_pointer_MouseSource_.POINTER_TYPE = 'mouse';
/**
 * Radius around touchend that swallows mouse events.
 *
 * @const
 * @type {number}
 */

_ol_pointer_MouseSource_.DEDUP_DIST = 25;
/**
 * Detect if a mouse event was simulated from a touch by
 * checking if previously there was a touch event at the
 * same position.
 *
 * FIXME - Known problem with the native Android browser on
 * Samsung GT-I9100 (Android 4.1.2):
 * In case the page is scrolled, this function does not work
 * correctly when a canvas is used (WebGL or canvas renderer).
 * Mouse listeners on canvas elements (for this browser), create
 * two mouse events: One 'good' and one 'bad' one (on other browsers or
 * when a div is used, there is only one event). For the 'bad' one,
 * clientX/clientY and also pageX/pageY are wrong when the page
 * is scrolled. Because of that, this function can not detect if
 * the events were simulated from a touch event. As result, a
 * pointer event at a wrong position is dispatched, which confuses
 * the map interactions.
 * It is unclear, how one can get the correct position for the event
 * or detect that the positions are invalid.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {boolean} True, if the event was generated by a touch.
 */

_ol_pointer_MouseSource_.prototype.isEventSimulatedFromTouch_ = function (inEvent) {
  var lts = this.lastTouches;
  var x = inEvent.clientX,
      y = inEvent.clientY;

  for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
    // simulated mouse events will be swallowed near a primary touchend
    var dx = Math.abs(x - t[0]),
        dy = Math.abs(y - t[1]);

    if (dx <= _ol_pointer_MouseSource_.DEDUP_DIST && dy <= _ol_pointer_MouseSource_.DEDUP_DIST) {
      return true;
    }
  }

  return false;
};
/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @return {Object} The copied event.
 */


_ol_pointer_MouseSource_.prepareEvent = function (inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent); // forward mouse preventDefault

  var pd = e.preventDefault;

  e.preventDefault = function () {
    inEvent.preventDefault();
    pd();
  };

  e.pointerId = _ol_pointer_MouseSource_.POINTER_ID;
  e.isPrimary = true;
  e.pointerType = _ol_pointer_MouseSource_.POINTER_TYPE;
  return e;
};
/**
 * Handler for `mousedown`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mousedown = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    // TODO(dfreedman) workaround for some elements not sending mouseup
    // http://crbug/149091
    if (_ol_pointer_MouseSource_.POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }

    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
};
/**
 * Handler for `mousemove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mousemove = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.dispatcher.move(e, inEvent);
  }
};
/**
 * Handler for `mouseup`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mouseup = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];

    if (p && p.button === inEvent.button) {
      var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
};
/**
 * Handler for `mouseover`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mouseover = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.dispatcher.enterOver(e, inEvent);
  }
};
/**
 * Handler for `mouseout`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.mouseout = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

    this.dispatcher.leaveOut(e, inEvent);
  }
};
/**
 * Dispatches a `pointercancel` event.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MouseSource_.prototype.cancel = function (inEvent) {
  var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);

  this.dispatcher.cancel(e, inEvent);
  this.cleanupMouse();
};
/**
 * Remove the mouse from the list of active pointers.
 */


_ol_pointer_MouseSource_.prototype.cleanupMouse = function () {
  delete this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];
};

exports.default = _ol_pointer_MouseSource_;

},{"../index.js":90,"../pointer/eventsource.js":134}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _eventsource = require("../pointer/eventsource.js");

var _eventsource2 = _interopRequireDefault(_eventsource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
var _ol_pointer_MsSource_ = function (dispatcher) {
  var mapping = {
    'MSPointerDown': this.msPointerDown,
    'MSPointerMove': this.msPointerMove,
    'MSPointerUp': this.msPointerUp,
    'MSPointerOut': this.msPointerOut,
    'MSPointerOver': this.msPointerOver,
    'MSPointerCancel': this.msPointerCancel,
    'MSGotPointerCapture': this.msGotPointerCapture,
    'MSLostPointerCapture': this.msLostPointerCapture
  };

  _eventsource2.default.call(this, dispatcher, mapping);
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */


  this.pointerMap = dispatcher.pointerMap;
  /**
   * @const
   * @type {Array.<string>}
   */

  this.POINTER_TYPES = ['', 'unavailable', 'touch', 'pen', 'mouse'];
};

_index2.default.inherits(_ol_pointer_MsSource_, _eventsource2.default);
/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {Object} The copied event.
 */


_ol_pointer_MsSource_.prototype.prepareEvent_ = function (inEvent) {
  var e = inEvent;

  if (typeof inEvent.pointerType === 'number') {
    e = this.dispatcher.cloneEvent(inEvent, inEvent);
    e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
  }

  return e;
};
/**
 * Remove this pointer from the list of active pointers.
 * @param {number} pointerId Pointer identifier.
 */


_ol_pointer_MsSource_.prototype.cleanup = function (pointerId) {
  delete this.pointerMap[pointerId.toString()];
};
/**
 * Handler for `msPointerDown`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerDown = function (inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
};
/**
 * Handler for `msPointerMove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerMove = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
};
/**
 * Handler for `msPointerUp`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerUp = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
};
/**
 * Handler for `msPointerOut`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerOut = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
};
/**
 * Handler for `msPointerOver`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerOver = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
};
/**
 * Handler for `msPointerCancel`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msPointerCancel = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
};
/**
 * Handler for `msLostPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msLostPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};
/**
 * Handler for `msGotPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_MsSource_.prototype.msGotPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};

exports.default = _ol_pointer_MsSource_;

},{"../index.js":90,"../pointer/eventsource.js":134}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _eventsource = require("../pointer/eventsource.js");

var _eventsource2 = _interopRequireDefault(_eventsource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
var _ol_pointer_NativeSource_ = function (dispatcher) {
  var mapping = {
    'pointerdown': this.pointerDown,
    'pointermove': this.pointerMove,
    'pointerup': this.pointerUp,
    'pointerout': this.pointerOut,
    'pointerover': this.pointerOver,
    'pointercancel': this.pointerCancel,
    'gotpointercapture': this.gotPointerCapture,
    'lostpointercapture': this.lostPointerCapture
  };

  _eventsource2.default.call(this, dispatcher, mapping);
};

_index2.default.inherits(_ol_pointer_NativeSource_, _eventsource2.default);
/**
 * Handler for `pointerdown`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerDown = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointermove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerMove = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointerup`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerUp = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointerout`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerOut = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointerover`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerOver = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `pointercancel`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.pointerCancel = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `lostpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.lostPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/**
 * Handler for `gotpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_NativeSource_.prototype.gotPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

exports.default = _ol_pointer_NativeSource_;

},{"../index.js":90,"../pointer/eventsource.js":134}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _event = require("../events/event.js");

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * A class for pointer events.
 *
 * This class is used as an abstraction for mouse events,
 * touch events and even native pointer events.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @param {string} type The type of the event to create.
 * @param {Event} originalEvent The event.
 * @param {Object.<string, ?>=} opt_eventDict An optional dictionary of
 *    initial event properties.
 */
var _ol_pointer_PointerEvent_ = function (type, originalEvent, opt_eventDict) {
  _event2.default.call(this, type);
  /**
   * @const
   * @type {Event}
   */


  this.originalEvent = originalEvent;
  var eventDict = opt_eventDict ? opt_eventDict : {};
  /**
   * @type {number}
   */

  this.buttons = this.getButtons_(eventDict);
  /**
   * @type {number}
   */

  this.pressure = this.getPressure_(eventDict, this.buttons); // MouseEvent related properties

  /**
   * @type {boolean}
   */

  this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;
  /**
   * @type {boolean}
   */

  this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;
  /**
   * @type {Object}
   */

  this.view = 'view' in eventDict ? eventDict['view'] : null;
  /**
   * @type {number}
   */

  this.detail = 'detail' in eventDict ? eventDict['detail'] : null;
  /**
   * @type {number}
   */

  this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;
  /**
   * @type {number}
   */

  this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;
  /**
   * @type {number}
   */

  this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;
  /**
   * @type {number}
   */

  this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;
  /**
   * @type {boolean}
   */

  this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;
  /**
   * @type {boolean}
   */

  this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;
  /**
   * @type {boolean}
   */

  this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;
  /**
   * @type {boolean}
   */

  this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;
  /**
   * @type {number}
   */

  this.button = 'button' in eventDict ? eventDict['button'] : 0;
  /**
   * @type {Node}
   */

  this.relatedTarget = 'relatedTarget' in eventDict ? eventDict['relatedTarget'] : null; // PointerEvent related properties

  /**
   * @const
   * @type {number}
   */

  this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;
  /**
   * @type {number}
   */

  this.width = 'width' in eventDict ? eventDict['width'] : 0;
  /**
   * @type {number}
   */

  this.height = 'height' in eventDict ? eventDict['height'] : 0;
  /**
   * @type {number}
   */

  this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;
  /**
   * @type {number}
   */

  this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;
  /**
   * @type {string}
   */

  this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';
  /**
   * @type {number}
   */

  this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;
  /**
   * @type {boolean}
   */

  this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false; // keep the semantics of preventDefault

  if (originalEvent.preventDefault) {
    this.preventDefault = function () {
      originalEvent.preventDefault();
    };
  }
};

_index2.default.inherits(_ol_pointer_PointerEvent_, _event2.default);
/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @return {number} Button indicator.
 */


_ol_pointer_PointerEvent_.prototype.getButtons_ = function (eventDict) {
  // According to the w3c spec,
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
  // MouseEvent.button == 0 can mean either no mouse button depressed, or the
  // left mouse button depressed.
  //
  // As of now, the only way to distinguish between the two states of
  // MouseEvent.button is by using the deprecated MouseEvent.which property, as
  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
  // no mouse button is held.
  //
  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
  // but initMouseEvent does not expose an argument with which to set
  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
  // of app developers.
  //
  // The only way to propagate the correct state of MouseEvent.which and
  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
  // is to call initMouseEvent with a buttonArg value of -1.
  //
  // This is fixed with DOM Level 4's use of buttons
  var buttons;

  if (eventDict.buttons || _ol_pointer_PointerEvent_.HAS_BUTTONS) {
    buttons = eventDict.buttons;
  } else {
    switch (eventDict.which) {
      case 1:
        buttons = 1;
        break;

      case 2:
        buttons = 4;
        break;

      case 3:
        buttons = 2;
        break;

      default:
        buttons = 0;
    }
  }

  return buttons;
};
/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @param {number} buttons Button indicator.
 * @return {number} The pressure.
 */


_ol_pointer_PointerEvent_.prototype.getPressure_ = function (eventDict, buttons) {
  // Spec requires that pointers without pressure specified use 0.5 for down
  // state and 0 for up state.
  var pressure = 0;

  if (eventDict.pressure) {
    pressure = eventDict.pressure;
  } else {
    pressure = buttons ? 0.5 : 0;
  }

  return pressure;
};
/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */


_ol_pointer_PointerEvent_.HAS_BUTTONS = false;
/**
 * Checks if the `buttons` property is supported.
 */

(function () {
  try {
    var ev = new MouseEvent('click', {
      buttons: 1
    });
    _ol_pointer_PointerEvent_.HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {// pass
  }
})();

exports.default = _ol_pointer_PointerEvent_;

},{"../events/event.js":51,"../index.js":90}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require("../events/eventtarget.js");

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _has = require("../has.js");

var _has2 = _interopRequireDefault(_has);

var _eventtype = require("../pointer/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _mousesource = require("../pointer/mousesource.js");

var _mousesource2 = _interopRequireDefault(_mousesource);

var _mssource = require("../pointer/mssource.js");

var _mssource2 = _interopRequireDefault(_mssource);

var _nativesource = require("../pointer/nativesource.js");

var _nativesource2 = _interopRequireDefault(_nativesource);

var _pointerevent = require("../pointer/pointerevent.js");

var _pointerevent2 = _interopRequireDefault(_pointerevent);

var _touchsource = require("../pointer/touchsource.js");

var _touchsource2 = _interopRequireDefault(_touchsource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @constructor
 * @extends {ol.events.EventTarget}
 * @param {Element|HTMLDocument} element Viewport element.
 */
var _ol_pointer_PointerEventHandler_ = function (element) {
  _eventtarget2.default.call(this);
  /**
   * @const
   * @private
   * @type {Element|HTMLDocument}
   */


  this.element_ = element;
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */

  this.pointerMap = {};
  /**
   * @type {Object.<string, function(Event)>}
   * @private
   */

  this.eventMap_ = {};
  /**
   * @type {Array.<ol.pointer.EventSource>}
   * @private
   */

  this.eventSourceList_ = [];
  this.registerSources();
};

_index2.default.inherits(_ol_pointer_PointerEventHandler_, _eventtarget2.default);
/**
 * Set up the event sources (mouse, touch and native pointers)
 * that generate pointer events.
 */


_ol_pointer_PointerEventHandler_.prototype.registerSources = function () {
  if (_has2.default.POINTER) {
    this.registerSource('native', new _nativesource2.default(this));
  } else if (_has2.default.MSPOINTER) {
    this.registerSource('ms', new _mssource2.default(this));
  } else {
    var mouseSource = new _mousesource2.default(this);
    this.registerSource('mouse', mouseSource);

    if (_has2.default.TOUCH) {
      this.registerSource('touch', new _touchsource2.default(this, mouseSource));
    }
  } // register events on the viewport element


  this.register_();
};
/**
 * Add a new event source that will generate pointer events.
 *
 * @param {string} name A name for the event source
 * @param {ol.pointer.EventSource} source The source event.
 */


_ol_pointer_PointerEventHandler_.prototype.registerSource = function (name, source) {
  var s = source;
  var newEvents = s.getEvents();

  if (newEvents) {
    newEvents.forEach(function (e) {
      var handler = s.getHandlerForEvent(e);

      if (handler) {
        this.eventMap_[e] = handler.bind(s);
      }
    }, this);
    this.eventSourceList_.push(s);
  }
};
/**
 * Set up the events for all registered event sources.
 * @private
 */


_ol_pointer_PointerEventHandler_.prototype.register_ = function () {
  var l = this.eventSourceList_.length;
  var eventSource;

  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.addEvents_(eventSource.getEvents());
  }
};
/**
 * Remove all registered events.
 * @private
 */


_ol_pointer_PointerEventHandler_.prototype.unregister_ = function () {
  var l = this.eventSourceList_.length;
  var eventSource;

  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.removeEvents_(eventSource.getEvents());
  }
};
/**
 * Calls the right handler for a new event.
 * @private
 * @param {Event} inEvent Browser event.
 */


_ol_pointer_PointerEventHandler_.prototype.eventHandler_ = function (inEvent) {
  var type = inEvent.type;
  var handler = this.eventMap_[type];

  if (handler) {
    handler(inEvent);
  }
};
/**
 * Setup listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */


_ol_pointer_PointerEventHandler_.prototype.addEvents_ = function (events) {
  events.forEach(function (eventName) {
    _events2.default.listen(this.element_, eventName, this.eventHandler_, this);
  }, this);
};
/**
 * Unregister listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */


_ol_pointer_PointerEventHandler_.prototype.removeEvents_ = function (events) {
  events.forEach(function (e) {
    _events2.default.unlisten(this.element_, e, this.eventHandler_, this);
  }, this);
};
/**
 * Returns a snapshot of inEvent, with writable properties.
 *
 * @param {Event} event Browser event.
 * @param {Event|Touch} inEvent An event that contains
 *    properties to copy.
 * @return {Object} An object containing shallow copies of
 *    `inEvent`'s properties.
 */


_ol_pointer_PointerEventHandler_.prototype.cloneEvent = function (event, inEvent) {
  var eventCopy = {},
      p;

  for (var i = 0, ii = _ol_pointer_PointerEventHandler_.CLONE_PROPS.length; i < ii; i++) {
    p = _ol_pointer_PointerEventHandler_.CLONE_PROPS[i][0];
    eventCopy[p] = event[p] || inEvent[p] || _ol_pointer_PointerEventHandler_.CLONE_PROPS[i][1];
  }

  return eventCopy;
}; // EVENTS

/**
 * Triggers a 'pointerdown' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.down = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERDOWN, data, event);
};
/**
 * Triggers a 'pointermove' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.move = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERMOVE, data, event);
};
/**
 * Triggers a 'pointerup' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.up = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERUP, data, event);
};
/**
 * Triggers a 'pointerenter' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.enter = function (data, event) {
  data.bubbles = false;
  this.fireEvent(_eventtype2.default.POINTERENTER, data, event);
};
/**
 * Triggers a 'pointerleave' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.leave = function (data, event) {
  data.bubbles = false;
  this.fireEvent(_eventtype2.default.POINTERLEAVE, data, event);
};
/**
 * Triggers a 'pointerover' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.over = function (data, event) {
  data.bubbles = true;
  this.fireEvent(_eventtype2.default.POINTEROVER, data, event);
};
/**
 * Triggers a 'pointerout' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.out = function (data, event) {
  data.bubbles = true;
  this.fireEvent(_eventtype2.default.POINTEROUT, data, event);
};
/**
 * Triggers a 'pointercancel' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.cancel = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERCANCEL, data, event);
};
/**
 * Triggers a combination of 'pointerout' and 'pointerleave' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.leaveOut = function (data, event) {
  this.out(data, event);

  if (!this.contains_(data.target, data.relatedTarget)) {
    this.leave(data, event);
  }
};
/**
 * Triggers a combination of 'pointerover' and 'pointerevents' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.enterOver = function (data, event) {
  this.over(data, event);

  if (!this.contains_(data.target, data.relatedTarget)) {
    this.enter(data, event);
  }
};
/**
 * @private
 * @param {Element} container The container element.
 * @param {Element} contained The contained element.
 * @return {boolean} Returns true if the container element
 *   contains the other element.
 */


_ol_pointer_PointerEventHandler_.prototype.contains_ = function (container, contained) {
  if (!container || !contained) {
    return false;
  }

  return container.contains(contained);
}; // EVENT CREATION AND TRACKING

/**
 * Creates a new Event of type `inType`, based on the information in
 * `data`.
 *
 * @param {string} inType A string representing the type of event to create.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} A PointerEvent of type `inType`.
 */


_ol_pointer_PointerEventHandler_.prototype.makeEvent = function (inType, data, event) {
  return new _pointerevent2.default(inType, event, data);
};
/**
 * Make and dispatch an event in one call.
 * @param {string} inType A string representing the type of event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */


_ol_pointer_PointerEventHandler_.prototype.fireEvent = function (inType, data, event) {
  var e = this.makeEvent(inType, data, event);
  this.dispatchEvent(e);
};
/**
 * Creates a pointer event from a native pointer event
 * and dispatches this event.
 * @param {Event} event A platform event with a target.
 */


_ol_pointer_PointerEventHandler_.prototype.fireNativeEvent = function (event) {
  var e = this.makeEvent(event.type, event, event);
  this.dispatchEvent(e);
};
/**
 * Wrap a native mouse event into a pointer event.
 * This proxy method is required for the legacy IE support.
 * @param {string} eventType The pointer event type.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} The wrapped event.
 */


_ol_pointer_PointerEventHandler_.prototype.wrapMouseEvent = function (eventType, event) {
  var pointerEvent = this.makeEvent(eventType, _mousesource2.default.prepareEvent(event, this), event);
  return pointerEvent;
};
/**
 * @inheritDoc
 */


_ol_pointer_PointerEventHandler_.prototype.disposeInternal = function () {
  this.unregister_();

  _eventtarget2.default.prototype.disposeInternal.call(this);
};
/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array.<Array>}
 */


_ol_pointer_PointerEventHandler_.CLONE_PROPS = [// MouseEvent
['bubbles', false], ['cancelable', false], ['view', null], ['detail', null], ['screenX', 0], ['screenY', 0], ['clientX', 0], ['clientY', 0], ['ctrlKey', false], ['altKey', false], ['shiftKey', false], ['metaKey', false], ['button', 0], ['relatedTarget', null], // DOM Level 3
['buttons', 0], // PointerEvent
['pointerId', 0], ['width', 0], ['height', 0], ['pressure', 0], ['tiltX', 0], ['tiltY', 0], ['pointerType', ''], ['hwTimestamp', 0], ['isPrimary', false], // event instance
['type', ''], ['target', null], ['currentTarget', null], ['which', 0]];
exports.default = _ol_pointer_PointerEventHandler_;

},{"../events.js":49,"../events/eventtarget.js":52,"../has.js":85,"../index.js":90,"../pointer/eventtype.js":135,"../pointer/mousesource.js":136,"../pointer/mssource.js":137,"../pointer/nativesource.js":138,"../pointer/pointerevent.js":139,"../pointer/touchsource.js":141}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../array.js");

var _array2 = _interopRequireDefault(_array);

var _eventsource = require("../pointer/eventsource.js");

var _eventsource2 = _interopRequireDefault(_eventsource);

var _mousesource = require("../pointer/mousesource.js");

var _mousesource2 = _interopRequireDefault(_mousesource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Based on https://github.com/Polymer/PointerEvents
// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @constructor
 * @param {ol.pointer.PointerEventHandler} dispatcher The event handler.
 * @param {ol.pointer.MouseSource} mouseSource Mouse source.
 * @extends {ol.pointer.EventSource}
 */
var _ol_pointer_TouchSource_ = function (dispatcher, mouseSource) {
  var mapping = {
    'touchstart': this.touchstart,
    'touchmove': this.touchmove,
    'touchend': this.touchend,
    'touchcancel': this.touchcancel
  };

  _eventsource2.default.call(this, dispatcher, mapping);
  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */


  this.pointerMap = dispatcher.pointerMap;
  /**
   * @const
   * @type {ol.pointer.MouseSource}
   */

  this.mouseSource = mouseSource;
  /**
   * @private
   * @type {number|undefined}
   */

  this.firstTouchId_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.clickCount_ = 0;
  /**
   * @private
   * @type {number|undefined}
   */

  this.resetId_ = undefined;
};

_index2.default.inherits(_ol_pointer_TouchSource_, _eventsource2.default);
/**
 * Mouse event timeout: This should be long enough to
 * ignore compat mouse events made by touch.
 * @const
 * @type {number}
 */


_ol_pointer_TouchSource_.DEDUP_TIMEOUT = 2500;
/**
 * @const
 * @type {number}
 */

_ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT = 200;
/**
 * @const
 * @type {string}
 */

_ol_pointer_TouchSource_.POINTER_TYPE = 'touch';
/**
 * @private
 * @param {Touch} inTouch The in touch.
 * @return {boolean} True, if this is the primary touch.
 */

_ol_pointer_TouchSource_.prototype.isPrimaryTouch_ = function (inTouch) {
  return this.firstTouchId_ === inTouch.identifier;
};
/**
 * Set primary touch if there are no pointers, or the only pointer is the mouse.
 * @param {Touch} inTouch The in touch.
 * @private
 */


_ol_pointer_TouchSource_.prototype.setPrimaryTouch_ = function (inTouch) {
  var count = Object.keys(this.pointerMap).length;

  if (count === 0 || count === 1 && _mousesource2.default.POINTER_ID.toString() in this.pointerMap) {
    this.firstTouchId_ = inTouch.identifier;
    this.cancelResetClickCount_();
  }
};
/**
 * @private
 * @param {Object} inPointer The in pointer object.
 */


_ol_pointer_TouchSource_.prototype.removePrimaryPointer_ = function (inPointer) {
  if (inPointer.isPrimary) {
    this.firstTouchId_ = undefined;
    this.resetClickCount_();
  }
};
/**
 * @private
 */


_ol_pointer_TouchSource_.prototype.resetClickCount_ = function () {
  this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), _ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT);
};
/**
 * @private
 */


_ol_pointer_TouchSource_.prototype.resetClickCountHandler_ = function () {
  this.clickCount_ = 0;
  this.resetId_ = undefined;
};
/**
 * @private
 */


_ol_pointer_TouchSource_.prototype.cancelResetClickCount_ = function () {
  if (this.resetId_ !== undefined) {
    clearTimeout(this.resetId_);
  }
};
/**
 * @private
 * @param {Event} browserEvent Browser event
 * @param {Touch} inTouch Touch event
 * @return {Object} A pointer object.
 */


_ol_pointer_TouchSource_.prototype.touchToPointer_ = function (browserEvent, inTouch) {
  var e = this.dispatcher.cloneEvent(browserEvent, inTouch); // Spec specifies that pointerId 1 is reserved for Mouse.
  // Touch identifiers can start at 0.
  // Add 2 to the touch identifier for compatibility.

  e.pointerId = inTouch.identifier + 2; // TODO: check if this is necessary?
  //e.target = findTarget(e);

  e.bubbles = true;
  e.cancelable = true;
  e.detail = this.clickCount_;
  e.button = 0;
  e.buttons = 1;
  e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
  e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
  e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
  e.isPrimary = this.isPrimaryTouch_(inTouch);
  e.pointerType = _ol_pointer_TouchSource_.POINTER_TYPE; // make sure that the properties that are different for
  // each `Touch` object are not copied from the BrowserEvent object

  e.clientX = inTouch.clientX;
  e.clientY = inTouch.clientY;
  e.screenX = inTouch.screenX;
  e.screenY = inTouch.screenY;
  return e;
};
/**
 * @private
 * @param {Event} inEvent Touch event
 * @param {function(Event, Object)} inFunction In function.
 */


_ol_pointer_TouchSource_.prototype.processTouches_ = function (inEvent, inFunction) {
  var touches = Array.prototype.slice.call(inEvent.changedTouches);
  var count = touches.length;

  function preventDefault() {
    inEvent.preventDefault();
  }

  var i, pointer;

  for (i = 0; i < count; ++i) {
    pointer = this.touchToPointer_(inEvent, touches[i]); // forward touch preventDefaults

    pointer.preventDefault = preventDefault;
    inFunction.call(this, inEvent, pointer);
  }
};
/**
 * @private
 * @param {TouchList} touchList The touch list.
 * @param {number} searchId Search identifier.
 * @return {boolean} True, if the `Touch` with the given id is in the list.
 */


_ol_pointer_TouchSource_.prototype.findTouch_ = function (touchList, searchId) {
  var l = touchList.length;
  var touch;

  for (var i = 0; i < l; i++) {
    touch = touchList[i];

    if (touch.identifier === searchId) {
      return true;
    }
  }

  return false;
};
/**
 * In some instances, a touchstart can happen without a touchend. This
 * leaves the pointermap in a broken state.
 * Therefore, on every touchstart, we remove the touches that did not fire a
 * touchend event.
 * To keep state globally consistent, we fire a pointercancel for
 * this "abandoned" touch
 *
 * @private
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.vacuumTouches_ = function (inEvent) {
  var touchList = inEvent.touches; // pointerMap.getCount() should be < touchList.length here,
  // as the touchstart has not been processed yet.

  var keys = Object.keys(this.pointerMap);
  var count = keys.length;

  if (count >= touchList.length) {
    var d = [];
    var i, key, value;

    for (i = 0; i < count; ++i) {
      key = keys[i];
      value = this.pointerMap[key]; // Never remove pointerId == 1, which is mouse.
      // Touch identifiers are 2 smaller than their pointerId, which is the
      // index in pointermap.

      if (key != _mousesource2.default.POINTER_ID && !this.findTouch_(touchList, key - 2)) {
        d.push(value.out);
      }
    }

    for (i = 0; i < d.length; ++i) {
      this.cancelOut_(inEvent, d[i]);
    }
  }
};
/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.touchstart = function (inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
};
/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer object.
 */


_ol_pointer_TouchSource_.prototype.overDown_ = function (browserEvent, inPointer) {
  this.pointerMap[inPointer.pointerId] = {
    target: inPointer.target,
    out: inPointer,
    outTarget: inPointer.target
  };
  this.dispatcher.over(inPointer, browserEvent);
  this.dispatcher.enter(inPointer, browserEvent);
  this.dispatcher.down(inPointer, browserEvent);
};
/**
 * Handler for `touchmove`.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.touchmove = function (inEvent) {
  inEvent.preventDefault();
  this.processTouches_(inEvent, this.moveOverOut_);
};
/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */


_ol_pointer_TouchSource_.prototype.moveOverOut_ = function (browserEvent, inPointer) {
  var event = inPointer;
  var pointer = this.pointerMap[event.pointerId]; // a finger drifted off the screen, ignore it

  if (!pointer) {
    return;
  }

  var outEvent = pointer.out;
  var outTarget = pointer.outTarget;
  this.dispatcher.move(event, browserEvent);

  if (outEvent && outTarget !== event.target) {
    outEvent.relatedTarget = event.target;
    event.relatedTarget = outTarget; // recover from retargeting by shadow

    outEvent.target = outTarget;

    if (event.target) {
      this.dispatcher.leaveOut(outEvent, browserEvent);
      this.dispatcher.enterOver(event, browserEvent);
    } else {
      // clean up case when finger leaves the screen
      event.target = outTarget;
      event.relatedTarget = null;
      this.cancelOut_(browserEvent, event);
    }
  }

  pointer.out = event;
  pointer.outTarget = event.target;
};
/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The event.
 */


_ol_pointer_TouchSource_.prototype.touchend = function (inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
};
/**
 * @private
 * @param {Event} browserEvent An event.
 * @param {Object} inPointer The inPointer object.
 */


_ol_pointer_TouchSource_.prototype.upOut_ = function (browserEvent, inPointer) {
  this.dispatcher.up(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};
/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.touchcancel = function (inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
};
/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */


_ol_pointer_TouchSource_.prototype.cancelOut_ = function (browserEvent, inPointer) {
  this.dispatcher.cancel(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};
/**
 * @private
 * @param {Object} inPointer The inPointer object.
 */


_ol_pointer_TouchSource_.prototype.cleanUpPointer_ = function (inPointer) {
  delete this.pointerMap[inPointer.pointerId];
  this.removePrimaryPointer_(inPointer);
};
/**
 * Prevent synth mouse events from creating pointer events.
 *
 * @private
 * @param {Event} inEvent The in event.
 */


_ol_pointer_TouchSource_.prototype.dedupSynthMouse_ = function (inEvent) {
  var lts = this.mouseSource.lastTouches;
  var t = inEvent.changedTouches[0]; // only the primary finger will synth mouse events

  if (this.isPrimaryTouch_(t)) {
    // remember x/y of last touch
    var lt = [t.clientX, t.clientY];
    lts.push(lt);
    setTimeout(function () {
      // remove touch after timeout
      _array2.default.remove(lts, lt);
    }, _ol_pointer_TouchSource_.DEDUP_TIMEOUT);
  }
};

exports.default = _ol_pointer_TouchSource_;

},{"../array.js":30,"../index.js":90,"../pointer/eventsource.js":134,"../pointer/mousesource.js":136}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _sphere = require("./sphere.js");

var _sphere2 = _interopRequireDefault(_sphere);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

var _epsg = require("./proj/epsg3857.js");

var _epsg2 = _interopRequireDefault(_epsg);

var _epsg3 = require("./proj/epsg4326.js");

var _epsg4 = _interopRequireDefault(_epsg3);

var _projection = require("./proj/projection.js");

var _projection2 = _interopRequireDefault(_projection);

var _units = require("./proj/units.js");

var _units2 = _interopRequireDefault(_units);

var _proj = require("./proj/proj4.js");

var _proj2 = _interopRequireDefault(_proj);

var _projections = require("./proj/projections.js");

var _projections2 = _interopRequireDefault(_projections);

var _transforms = require("./proj/transforms.js");

var _transforms2 = _interopRequireDefault(_transforms);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_proj_ = {};
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */

_ol_proj_.METERS_PER_UNIT = _units2.default.METERS_PER_UNIT;
/**
 * A place to store the mean radius of the Earth.
 * @private
 * @type {ol.Sphere}
 */

_ol_proj_.SPHERE_ = new _sphere2.default(_sphere2.default.DEFAULT_RADIUS);

if (_index2.default.ENABLE_PROJ4JS) {
  /**
   * Register proj4. If not explicitly registered, it will be assumed that
   * proj4js will be loaded in the global namespace. For example in a
   * browserify ES6 environment you could use:
   *
   *     import ol from 'openlayers';
   *     import proj4 from 'proj4';
   *     ol.proj.setProj4(proj4);
   *
   * @param {Proj4} proj4 Proj4.
   * @api
   */
  _ol_proj_.setProj4 = function (proj4) {
    _proj2.default.set(proj4);
  };
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link ol.proj.Projection} constructor or by using
 * {@link ol.proj.Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ol.ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {ol.Coordinate} point Point to find adjusted resolution at.
 * @param {ol.proj.Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */


_ol_proj_.getPointResolution = function (projection, resolution, point, opt_units) {
  projection = _ol_proj_.get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();

  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();

    if (units == _units2.default.DEGREES && !opt_units || opt_units == _units2.default.DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));

      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = toEPSG4326(vertices, vertices, 2);

      var width = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(0, 2), vertices.slice(2, 4));

      var height = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(4, 6), vertices.slice(6, 8));

      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ? _units2.default.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();

      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }

  return pointResolution;
};
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<ol.proj.Projection>} projections Projections.
 * @api
 */


_ol_proj_.addEquivalentProjections = function (projections) {
  _ol_proj_.addProjections(projections);

  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        _transforms2.default.add(source, destination, _ol_proj_.cloneTransform);
      }
    });
  });
};
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<ol.proj.Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<ol.proj.Projection>} projections2 Projections with equal
 *     meaning.
 * @param {ol.TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {ol.TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */


_ol_proj_.addEquivalentTransforms = function (projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      _transforms2.default.add(projection1, projection2, forwardTransform);

      _transforms2.default.add(projection2, projection1, inverseTransform);
    });
  });
};
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {ol.proj.Projection} projection Projection instance.
 * @api
 */


_ol_proj_.addProjection = function (projection) {
  _projections2.default.add(projection.getCode(), projection);

  _transforms2.default.add(projection, projection, _ol_proj_.cloneTransform);
};
/**
 * @param {Array.<ol.proj.Projection>} projections Projections.
 */


_ol_proj_.addProjections = function (projections) {
  projections.forEach(_ol_proj_.addProjection);
};
/**
 * Clear all cached projections and transforms.
 */


_ol_proj_.clearAllProjections = function () {
  _projections2.default.clear();

  _transforms2.default.clear();
};
/**
 * @param {ol.proj.Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {ol.proj.Projection} Projection.
 */


_ol_proj_.createProjection = function (projection, defaultCode) {
  if (!projection) {
    return _ol_proj_.get(defaultCode);
  } else if (typeof projection === 'string') {
    return _ol_proj_.get(projection);
  } else {
    return (
      /** @type {ol.proj.Projection} */
      projection
    );
  }
};
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ol.ProjectionLike} source Source projection.
 * @param {ol.ProjectionLike} destination Destination projection.
 * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @api
 */


_ol_proj_.addCoordinateTransforms = function (source, destination, forward, inverse) {
  var sourceProj = _ol_proj_.get(source);

  var destProj = _ol_proj_.get(destination);

  _transforms2.default.add(sourceProj, destProj, _ol_proj_.createTransformFromCoordinateTransform(forward));

  _transforms2.default.add(destProj, sourceProj, _ol_proj_.createTransformFromCoordinateTransform(inverse));
};
/**
 * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate
 *     transform.
 * @return {ol.TransformFunction} Transform function.
 */


_ol_proj_.createTransformFromCoordinateTransform = function (transform) {
  return (
    /**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      var point, i, j;

      for (i = 0; i < length; i += dimension) {
        point = transform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];

        for (j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }

      return output;
    }
  );
};
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ol.ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate projected to the target projection.
 * @api
 */


_ol_proj_.fromLonLat = function (coordinate, opt_projection) {
  return _ol_proj_.transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
};
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {ol.Coordinate} coordinate Projected coordinate.
 * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */


_ol_proj_.toLonLat = function (coordinate, opt_projection) {
  var lonLat = _ol_proj_.transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');

  var lon = lonLat[0];

  if (lon < -180 || lon > 180) {
    lonLat[0] = _math2.default.modulo(lon + 180, 360) - 180;
  }

  return lonLat;
};
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ol.ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {ol.proj.Projection} Projection object, or null if not in list.
 * @api
 */


_ol_proj_.get = function (projectionLike) {
  var projection = null;

  if (projectionLike instanceof _projection2.default) {
    projection = projectionLike;
  } else if (typeof projectionLike === 'string') {
    var code = projectionLike;
    projection = _projections2.default.get(code);

    if (_index2.default.ENABLE_PROJ4JS && !projection) {
      var proj4js = _proj2.default.get();

      if (typeof proj4js == 'function' && proj4js.defs(code) !== undefined) {
        projection = new _projection2.default({
          code: code
        });

        _ol_proj_.addProjection(projection);
      }
    }
  }

  return projection;
};
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {ol.proj.Projection} projection1 Projection 1.
 * @param {ol.proj.Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */


_ol_proj_.equivalent = function (projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }

  var equalUnits = projection1.getUnits() === projection2.getUnits();

  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFn = _ol_proj_.getTransformFromProjections(projection1, projection2);

    return transformFn === _ol_proj_.cloneTransform && equalUnits;
  }
};
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ol.ProjectionLike} source Source.
 * @param {ol.ProjectionLike} destination Destination.
 * @return {ol.TransformFunction} Transform function.
 * @api
 */


_ol_proj_.getTransform = function (source, destination) {
  var sourceProjection = _ol_proj_.get(source);

  var destinationProjection = _ol_proj_.get(destination);

  return _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);
};
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {ol.proj.Projection} sourceProjection Source Projection object.
 * @param {ol.proj.Projection} destinationProjection Destination Projection
 *     object.
 * @return {ol.TransformFunction} Transform function.
 */


_ol_proj_.getTransformFromProjections = function (sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();

  var transform = _transforms2.default.get(sourceCode, destinationCode);

  if (_index2.default.ENABLE_PROJ4JS && !transform) {
    var proj4js = _proj2.default.get();

    if (typeof proj4js == 'function') {
      var sourceDef = proj4js.defs(sourceCode);
      var destinationDef = proj4js.defs(destinationCode);

      if (sourceDef !== undefined && destinationDef !== undefined) {
        if (sourceDef === destinationDef) {
          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);
        } else {
          var proj4Transform = proj4js(destinationCode, sourceCode);

          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection, proj4Transform.forward, proj4Transform.inverse);
        }

        transform = _transforms2.default.get(sourceCode, destinationCode);
      }
    }
  }

  if (!transform) {
    transform = _ol_proj_.identityTransform;
  }

  return transform;
};
/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */


_ol_proj_.identityTransform = function (input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    input = opt_output;
  }

  return input;
};
/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */


_ol_proj_.cloneTransform = function (input, opt_output, opt_dimension) {
  var output;

  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    output = opt_output;
  } else {
    output = input.slice();
  }

  return output;
};
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link ol.proj.transformExtent} for extent transformation.
 * See the transform method of {@link ol.geom.Geometry} and its subclasses for
 * geometry transforms.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */


_ol_proj_.transform = function (coordinate, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);

  return transformFn(coordinate, undefined, coordinate.length);
};
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {ol.Extent} extent The extent to transform.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Extent} The transformed extent.
 * @api
 */


_ol_proj_.transformExtent = function (extent, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);

  return _extent2.default.applyTransform(extent, transformFn);
};
/**
 * Transforms the given point to the destination projection.
 *
 * @param {ol.Coordinate} point Point.
 * @param {ol.proj.Projection} sourceProjection Source projection.
 * @param {ol.proj.Projection} destinationProjection Destination projection.
 * @return {ol.Coordinate} Point.
 */


_ol_proj_.transformWithProjections = function (point, sourceProjection, destinationProjection) {
  var transformFn = _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);

  return transformFn(point);
};
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `ol.proj.clearAllProjections()` is called (e.g. in tests).
 */


_ol_proj_.addCommon = function () {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  _ol_proj_.addEquivalentProjections(_epsg2.default.PROJECTIONS);

  _ol_proj_.addEquivalentProjections(_epsg4.default.PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.


  _ol_proj_.addEquivalentTransforms(_epsg4.default.PROJECTIONS, _epsg2.default.PROJECTIONS, _epsg2.default.fromEPSG4326, _epsg2.default.toEPSG4326);
};

_ol_proj_.addCommon();

exports.default = _ol_proj_;

},{"./extent.js":55,"./index.js":90,"./math.js":124,"./proj/epsg3857.js":143,"./proj/epsg4326.js":144,"./proj/proj4.js":145,"./proj/projection.js":146,"./proj/projections.js":147,"./proj/transforms.js":148,"./proj/units.js":149,"./sphere.js":216}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

var _projection = require("../proj/projection.js");

var _projection2 = _interopRequireDefault(_projection);

var _units = require("../proj/units.js");

var _units2 = _interopRequireDefault(_units);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_proj_EPSG3857_ = {};
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @private
 */

_ol_proj_EPSG3857_.Projection_ = function (code) {
  _projection2.default.call(this, {
    code: code,
    units: _units2.default.METERS,
    extent: _ol_proj_EPSG3857_.EXTENT,
    global: true,
    worldExtent: _ol_proj_EPSG3857_.WORLD_EXTENT,
    getPointResolution: function (resolution, point) {
      return resolution / _math2.default.cosh(point[1] / _ol_proj_EPSG3857_.RADIUS);
    }
  });
};

_index2.default.inherits(_ol_proj_EPSG3857_.Projection_, _projection2.default);
/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */


_ol_proj_EPSG3857_.RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */

_ol_proj_EPSG3857_.HALF_SIZE = Math.PI * _ol_proj_EPSG3857_.RADIUS;
/**
 * @const
 * @type {ol.Extent}
 */

_ol_proj_EPSG3857_.EXTENT = [-_ol_proj_EPSG3857_.HALF_SIZE, -_ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE];
/**
 * @const
 * @type {ol.Extent}
 */

_ol_proj_EPSG3857_.WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */

_ol_proj_EPSG3857_.PROJECTIONS = [new _ol_proj_EPSG3857_.Projection_('EPSG:3857'), new _ol_proj_EPSG3857_.Projection_('EPSG:102100'), new _ol_proj_EPSG3857_.Projection_('EPSG:102113'), new _ol_proj_EPSG3857_.Projection_('EPSG:900913'), new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG:6.18:3:3857'), new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG::3857'), new _ol_proj_EPSG3857_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#3857')];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */

_ol_proj_EPSG3857_.fromEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  var halfSize = _ol_proj_EPSG3857_.HALF_SIZE;

  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = _ol_proj_EPSG3857_.RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));

    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }

    output[i + 1] = y;
  }

  return output;
};
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */


_ol_proj_EPSG3857_.toEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / _ol_proj_EPSG3857_.HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / _ol_proj_EPSG3857_.RADIUS)) / Math.PI - 90;
  }

  return output;
};

exports.default = _ol_proj_EPSG3857_;

},{"../index.js":90,"../math.js":124,"../proj/projection.js":146,"../proj/units.js":149}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _projection = require("../proj/projection.js");

var _projection2 = _interopRequireDefault(_projection);

var _units = require("../proj/units.js");

var _units2 = _interopRequireDefault(_units);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_proj_EPSG4326_ = {};
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @param {string=} opt_axisOrientation Axis orientation.
 * @private
 */

_ol_proj_EPSG4326_.Projection_ = function (code, opt_axisOrientation) {
  _projection2.default.call(this, {
    code: code,
    units: _units2.default.DEGREES,
    extent: _ol_proj_EPSG4326_.EXTENT,
    axisOrientation: opt_axisOrientation,
    global: true,
    metersPerUnit: _ol_proj_EPSG4326_.METERS_PER_UNIT,
    worldExtent: _ol_proj_EPSG4326_.EXTENT
  });
};

_index2.default.inherits(_ol_proj_EPSG4326_.Projection_, _projection2.default);
/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */


_ol_proj_EPSG4326_.RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {ol.Extent}
 */

_ol_proj_EPSG4326_.EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */

_ol_proj_EPSG4326_.METERS_PER_UNIT = Math.PI * _ol_proj_EPSG4326_.RADIUS / 180;
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */

_ol_proj_EPSG4326_.PROJECTIONS = [new _ol_proj_EPSG4326_.Projection_('CRS:84'), new _ol_proj_EPSG4326_.Projection_('EPSG:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG::4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:1.3:CRS84'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:2:84'), new _ol_proj_EPSG4326_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:x-ogc:def:crs:EPSG:4326', 'neu')];
exports.default = _ol_proj_EPSG4326_;

},{"../index.js":90,"../proj/projection.js":146,"../proj/units.js":149}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_proj_proj4_ = {};
/**
 * @private
 * @type {Proj4}
 */

_ol_proj_proj4_.cache_ = null;
/**
 * Store the proj4 function.
 * @param {Proj4} proj4 The proj4 function.
 */

_ol_proj_proj4_.set = function (proj4) {
  _ol_proj_proj4_.cache_ = proj4;
};
/**
 * Get proj4.
 * @return {Proj4} The proj4 function set above or available globally.
 */


_ol_proj_proj4_.get = function () {
  return _ol_proj_proj4_.cache_ || window['proj4'];
};

exports.default = _ol_proj_proj4_;

},{}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _units = require("../proj/units.js");

var _units2 = _interopRequireDefault(_units);

var _proj = require("../proj/proj4.js");

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link ol.proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link ol.ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link ol.proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {@link ol.proj.setProj4}.
 *
 * @constructor
 * @param {olx.ProjectionOptions} options Projection options.
 * @struct
 * @api
 */
var _ol_proj_Projection_ = function (options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;
  /**
   * Units of projected coordinates. When set to `ol.proj.Units.TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {ol.proj.Units}
   */

  this.units_ =
  /** @type {ol.proj.Units} */
  options.units;
  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {ol.Extent}
   */

  this.extent_ = options.extent !== undefined ? options.extent : null;
  /**
   * Extent of the world in EPSG:4326. For projections with
   * `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {ol.Extent}
   */

  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
  /**
   * @private
   * @type {string}
   */

  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
  /**
   * @private
   * @type {boolean}
   */

  this.global_ = options.global !== undefined ? options.global : false;
  /**
   * @private
   * @type {boolean}
   */

  this.canWrapX_ = !!(this.global_ && this.extent_);
  /**
   * @private
   * @type {function(number, ol.Coordinate):number|undefined}
   */

  this.getPointResolutionFunc_ = options.getPointResolution;
  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */

  this.defaultTileGrid_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.metersPerUnit_ = options.metersPerUnit;
  var code = options.code;

  if (_index2.default.ENABLE_PROJ4JS) {
    var proj4js = _proj2.default.get();

    if (typeof proj4js == 'function') {
      var def = proj4js.defs(code);

      if (def !== undefined) {
        if (def.axis !== undefined && options.axisOrientation === undefined) {
          this.axisOrientation_ = def.axis;
        }

        if (options.metersPerUnit === undefined) {
          this.metersPerUnit_ = def.to_meter;
        }

        if (options.units === undefined) {
          this.units_ = def.units;
        }
      }
    }
  }
};
/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */


_ol_proj_Projection_.prototype.canWrapX = function () {
  return this.canWrapX_;
};
/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */


_ol_proj_Projection_.prototype.getCode = function () {
  return this.code_;
};
/**
 * Get the validity extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_proj_Projection_.prototype.getExtent = function () {
  return this.extent_;
};
/**
 * Get the units of this projection.
 * @return {ol.proj.Units} Units.
 * @api
 */


_ol_proj_Projection_.prototype.getUnits = function () {
  return this.units_;
};
/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */


_ol_proj_Projection_.prototype.getMetersPerUnit = function () {
  return this.metersPerUnit_ || _units2.default.METERS_PER_UNIT[this.units_];
};
/**
 * Get the world extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_proj_Projection_.prototype.getWorldExtent = function () {
  return this.worldExtent_;
};
/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *     or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *     "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */


_ol_proj_Projection_.prototype.getAxisOrientation = function () {
  return this.axisOrientation_;
};
/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */


_ol_proj_Projection_.prototype.isGlobal = function () {
  return this.global_;
};
/**
* Set if the projection is a global projection which spans the whole world
* @param {boolean} global Whether the projection is global.
* @api
*/


_ol_proj_Projection_.prototype.setGlobal = function (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};
/**
 * @return {ol.tilegrid.TileGrid} The default tile grid.
 */


_ol_proj_Projection_.prototype.getDefaultTileGrid = function () {
  return this.defaultTileGrid_;
};
/**
 * @param {ol.tilegrid.TileGrid} tileGrid The default tile grid.
 */


_ol_proj_Projection_.prototype.setDefaultTileGrid = function (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};
/**
 * Set the validity extent for this projection.
 * @param {ol.Extent} extent Extent.
 * @api
 */


_ol_proj_Projection_.prototype.setExtent = function (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};
/**
 * Set the world extent for this projection.
 * @param {ol.Extent} worldExtent World extent
 *     [minlon, minlat, maxlon, maxlat].
 * @api
 */


_ol_proj_Projection_.prototype.setWorldExtent = function (worldExtent) {
  this.worldExtent_ = worldExtent;
};
/**
 * Set the getPointResolution function (see {@link ol.proj#getPointResolution}
 * for this projection.
 * @param {function(number, ol.Coordinate):number} func Function
 * @api
 */


_ol_proj_Projection_.prototype.setGetPointResolution = function (func) {
  this.getPointResolutionFunc_ = func;
};
/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, ol.Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */


_ol_proj_Projection_.prototype.getPointResolutionFunc = function () {
  return this.getPointResolutionFunc_;
};

exports.default = _ol_proj_Projection_;

},{"../index.js":90,"../proj/proj4.js":145,"../proj/units.js":149}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_proj_projections_ = {};
/**
 * @private
 * @type {Object.<string, ol.proj.Projection>}
 */

_ol_proj_projections_.cache_ = {};
/**
 * Clear the projections cache.
 */

_ol_proj_projections_.clear = function () {
  _ol_proj_projections_.cache_ = {};
};
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {ol.proj.Projection} The projection (if cached).
 */


_ol_proj_projections_.get = function (code) {
  var projections = _ol_proj_projections_.cache_;
  return projections[code] || null;
};
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {ol.proj.Projection} projection The projection to cache.
 */


_ol_proj_projections_.add = function (code, projection) {
  var projections = _ol_proj_projections_.cache_;
  projections[code] = projection;
};

exports.default = _ol_proj_projections_;

},{}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_proj_transforms_ = {};
/**
 * @private
 * @type {Object.<string, Object.<string, ol.TransformFunction>>}
 */

_ol_proj_transforms_.cache_ = {};
/**
 * Clear the transform cache.
 */

_ol_proj_transforms_.clear = function () {
  _ol_proj_transforms_.cache_ = {};
};
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {ol.proj.Projection} source Source.
 * @param {ol.proj.Projection} destination Destination.
 * @param {ol.TransformFunction} transformFn Transform.
 */


_ol_proj_transforms_.add = function (source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;

  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }

  transforms[sourceCode][destinationCode] = transformFn;
};
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {ol.proj.Projection} source Source projection.
 * @param {ol.proj.Projection} destination Destination projection.
 * @return {ol.TransformFunction} transformFn The unregistered transform.
 */


_ol_proj_transforms_.remove = function (source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];

  if (_obj2.default.isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }

  return transform;
};
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {ol.TransformFunction|undefined} The transform function (if found).
 */


_ol_proj_transforms_.get = function (sourceCode, destinationCode) {
  var transform;
  var transforms = _ol_proj_transforms_.cache_;

  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }

  return transform;
};

exports.default = _ol_proj_transforms_;

},{"../obj.js":125}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var _ol_proj_Units_ = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */

_ol_proj_Units_.METERS_PER_UNIT = {}; // use the radius of the Normal sphere

_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES] = 2 * Math.PI * 6370997 / 360;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.FEET] = 0.3048;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.METERS] = 1;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.USFEET] = 1200 / 3937;
exports.default = _ol_proj_Units_;

},{}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _disposable = require("../disposable.js");

var _disposable2 = _interopRequireDefault(_disposable);

var _polygon = require("../geom/polygon.js");

var _polygon2 = _interopRequireDefault(_polygon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME add rotation

/**
 * @constructor
 * @extends {ol.Disposable}
 * @param {string} className CSS class name.
 */
var _ol_render_Box_ = function (className) {
  /**
   * @type {ol.geom.Polygon}
   * @private
   */
  this.geometry_ = null;
  /**
   * @type {HTMLDivElement}
   * @private
   */

  this.element_ =
  /** @type {HTMLDivElement} */
  document.createElement('div');
  this.element_.style.position = 'absolute';
  this.element_.className = 'ol-box ' + className;
  /**
   * @private
   * @type {ol.PluggableMap}
   */

  this.map_ = null;
  /**
   * @private
   * @type {ol.Pixel}
   */

  this.startPixel_ = null;
  /**
   * @private
   * @type {ol.Pixel}
   */

  this.endPixel_ = null;
};

_index2.default.inherits(_ol_render_Box_, _disposable2.default);
/**
 * @inheritDoc
 */


_ol_render_Box_.prototype.disposeInternal = function () {
  this.setMap(null);
};
/**
 * @private
 */


_ol_render_Box_.prototype.render_ = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var px = 'px';
  var style = this.element_.style;
  style.left = Math.min(startPixel[0], endPixel[0]) + px;
  style.top = Math.min(startPixel[1], endPixel[1]) + px;
  style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
  style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
};
/**
 * @param {ol.PluggableMap} map Map.
 */


_ol_render_Box_.prototype.setMap = function (map) {
  if (this.map_) {
    this.map_.getOverlayContainer().removeChild(this.element_);
    var style = this.element_.style;
    style.left = style.top = style.width = style.height = 'inherit';
  }

  this.map_ = map;

  if (this.map_) {
    this.map_.getOverlayContainer().appendChild(this.element_);
  }
};
/**
 * @param {ol.Pixel} startPixel Start pixel.
 * @param {ol.Pixel} endPixel End pixel.
 */


_ol_render_Box_.prototype.setPixels = function (startPixel, endPixel) {
  this.startPixel_ = startPixel;
  this.endPixel_ = endPixel;
  this.createOrUpdateGeometry();
  this.render_();
};
/**
 * Creates or updates the cached geometry.
 */


_ol_render_Box_.prototype.createOrUpdateGeometry = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
  var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_); // close the polygon

  coordinates[4] = coordinates[0].slice();

  if (!this.geometry_) {
    this.geometry_ = new _polygon2.default([coordinates]);
  } else {
    this.geometry_.setCoordinates([coordinates]);
  }
};
/**
 * @return {ol.geom.Polygon} Geometry.
 */


_ol_render_Box_.prototype.getGeometry = function () {
  return this.geometry_;
};

exports.default = _ol_render_Box_;

},{"../disposable.js":46,"../geom/polygon.js":83,"../index.js":90}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _css = require("../css.js");

var _css2 = _interopRequireDefault(_css);

var _dom = require("../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _lrucache = require("../structs/lrucache.js");

var _lrucache2 = _interopRequireDefault(_lrucache);

var _transform = require("../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_render_canvas_ = {};
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultFont = '10px sans-serif';
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_canvas_.defaultFillStyle = [0, 0, 0, 1];
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultLineCap = 'round';
/**
 * @const
 * @type {Array.<number>}
 */

_ol_render_canvas_.defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

_ol_render_canvas_.defaultLineDashOffset = 0;
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

_ol_render_canvas_.defaultMiterLimit = 10;
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_canvas_.defaultStrokeStyle = [0, 0, 0, 1];
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultTextAlign = 'center';
/**
 * @const
 * @type {string}
 */

_ol_render_canvas_.defaultTextBaseline = 'middle';
/**
 * @const
 * @type {Array.<number>}
 */

_ol_render_canvas_.defaultPadding = [0, 0, 0, 0];
/**
 * @const
 * @type {number}
 */

_ol_render_canvas_.defaultLineWidth = 1;
/**
 * @type {ol.structs.LRUCache.<HTMLCanvasElement>}
 */

_ol_render_canvas_.labelCache = new _lrucache2.default();
/**
 * @type {!Object.<string, number>}
 */

_ol_render_canvas_.checkedFonts_ = {};
/**
 * @type {CanvasRenderingContext2D}
 */

_ol_render_canvas_.measureContext_ = null;
/**
 * @type {!Object.<string, number>}
 */

_ol_render_canvas_.textHeights_ = {};
/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */

_ol_render_canvas_.checkFont = function () {
  var retries = 60;
  var checked = _ol_render_canvas_.checkedFonts_;
  var labelCache = _ol_render_canvas_.labelCache;
  var font = '32px monospace';
  var text = 'wmytzilWMYTZIL@#/&?$%10';
  var interval, referenceWidth;

  function isAvailable(fontFamily) {
    var context = _ol_render_canvas_.getMeasureContext();

    context.font = font;
    referenceWidth = context.measureText(text).width;
    var available = true;

    if (fontFamily != 'monospace') {
      context.font = '32px ' + fontFamily + ',monospace';
      var width = context.measureText(text).width; // If width and referenceWidth are the same, then the 'monospace'
      // fallback was used instead of the font we wanted, so the font is not
      // available.

      available = width != referenceWidth;
    }

    return available;
  }

  function check() {
    var done = true;

    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;

          _obj2.default.clear(_ol_render_canvas_.textHeights_); // Make sure that loaded fonts are picked up by Safari


          _ol_render_canvas_.measureContext_ = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }

    if (done) {
      window.clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    var fontFamilies = _css2.default.getFontFamilies(fontSpec);

    if (!fontFamilies) {
      return;
    }

    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];

      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;

        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;

          if (interval === undefined) {
            interval = window.setInterval(check, 32);
          }
        }
      }
    }
  };
}();
/**
 * @return {CanvasRenderingContext2D} Measure context.
 */


_ol_render_canvas_.getMeasureContext = function () {
  var context = _ol_render_canvas_.measureContext_;

  if (!context) {
    context = _ol_render_canvas_.measureContext_ = _dom2.default.createCanvasContext2D(1, 1);
  }

  return context;
};
/**
 * @param {string} font Font to use for measuring.
 * @return {ol.Size} Measurement.
 */


_ol_render_canvas_.measureTextHeight = function () {
  var span;
  var heights = _ol_render_canvas_.textHeights_;
  return function (font) {
    var height = heights[font];

    if (height == undefined) {
      if (!span) {
        span = document.createElement('span');
        span.textContent = 'M';
        span.style.margin = span.style.padding = '0 !important';
        span.style.position = 'absolute !important';
        span.style.left = '-99999px !important';
      }

      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }

    return height;
  };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */


_ol_render_canvas_.measureTextWidth = function (font, text) {
  var measureContext = _ol_render_canvas_.getMeasureContext();

  if (font != measureContext.font) {
    measureContext.font = font;
  }

  return measureContext.measureText(text).width;
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */


_ol_render_canvas_.rotateAtOffset = function (context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
};

_ol_render_canvas_.resetTransform_ = _transform2.default.create();
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */

_ol_render_canvas_.drawImage = function (context, transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;

  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }

  if (transform) {
    context.setTransform.apply(context, transform);
  }

  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

  if (alpha) {
    context.globalAlpha = alpha;
  }

  if (transform) {
    context.setTransform.apply(context, _ol_render_canvas_.resetTransform_);
  }
};

exports.default = _ol_render_canvas_;

},{"../css.js":45,"../dom.js":47,"../obj.js":125,"../structs/lrucache.js":219,"../transform.js":244}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _instruction = require("../canvas/instruction.js");

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require("../canvas/replay.js");

var _replay2 = _interopRequireDefault(_replay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var _ol_render_canvas_ImageReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _replay2.default.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  /**
   * @private
   * @type {ol.DeclutterGroup}
   */


  this.declutterGroup_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */

  this.hitDetectionImage_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */

  this.image_ = null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.anchorX_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.anchorY_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.height_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.opacity_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.originX_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.originY_ = undefined;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.rotateWithView_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.rotation_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.scale_ = undefined;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.snapToPixel_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.width_ = undefined;
};

_index2.default.inherits(_ol_render_canvas_ImageReplay_, _replay2.default);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} My end.
 */


_ol_render_canvas_ImageReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
  if (!this.image_) {
    return;
  }

  this.beginGeometry(pointGeometry, feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(pointGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
  if (!this.image_) {
    return;
  }

  this.beginGeometry(multiPointGeometry, feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(multiPointGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions(); // FIXME this doesn't really protect us against further calls to draw*Geometry

  this.anchorX_ = undefined;
  this.anchorY_ = undefined;
  this.hitDetectionImage_ = null;
  this.image_ = null;
  this.height_ = undefined;
  this.scale_ = undefined;
  this.opacity_ = undefined;
  this.originX_ = undefined;
  this.originY_ = undefined;
  this.rotateWithView_ = undefined;
  this.rotation_ = undefined;
  this.snapToPixel_ = undefined;
  this.width_ = undefined;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ImageReplay_.prototype.setImageStyle = function (imageStyle, declutterGroup) {
  var anchor = imageStyle.getAnchor();
  var size = imageStyle.getSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var image = imageStyle.getImage(1);
  var origin = imageStyle.getOrigin();
  this.anchorX_ = anchor[0];
  this.anchorY_ = anchor[1];
  this.declutterGroup_ =
  /** @type {ol.DeclutterGroup} */
  declutterGroup;
  this.hitDetectionImage_ = hitDetectionImage;
  this.image_ = image;
  this.height_ = size[1];
  this.opacity_ = imageStyle.getOpacity();
  this.originX_ = origin[0];
  this.originY_ = origin[1];
  this.rotateWithView_ = imageStyle.getRotateWithView();
  this.rotation_ = imageStyle.getRotation();
  this.scale_ = imageStyle.getScale();
  this.snapToPixel_ = imageStyle.getSnapToPixel();
  this.width_ = size[0];
};

exports.default = _ol_render_canvas_ImageReplay_;

},{"../../index.js":90,"../canvas/instruction.js":154,"../canvas/replay.js":157}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _colorlike = require("../../colorlike.js");

var _colorlike2 = _interopRequireDefault(_colorlike);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _geometrytype = require("../../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _simplegeometry = require("../../geom/simplegeometry.js");

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _transform = require("../../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _has = require("../../has.js");

var _has2 = _interopRequireDefault(_has);

var _vectorcontext = require("../vectorcontext.js");

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _canvas = require("../canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _transform3 = require("../../transform.js");

var _transform4 = _interopRequireDefault(_transform3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol.geom.flat.transform.transform2D?

/**
 * @classdesc
 * A concrete subclass of {@link ol.render.VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link ol.render.Event} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 *
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Extent} extent Extent.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @struct
 */
var _ol_render_canvas_Immediate_ = function (context, pixelRatio, extent, transform, viewRotation) {
  _vectorcontext2.default.call(this);
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */


  this.context_ = context;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.extent_ = extent;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.transform_ = transform;
  /**
   * @private
   * @type {number}
   */

  this.viewRotation_ = viewRotation;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.contextFillState_ = null;
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.contextStrokeState_ = null;
  /**
   * @private
   * @type {?ol.CanvasTextState}
   */

  this.contextTextState_ = null;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.fillState_ = null;
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.strokeState_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */

  this.image_ = null;
  /**
   * @private
   * @type {number}
   */

  this.imageAnchorX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageAnchorY_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageHeight_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageOpacity_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageOriginX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageOriginY_ = 0;
  /**
   * @private
   * @type {boolean}
   */

  this.imageRotateWithView_ = false;
  /**
   * @private
   * @type {number}
   */

  this.imageRotation_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.imageScale_ = 0;
  /**
   * @private
   * @type {boolean}
   */

  this.imageSnapToPixel_ = false;
  /**
   * @private
   * @type {number}
   */

  this.imageWidth_ = 0;
  /**
   * @private
   * @type {string}
   */

  this.text_ = '';
  /**
   * @private
   * @type {number}
   */

  this.textOffsetX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.textOffsetY_ = 0;
  /**
   * @private
   * @type {boolean}
   */

  this.textRotateWithView_ = false;
  /**
   * @private
   * @type {number}
   */

  this.textRotation_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.textScale_ = 0;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.textFillState_ = null;
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.textStrokeState_ = null;
  /**
   * @private
   * @type {?ol.CanvasTextState}
   */

  this.textState_ = null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.pixelCoordinates_ = [];
  /**
   * @private
   * @type {ol.Transform}
   */

  this.tmpLocalTransform_ = _transform4.default.create();
};

_index2.default.inherits(_ol_render_canvas_Immediate_, _vectorcontext2.default);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
  if (!this.image_) {
    return;
  }

  var pixelCoordinates = _transform2.default.transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);

  var context = this.context_;
  var localTransform = this.tmpLocalTransform_;
  var alpha = context.globalAlpha;

  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha * this.imageOpacity_;
  }

  var rotation = this.imageRotation_;

  if (this.imageRotateWithView_) {
    rotation += this.viewRotation_;
  }

  var i, ii;

  for (i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
    var x = pixelCoordinates[i] - this.imageAnchorX_;
    var y = pixelCoordinates[i + 1] - this.imageAnchorY_;

    if (this.imageSnapToPixel_) {
      x = Math.round(x);
      y = Math.round(y);
    }

    if (rotation !== 0 || this.imageScale_ != 1) {
      var centerX = x + this.imageAnchorX_;
      var centerY = y + this.imageAnchorY_;

      _transform4.default.compose(localTransform, centerX, centerY, this.imageScale_, this.imageScale_, rotation, -centerX, -centerY);

      context.setTransform.apply(context, localTransform);
    }

    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
  }

  if (rotation !== 0 || this.imageScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }

  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha;
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
  if (!this.textState_ || this.text_ === '') {
    return;
  }

  if (this.textFillState_) {
    this.setContextFillState_(this.textFillState_);
  }

  if (this.textStrokeState_) {
    this.setContextStrokeState_(this.textStrokeState_);
  }

  this.setContextTextState_(this.textState_);

  var pixelCoordinates = _transform2.default.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);

  var context = this.context_;
  var rotation = this.textRotation_;

  if (this.textRotateWithView_) {
    rotation += this.viewRotation_;
  }

  for (; offset < end; offset += stride) {
    var x = pixelCoordinates[offset] + this.textOffsetX_;
    var y = pixelCoordinates[offset + 1] + this.textOffsetY_;

    if (rotation !== 0 || this.textScale_ != 1) {
      var localTransform = _transform4.default.compose(this.tmpLocalTransform_, x, y, this.textScale_, this.textScale_, rotation, -x, -y);

      context.setTransform.apply(context, localTransform);
    }

    if (this.textStrokeState_) {
      context.strokeText(this.text_, x, y);
    }

    if (this.textFillState_) {
      context.fillText(this.text_, x, y);
    }
  }

  if (rotation !== 0 || this.textScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} close Close.
 * @private
 * @return {number} end End.
 */


_ol_render_canvas_Immediate_.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
  var context = this.context_;

  var pixelCoordinates = _transform2.default.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);

  context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
  var length = pixelCoordinates.length;

  if (close) {
    length -= 2;
  }

  for (var i = 2; i < length; i += 2) {
    context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
  }

  if (close) {
    context.closePath();
  }

  return end;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */


_ol_render_canvas_Immediate_.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
  }

  return offset;
};
/**
 * Render a circle geometry into the canvas.  Rendering is immediate and uses
 * the current fill and stroke styles.
 *
 * @param {ol.geom.Circle} geometry Circle geometry.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.drawCircle = function (geometry) {
  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.fillState_ || this.strokeState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }

    var pixelCoordinates = _simplegeometry2.default.transform2D(geometry, this.transform_, this.pixelCoordinates_);

    var dx = pixelCoordinates[2] - pixelCoordinates[0];
    var dy = pixelCoordinates[3] - pixelCoordinates[1];
    var radius = Math.sqrt(dx * dx + dy * dy);
    var context = this.context_;
    context.beginPath();
    context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);

    if (this.fillState_) {
      context.fill();
    }

    if (this.strokeState_) {
      context.stroke();
    }
  }

  if (this.text_ !== '') {
    this.drawText_(geometry.getCenter(), 0, 2, 2);
  }
};
/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.setStyle = function (style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};
/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.canvas.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.drawGeometry = function (geometry) {
  var type = geometry.getType();

  switch (type) {
    case _geometrytype2.default.POINT:
      this.drawPoint(
      /** @type {ol.geom.Point} */
      geometry);
      break;

    case _geometrytype2.default.LINE_STRING:
      this.drawLineString(
      /** @type {ol.geom.LineString} */
      geometry);
      break;

    case _geometrytype2.default.POLYGON:
      this.drawPolygon(
      /** @type {ol.geom.Polygon} */
      geometry);
      break;

    case _geometrytype2.default.MULTI_POINT:
      this.drawMultiPoint(
      /** @type {ol.geom.MultiPoint} */
      geometry);
      break;

    case _geometrytype2.default.MULTI_LINE_STRING:
      this.drawMultiLineString(
      /** @type {ol.geom.MultiLineString} */
      geometry);
      break;

    case _geometrytype2.default.MULTI_POLYGON:
      this.drawMultiPolygon(
      /** @type {ol.geom.MultiPolygon} */
      geometry);
      break;

    case _geometrytype2.default.GEOMETRY_COLLECTION:
      this.drawGeometryCollection(
      /** @type {ol.geom.GeometryCollection} */
      geometry);
      break;

    case _geometrytype2.default.CIRCLE:
      this.drawCircle(
      /** @type {ol.geom.Circle} */
      geometry);
      break;

    default:
  }
};
/**
 * Render a feature into the canvas.  Note that any `zIndex` on the provided
 * style will be ignored - features are rendered immediately in the order that
 * this method is called.  If you need `zIndex` support, you should be using an
 * {@link ol.layer.Vector} instead.
 *
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @override
 * @api
 */


_ol_render_canvas_Immediate_.prototype.drawFeature = function (feature, style) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry || !_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  this.setStyle(style);
  this.drawGeometry(geometry);
};
/**
 * Render a GeometryCollection to the canvas.  Rendering is immediate and
 * uses the current styles appropriate for each geometry in the collection.
 *
 * @param {ol.geom.GeometryCollection} geometry Geometry collection.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawGeometryCollection = function (geometry) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};
/**
 * Render a Point geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Point|ol.render.Feature} geometry Point geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();

  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }

  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
/**
 * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
 * uses the current style.
 *
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry MultiPoint geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawMultiPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();

  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }

  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
/**
 * Render a LineString into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.LineString|ol.render.Feature} geometry LineString geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawLineString = function (geometry) {
  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    context.beginPath();
    this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
    context.stroke();
  }

  if (this.text_ !== '') {
    var flatMidpoint = geometry.getFlatMidpoint();
    this.drawText_(flatMidpoint, 0, 2, 2);
  }
};
/**
 * Render a MultiLineString geometry into the canvas.  Rendering is immediate
 * and uses the current style.
 *
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry MultiLineString
 *     geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawMultiLineString = function (geometry) {
  var geometryExtent = geometry.getExtent();

  if (!_extent2.default.intersects(this.extent_, geometryExtent)) {
    return;
  }

  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    var offset = 0;
    var ends = geometry.getEnds();
    var stride = geometry.getStride();
    context.beginPath();
    var i, ii;

    for (i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
    }

    context.stroke();
  }

  if (this.text_ !== '') {
    var flatMidpoints = geometry.getFlatMidpoints();
    this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
  }
};
/**
 * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Polygon geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawPolygon = function (geometry) {
  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }

    var context = this.context_;
    context.beginPath();
    this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());

    if (this.fillState_) {
      context.fill();
    }

    if (this.strokeState_) {
      context.stroke();
    }
  }

  if (this.text_ !== '') {
    var flatInteriorPoint = geometry.getFlatInteriorPoint();
    this.drawText_(flatInteriorPoint, 0, 2, 2);
  }
};
/**
 * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
 * uses the current style.
 * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.drawMultiPolygon = function (geometry) {
  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }

    var context = this.context_;
    var flatCoordinates = geometry.getOrientedFlatCoordinates();
    var offset = 0;
    var endss = geometry.getEndss();
    var stride = geometry.getStride();
    var i, ii;
    context.beginPath();

    for (i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      offset = this.drawRings_(flatCoordinates, offset, ends, stride);
    }

    if (this.fillState_) {
      context.fill();
    }

    if (this.strokeState_) {
      context.stroke();
    }
  }

  if (this.text_ !== '') {
    var flatInteriorPoints = geometry.getFlatInteriorPoints();
    this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
  }
};
/**
 * @param {ol.CanvasFillState} fillState Fill state.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.setContextFillState_ = function (fillState) {
  var context = this.context_;
  var contextFillState = this.contextFillState_;

  if (!contextFillState) {
    context.fillStyle = fillState.fillStyle;
    this.contextFillState_ = {
      fillStyle: fillState.fillStyle
    };
  } else {
    if (contextFillState.fillStyle != fillState.fillStyle) {
      contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
    }
  }
};
/**
 * @param {ol.CanvasStrokeState} strokeState Stroke state.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.setContextStrokeState_ = function (strokeState) {
  var context = this.context_;
  var contextStrokeState = this.contextStrokeState_;

  if (!contextStrokeState) {
    context.lineCap = strokeState.lineCap;

    if (_has2.default.CANVAS_LINE_DASH) {
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
    }

    context.lineJoin = strokeState.lineJoin;
    context.lineWidth = strokeState.lineWidth;
    context.miterLimit = strokeState.miterLimit;
    context.strokeStyle = strokeState.strokeStyle;
    this.contextStrokeState_ = {
      lineCap: strokeState.lineCap,
      lineDash: strokeState.lineDash,
      lineDashOffset: strokeState.lineDashOffset,
      lineJoin: strokeState.lineJoin,
      lineWidth: strokeState.lineWidth,
      miterLimit: strokeState.miterLimit,
      strokeStyle: strokeState.strokeStyle
    };
  } else {
    if (contextStrokeState.lineCap != strokeState.lineCap) {
      contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;
    }

    if (_has2.default.CANVAS_LINE_DASH) {
      if (!_array2.default.equals(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
      }

      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = context.lineDashOffset = strokeState.lineDashOffset;
      }
    }

    if (contextStrokeState.lineJoin != strokeState.lineJoin) {
      contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;
    }

    if (contextStrokeState.lineWidth != strokeState.lineWidth) {
      contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
    }

    if (contextStrokeState.miterLimit != strokeState.miterLimit) {
      contextStrokeState.miterLimit = context.miterLimit = strokeState.miterLimit;
    }

    if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
      contextStrokeState.strokeStyle = context.strokeStyle = strokeState.strokeStyle;
    }
  }
};
/**
 * @param {ol.CanvasTextState} textState Text state.
 * @private
 */


_ol_render_canvas_Immediate_.prototype.setContextTextState_ = function (textState) {
  var context = this.context_;
  var contextTextState = this.contextTextState_;
  var textAlign = textState.textAlign ? textState.textAlign : _canvas2.default.defaultTextAlign;

  if (!contextTextState) {
    context.font = textState.font;
    context.textAlign = textAlign;
    context.textBaseline = textState.textBaseline;
    this.contextTextState_ = {
      font: textState.font,
      textAlign: textAlign,
      textBaseline: textState.textBaseline
    };
  } else {
    if (contextTextState.font != textState.font) {
      contextTextState.font = context.font = textState.font;
    }

    if (contextTextState.textAlign != textAlign) {
      contextTextState.textAlign = textAlign;
    }

    if (contextTextState.textBaseline != textState.textBaseline) {
      contextTextState.textBaseline = context.textBaseline = textState.textBaseline;
    }
  }
};
/**
 * Set the fill and stroke style for subsequent draw operations.  To clear
 * either fill or stroke styles, pass null for the appropriate parameter.
 *
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  if (!fillStyle) {
    this.fillState_ = null;
  } else {
    var fillStyleColor = fillStyle.getColor();
    this.fillState_ = {
      fillStyle: _colorlike2.default.asColorLike(fillStyleColor ? fillStyleColor : _canvas2.default.defaultFillStyle)
    };
  }

  if (!strokeStyle) {
    this.strokeState_ = null;
  } else {
    var strokeStyleColor = strokeStyle.getColor();
    var strokeStyleLineCap = strokeStyle.getLineCap();
    var strokeStyleLineDash = strokeStyle.getLineDash();
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    var strokeStyleWidth = strokeStyle.getWidth();
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    this.strokeState_ = {
      lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas2.default.defaultLineCap,
      lineDash: strokeStyleLineDash ? strokeStyleLineDash : _canvas2.default.defaultLineDash,
      lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset,
      lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas2.default.defaultLineJoin,
      lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas2.default.defaultLineWidth),
      miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas2.default.defaultMiterLimit,
      strokeStyle: _colorlike2.default.asColorLike(strokeStyleColor ? strokeStyleColor : _canvas2.default.defaultStrokeStyle)
    };
  }
};
/**
 * Set the image style for subsequent draw operations.  Pass null to remove
 * the image style.
 *
 * @param {ol.style.Image} imageStyle Image style.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.setImageStyle = function (imageStyle) {
  if (!imageStyle) {
    this.image_ = null;
  } else {
    var imageAnchor = imageStyle.getAnchor(); // FIXME pixel ratio

    var imageImage = imageStyle.getImage(1);
    var imageOrigin = imageStyle.getOrigin();
    var imageSize = imageStyle.getSize();
    this.imageAnchorX_ = imageAnchor[0];
    this.imageAnchorY_ = imageAnchor[1];
    this.imageHeight_ = imageSize[1];
    this.image_ = imageImage;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
    this.imageSnapToPixel_ = imageStyle.getSnapToPixel();
    this.imageWidth_ = imageSize[0];
  }
};
/**
 * Set the text style for subsequent draw operations.  Pass null to
 * remove the text style.
 *
 * @param {ol.style.Text} textStyle Text style.
 * @override
 */


_ol_render_canvas_Immediate_.prototype.setTextStyle = function (textStyle) {
  if (!textStyle) {
    this.text_ = '';
  } else {
    var textFillStyle = textStyle.getFill();

    if (!textFillStyle) {
      this.textFillState_ = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      this.textFillState_ = {
        fillStyle: _colorlike2.default.asColorLike(textFillStyleColor ? textFillStyleColor : _canvas2.default.defaultFillStyle)
      };
    }

    var textStrokeStyle = textStyle.getStroke();

    if (!textStrokeStyle) {
      this.textStrokeState_ = null;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
      var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
      var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
      var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
      var textStrokeStyleWidth = textStrokeStyle.getWidth();
      var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
      this.textStrokeState_ = {
        lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas2.default.defaultLineCap,
        lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas2.default.defaultLineDash,
        lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset,
        lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas2.default.defaultLineJoin,
        lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas2.default.defaultLineWidth,
        miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas2.default.defaultMiterLimit,
        strokeStyle: _colorlike2.default.asColorLike(textStrokeStyleColor ? textStrokeStyleColor : _canvas2.default.defaultStrokeStyle)
      };
    }

    var textFont = textStyle.getFont();
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    var textScale = textStyle.getScale();
    var textText = textStyle.getText();
    var textTextAlign = textStyle.getTextAlign();
    var textTextBaseline = textStyle.getTextBaseline();
    this.textState_ = {
      font: textFont !== undefined ? textFont : _canvas2.default.defaultFont,
      textAlign: textTextAlign !== undefined ? textTextAlign : _canvas2.default.defaultTextAlign,
      textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas2.default.defaultTextBaseline
    };
    this.text_ = textText !== undefined ? textText : '';
    this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
    this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
    this.textRotation_ = textRotation !== undefined ? textRotation : 0;
    this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);
  }
};

exports.default = _ol_render_canvas_Immediate_;

},{"../../array.js":30,"../../colorlike.js":38,"../../extent.js":55,"../../geom/flat/transform.js":77,"../../geom/geometrytype.js":80,"../../geom/simplegeometry.js":84,"../../has.js":85,"../../index.js":90,"../../transform.js":244,"../canvas.js":151,"../vectorcontext.js":165}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {number}
 */
var _ol_render_canvas_Instruction_ = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
exports.default = _ol_render_canvas_Instruction_;

},{}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _instruction = require("../canvas/instruction.js");

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require("../canvas/replay.js");

var _replay2 = _interopRequireDefault(_replay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var _ol_render_canvas_LineStringReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _replay2.default.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};

_index2.default.inherits(_ol_render_canvas_LineStringReplay_, _replay2.default);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} end.
 */


_ol_render_canvas_LineStringReplay_.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var myBegin = this.coordinates.length;
  var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  var moveToLineToInstruction = [_instruction2.default.MOVE_TO_LINE_TO, myBegin, myEnd];
  this.instructions.push(moveToLineToInstruction);
  this.hitDetectionInstructions.push(moveToLineToInstruction);
  return end;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;

  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }

  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(lineStringGeometry, feature);
  this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [_instruction2.default.BEGIN_PATH]);
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();
  this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.hitDetectionInstructions.push([_instruction2.default.STROKE]);
  this.endGeometry(lineStringGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;

  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }

  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(multiLineStringGeometry, feature);
  this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [_instruction2.default.BEGIN_PATH]);
  var ends = multiLineStringGeometry.getEnds();
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var offset = 0;
  var i, ii;

  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
  }

  this.hitDetectionInstructions.push([_instruction2.default.STROKE]);
  this.endGeometry(multiLineStringGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_LineStringReplay_.prototype.finish = function () {
  var state = this.state;

  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([_instruction2.default.STROKE]);
  }

  this.reverseHitDetectionInstructions();
  this.state = null;
};
/**
 * @inheritDoc.
 */


_ol_render_canvas_LineStringReplay_.prototype.applyStroke = function (state) {
  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([_instruction2.default.STROKE]);
    state.lastStroke = this.coordinates.length;
  }

  state.lastStroke = 0;

  _replay2.default.prototype.applyStroke.call(this, state);

  this.instructions.push([_instruction2.default.BEGIN_PATH]);
};

exports.default = _ol_render_canvas_LineStringReplay_;

},{"../../index.js":90,"../canvas/instruction.js":154,"../canvas/replay.js":157}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _color = require("../../color.js");

var _color2 = _interopRequireDefault(_color);

var _simplify = require("../../geom/flat/simplify.js");

var _simplify2 = _interopRequireDefault(_simplify);

var _canvas = require("../canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _instruction = require("../canvas/instruction.js");

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require("../canvas/replay.js");

var _replay2 = _interopRequireDefault(_replay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var _ol_render_canvas_PolygonReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _replay2.default.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};

_index2.default.inherits(_ol_render_canvas_PolygonReplay_, _replay2.default);
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */


_ol_render_canvas_PolygonReplay_.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
  var state = this.state;
  var fill = state.fillStyle !== undefined;
  var stroke = state.strokeStyle != undefined;
  var numEnds = ends.length;
  var beginPathInstruction = [_instruction2.default.BEGIN_PATH];
  this.instructions.push(beginPathInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction);

  for (var i = 0; i < numEnds; ++i) {
    var end = ends[i];
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
    var moveToLineToInstruction = [_instruction2.default.MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);

    if (stroke) {
      // Performance optimization: only call closePath() when we have a stroke.
      // Otherwise the ring is closed already (see appendFlatCoordinates above).
      var closePathInstruction = [_instruction2.default.CLOSE_PATH];
      this.instructions.push(closePathInstruction);
      this.hitDetectionInstructions.push(closePathInstruction);
    }

    offset = end;
  }

  var fillInstruction = [_instruction2.default.FILL];
  this.hitDetectionInstructions.push(fillInstruction);

  if (fill) {
    this.instructions.push(fillInstruction);
  }

  if (stroke) {
    var strokeInstruction = [_instruction2.default.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }

  return offset;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.drawCircle = function (circleGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;

  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }

  this.setFillStrokeStyles_(circleGeometry);
  this.beginGeometry(circleGeometry, feature); // always fill the circle for hit detection

  this.hitDetectionInstructions.push([_instruction2.default.SET_FILL_STYLE, _color2.default.asString(_canvas2.default.defaultFillStyle)]);

  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }

  var flatCoordinates = circleGeometry.getFlatCoordinates();
  var stride = circleGeometry.getStride();
  var myBegin = this.coordinates.length;
  this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
  var beginPathInstruction = [_instruction2.default.BEGIN_PATH];
  var circleInstruction = [_instruction2.default.CIRCLE, myBegin];
  this.instructions.push(beginPathInstruction, circleInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
  var fillInstruction = [_instruction2.default.FILL];
  this.hitDetectionInstructions.push(fillInstruction);

  if (state.fillStyle !== undefined) {
    this.instructions.push(fillInstruction);
  }

  if (state.strokeStyle !== undefined) {
    var strokeInstruction = [_instruction2.default.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }

  this.endGeometry(circleGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
  var state = this.state;
  this.setFillStrokeStyles_(polygonGeometry);
  this.beginGeometry(polygonGeometry, feature); // always fill the polygon for hit detection

  this.hitDetectionInstructions.push([_instruction2.default.SET_FILL_STYLE, _color2.default.asString(_canvas2.default.defaultFillStyle)]);

  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }

  var ends = polygonGeometry.getEnds();
  var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
  var stride = polygonGeometry.getStride();
  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
  this.endGeometry(polygonGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;

  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }

  this.setFillStrokeStyles_(multiPolygonGeometry);
  this.beginGeometry(multiPolygonGeometry, feature); // always fill the multi-polygon for hit detection

  this.hitDetectionInstructions.push([_instruction2.default.SET_FILL_STYLE, _color2.default.asString(_canvas2.default.defaultFillStyle)]);

  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }

  var endss = multiPolygonGeometry.getEndss();
  var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
  var stride = multiPolygonGeometry.getStride();
  var offset = 0;
  var i, ii;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
  }

  this.endGeometry(multiPolygonGeometry, feature);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_PolygonReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions();
  this.state = null; // We want to preserve topology when drawing polygons.  Polygons are
  // simplified using quantization and point elimination. However, we might
  // have received a mix of quantized and non-quantized geometries, so ensure
  // that all are quantized by quantizing all coordinates in the batch.

  var tolerance = this.tolerance;

  if (tolerance !== 0) {
    var coordinates = this.coordinates;
    var i, ii;

    for (i = 0, ii = coordinates.length; i < ii; ++i) {
      coordinates[i] = _simplify2.default.snap(coordinates[i], tolerance);
    }
  }
};
/**
 * @private
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */


_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyles_ = function (geometry) {
  var state = this.state;
  var fillStyle = state.fillStyle;

  if (fillStyle !== undefined) {
    this.updateFillStyle(state, this.applyFill, geometry);
  }

  if (state.strokeStyle !== undefined) {
    this.updateStrokeStyle(state, this.applyStroke);
  }
};

exports.default = _ol_render_canvas_PolygonReplay_;

},{"../../color.js":37,"../../geom/flat/simplify.js":73,"../../index.js":90,"../canvas.js":151,"../canvas/instruction.js":154,"../canvas/replay.js":157}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _colorlike = require("../../colorlike.js");

var _colorlike2 = _interopRequireDefault(_colorlike);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _relationship = require("../../extent/relationship.js");

var _relationship2 = _interopRequireDefault(_relationship);

var _geometrytype = require("../../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _inflate = require("../../geom/flat/inflate.js");

var _inflate2 = _interopRequireDefault(_inflate);

var _length = require("../../geom/flat/length.js");

var _length2 = _interopRequireDefault(_length);

var _textpath = require("../../geom/flat/textpath.js");

var _textpath2 = _interopRequireDefault(_textpath);

var _transform = require("../../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _has = require("../../has.js");

var _has2 = _interopRequireDefault(_has);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _vectorcontext = require("../vectorcontext.js");

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _canvas = require("../canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _instruction = require("../canvas/instruction.js");

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require("../replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _transform3 = require("../../transform.js");

var _transform4 = _interopRequireDefault(_transform3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var _ol_render_canvas_Replay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _vectorcontext2.default.call(this);
  /**
   * @type {?}
   */


  this.declutterTree = declutterTree;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.tmpExtent_ = _extent2.default.createEmpty();
  /**
   * @protected
   * @type {number}
   */

  this.tolerance = tolerance;
  /**
   * @protected
   * @const
   * @type {ol.Extent}
   */

  this.maxExtent = maxExtent;
  /**
   * @protected
   * @type {boolean}
   */

  this.overlaps = overlaps;
  /**
   * @protected
   * @type {number}
   */

  this.pixelRatio = pixelRatio;
  /**
   * @protected
   * @type {number}
   */

  this.maxLineWidth = 0;
  /**
   * @protected
   * @const
   * @type {number}
   */

  this.resolution = resolution;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.fillOrigin_;
  /**
   * @private
   * @type {Array.<*>}
   */

  this.beginGeometryInstruction1_ = null;
  /**
   * @private
   * @type {Array.<*>}
   */

  this.beginGeometryInstruction2_ = null;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.bufferedMaxExtent_ = null;
  /**
   * @protected
   * @type {Array.<*>}
   */

  this.instructions = [];
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.coordinates = [];
  /**
   * @private
   * @type {Object.<number,ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>>}
   */

  this.coordinateCache_ = {};
  /**
   * @private
   * @type {!ol.Transform}
   */

  this.renderedTransform_ = _transform4.default.create();
  /**
   * @protected
   * @type {Array.<*>}
   */

  this.hitDetectionInstructions = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.pixelCoordinates_ = null;
  /**
   * @protected
   * @type {ol.CanvasFillStrokeState}
   */

  this.state =
  /** @type {ol.CanvasFillStrokeState} */
  {};
  /**
   * @private
   * @type {number}
   */

  this.viewRotation_ = 0;
  /**
   * @private
   * @type {!ol.Transform}
   */

  this.tmpLocalTransform_ = _transform4.default.create();
  /**
   * @private
   * @type {!ol.Transform}
   */

  this.resetTransform_ = _transform4.default.create();
};

_index2.default.inherits(_ol_render_canvas_Replay_, _vectorcontext2.default);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Coordinate} p1 1st point of the background box.
 * @param {ol.Coordinate} p2 2nd point of the background box.
 * @param {ol.Coordinate} p3 3rd point of the background box.
 * @param {ol.Coordinate} p4 4th point of the background box.
 * @param {Array.<*>} fillInstruction Fill instruction.
 * @param {Array.<*>} strokeInstruction Stroke instruction.
 */


_ol_render_canvas_Replay_.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
  context.beginPath();
  context.moveTo.apply(context, p1);
  context.lineTo.apply(context, p2);
  context.lineTo.apply(context, p3);
  context.lineTo.apply(context, p4);
  context.lineTo.apply(context, p1);

  if (fillInstruction) {
    this.fillOrigin_ =
    /** @type {Array.<number>} */
    fillInstruction[2];
    this.fill_(context);
  }

  if (strokeInstruction) {
    this.setStrokeStyle_(context,
    /** @type {Array.<*>} */
    strokeInstruction);
    context.stroke();
  }
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} anchorX Anchor X.
 * @param {number} anchorY Anchor Y.
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 * @param {number} height Height.
 * @param {number} opacity Opacity.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} rotation Rotation.
 * @param {number} scale Scale.
 * @param {boolean} snapToPixel Snap to pixel.
 * @param {number} width Width.
 * @param {Array.<number>} padding Padding.
 * @param {Array.<*>} fillInstruction Fill instruction.
 * @param {Array.<*>} strokeInstruction Stroke instruction.
 */


_ol_render_canvas_Replay_.prototype.replayImage_ = function (context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {
  var fillStroke = fillInstruction || strokeInstruction;
  var localTransform = this.tmpLocalTransform_;
  anchorX *= scale;
  anchorY *= scale;
  x -= anchorX;
  y -= anchorY;

  if (snapToPixel) {
    x = Math.round(x);
    y = Math.round(y);
  }

  var w = width + originX > image.width ? image.width - originX : width;
  var h = height + originY > image.height ? image.height - originY : height;
  var box = this.tmpExtent_;
  var boxW = padding[3] + w * scale + padding[1];
  var boxH = padding[0] + h * scale + padding[2];
  var boxX = x - padding[3];
  var boxY = y - padding[0];
  /** @type {ol.Coordinate} */

  var p1;
  /** @type {ol.Coordinate} */

  var p2;
  /** @type {ol.Coordinate} */

  var p3;
  /** @type {ol.Coordinate} */

  var p4;

  if (fillStroke || rotation !== 0) {
    p1 = [boxX, boxY];
    p2 = [boxX + boxW, boxY];
    p3 = [boxX + boxW, boxY + boxH];
    p4 = [boxX, boxY + boxH];
  }

  var transform = null;

  if (rotation !== 0) {
    var centerX = x + anchorX;
    var centerY = y + anchorY;
    transform = _transform4.default.compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);

    _extent2.default.createOrUpdateEmpty(box);

    _extent2.default.extendCoordinate(box, _transform4.default.apply(localTransform, p1));

    _extent2.default.extendCoordinate(box, _transform4.default.apply(localTransform, p2));

    _extent2.default.extendCoordinate(box, _transform4.default.apply(localTransform, p3));

    _extent2.default.extendCoordinate(box, _transform4.default.apply(localTransform, p4));
  } else {
    _extent2.default.createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);
  }

  var canvas = context.canvas;
  var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;

  if (declutterGroup) {
    if (!intersects && declutterGroup[4] == 1) {
      return;
    }

    _extent2.default.extend(declutterGroup, box);

    var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;

    if (declutterArgs && fillStroke) {
      declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);
    }

    declutterGroup.push(declutterArgs);
  } else if (intersects) {
    if (fillStroke) {
      this.replayTextBackground_(context, p1, p2, p3, p4,
      /** @type {Array.<*>} */
      fillInstruction,
      /** @type {Array.<*>} */
      strokeInstruction);
    }

    _canvas2.default.drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
  }
};
/**
 * @protected
 * @param {Array.<number>} dashArray Dash array.
 * @return {Array.<number>} Dash array with pixel ratio applied
 */


_ol_render_canvas_Replay_.prototype.applyPixelRatio = function (dashArray) {
  var pixelRatio = this.pixelRatio;
  return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
    return dash * pixelRatio;
  });
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} closed Last input coordinate equals first.
 * @param {boolean} skipFirst Skip first coordinate.
 * @protected
 * @return {number} My end.
 */


_ol_render_canvas_Replay_.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
  var myEnd = this.coordinates.length;
  var extent = this.getBufferedMaxExtent();

  if (skipFirst) {
    offset += stride;
  }

  var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var nextCoord = [NaN, NaN];
  var skipped = true;
  var i, lastRel, nextRel;

  for (i = offset + stride; i < end; i += stride) {
    nextCoord[0] = flatCoordinates[i];
    nextCoord[1] = flatCoordinates[i + 1];
    nextRel = _extent2.default.coordinateRelationship(extent, nextCoord);

    if (nextRel !== lastRel) {
      if (skipped) {
        this.coordinates[myEnd++] = lastCoord[0];
        this.coordinates[myEnd++] = lastCoord[1];
      }

      this.coordinates[myEnd++] = nextCoord[0];
      this.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else if (nextRel === _relationship2.default.INTERSECTING) {
      this.coordinates[myEnd++] = nextCoord[0];
      this.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else {
      skipped = true;
    }

    lastCoord[0] = nextCoord[0];
    lastCoord[1] = nextCoord[1];
    lastRel = nextRel;
  } // Last coordinate equals first or only one point to append:


  if (closed && skipped || i === offset + stride) {
    this.coordinates[myEnd++] = lastCoord[0];
    this.coordinates[myEnd++] = lastCoord[1];
  }

  return myEnd;
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} replayEnds Replay ends.
 * @return {number} Offset.
 */


_ol_render_canvas_Replay_.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, replayEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
    replayEnds.push(replayEnd);
    offset = end;
  }

  return offset;
};
/**
 * @inheritDoc.
 */


_ol_render_canvas_Replay_.prototype.drawCustom = function (geometry, feature, renderer) {
  this.beginGeometry(geometry, feature);
  var type = geometry.getType();
  var stride = geometry.getStride();
  var replayBegin = this.coordinates.length;
  var flatCoordinates, replayEnd, replayEnds, replayEndss;
  var offset;

  if (type == _geometrytype2.default.MULTI_POLYGON) {
    geometry =
    /** @type {ol.geom.MultiPolygon} */
    geometry;
    flatCoordinates = geometry.getOrientedFlatCoordinates();
    replayEndss = [];
    var endss = geometry.getEndss();
    offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var myEnds = [];
      offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
      replayEndss.push(myEnds);
    }

    this.instructions.push([_instruction2.default.CUSTOM, replayBegin, replayEndss, geometry, renderer, _inflate2.default.coordinatesss]);
  } else if (type == _geometrytype2.default.POLYGON || type == _geometrytype2.default.MULTI_LINE_STRING) {
    replayEnds = [];
    flatCoordinates = type == _geometrytype2.default.POLYGON ?
    /** @type {ol.geom.Polygon} */
    geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
    offset = this.drawCustomCoordinates_(flatCoordinates, 0,
    /** @type {ol.geom.Polygon|ol.geom.MultiLineString} */
    geometry.getEnds(), stride, replayEnds);
    this.instructions.push([_instruction2.default.CUSTOM, replayBegin, replayEnds, geometry, renderer, _inflate2.default.coordinatess]);
  } else if (type == _geometrytype2.default.LINE_STRING || type == _geometrytype2.default.MULTI_POINT) {
    flatCoordinates = geometry.getFlatCoordinates();
    replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    this.instructions.push([_instruction2.default.CUSTOM, replayBegin, replayEnd, geometry, renderer, _inflate2.default.coordinates]);
  } else if (type == _geometrytype2.default.POINT) {
    flatCoordinates = geometry.getFlatCoordinates();
    this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
    replayEnd = this.coordinates.length;
    this.instructions.push([_instruction2.default.CUSTOM, replayBegin, replayEnd, geometry, renderer]);
  }

  this.endGeometry(geometry, feature);
};
/**
 * @protected
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_canvas_Replay_.prototype.beginGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_ = [_instruction2.default.BEGIN_GEOMETRY, feature, 0];
  this.instructions.push(this.beginGeometryInstruction1_);
  this.beginGeometryInstruction2_ = [_instruction2.default.BEGIN_GEOMETRY, feature, 0];
  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
};
/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 */


_ol_render_canvas_Replay_.prototype.fill_ = function (context) {
  if (this.fillOrigin_) {
    var origin = _transform4.default.apply(this.renderedTransform_, this.fillOrigin_.slice());

    context.translate(origin[0], origin[1]);
    context.rotate(this.viewRotation_);
  }

  context.fill();

  if (this.fillOrigin_) {
    context.setTransform.apply(context, _canvas2.default.resetTransform_);
  }
};
/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {Array.<*>} instruction Instruction.
 */


_ol_render_canvas_Replay_.prototype.setStrokeStyle_ = function (context, instruction) {
  context.strokeStyle =
  /** @type {ol.ColorLike} */
  instruction[1];
  context.lineWidth =
  /** @type {number} */
  instruction[2];
  context.lineCap =
  /** @type {string} */
  instruction[3];
  context.lineJoin =
  /** @type {string} */
  instruction[4];
  context.miterLimit =
  /** @type {number} */
  instruction[5];

  if (_has2.default.CANVAS_LINE_DASH) {
    context.lineDashOffset =
    /** @type {number} */
    instruction[7];
    context.setLineDash(
    /** @type {Array.<number>} */
    instruction[6]);
  }
};
/**
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_canvas_Replay_.prototype.renderDeclutter_ = function (declutterGroup, feature) {
  if (declutterGroup && declutterGroup.length > 5) {
    var groupCount = declutterGroup[4];

    if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
      /** @type {ol.RBushEntry} */
      var box = {
        minX:
        /** @type {number} */
        declutterGroup[0],
        minY:
        /** @type {number} */
        declutterGroup[1],
        maxX:
        /** @type {number} */
        declutterGroup[2],
        maxY:
        /** @type {number} */
        declutterGroup[3],
        value: feature
      };

      if (!this.declutterTree.collides(box)) {
        this.declutterTree.insert(box);
        var drawImage = _canvas2.default.drawImage;

        for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
          var declutterData =
          /** @type {Array} */
          declutterGroup[j];

          if (declutterData) {
            if (declutterData.length > 11) {
              this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);
            }

            drawImage.apply(undefined, declutterData);
          }
        }
      }

      declutterGroup.length = 5;

      _extent2.default.createOrUpdateEmpty(declutterGroup);
    }
  }
};
/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<*>} instructions Instructions array.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined}
 *     featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_canvas_Replay_.prototype.replay_ = function (context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {
  /** @type {Array.<number>} */
  var pixelCoordinates;

  if (this.pixelCoordinates_ && _array2.default.equals(transform, this.renderedTransform_)) {
    pixelCoordinates = this.pixelCoordinates_;
  } else {
    if (!this.pixelCoordinates_) {
      this.pixelCoordinates_ = [];
    }

    pixelCoordinates = _transform2.default.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);

    _transform4.default.setFromArray(this.renderedTransform_, transform);
  }

  var skipFeatures = !_obj2.default.isEmpty(skippedFeaturesHash);
  var i = 0; // instruction index

  var ii = instructions.length; // end of instructions

  var d = 0; // data index

  var dd; // end of per-instruction data

  var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
  var pendingFill = 0;
  var pendingStroke = 0;
  var lastFillInstruction = null;
  var lastStrokeInstruction = null;
  var coordinateCache = this.coordinateCache_;
  var viewRotation = this.viewRotation_;
  var state =
  /** @type {olx.render.State} */
  {
    context: context,
    pixelRatio: this.pixelRatio,
    resolution: this.resolution,
    rotation: viewRotation
  }; // When the batch size gets too big, performance decreases. 200 is a good
  // balance between batch size and number of fill/stroke instructions.

  var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;

  while (i < ii) {
    var instruction = instructions[i];
    var type =
    /** @type {ol.render.canvas.Instruction} */
    instruction[0];
    var
    /** @type {ol.Feature|ol.render.Feature} */
    feature, x, y;

    switch (type) {
      case _instruction2.default.BEGIN_GEOMETRY:
        feature =
        /** @type {ol.Feature|ol.render.Feature} */
        instruction[1];

        if (skipFeatures && skippedFeaturesHash[_index2.default.getUid(feature).toString()] || !feature.getGeometry()) {
          i =
          /** @type {number} */
          instruction[2];
        } else if (opt_hitExtent !== undefined && !_extent2.default.intersects(opt_hitExtent, feature.getGeometry().getExtent())) {
          i =
          /** @type {number} */
          instruction[2] + 1;
        } else {
          ++i;
        }

        break;

      case _instruction2.default.BEGIN_PATH:
        if (pendingFill > batchSize) {
          this.fill_(context);
          pendingFill = 0;
        }

        if (pendingStroke > batchSize) {
          context.stroke();
          pendingStroke = 0;
        }

        if (!pendingFill && !pendingStroke) {
          context.beginPath();
          prevX = prevY = NaN;
        }

        ++i;
        break;

      case _instruction2.default.CIRCLE:
        d =
        /** @type {number} */
        instruction[1];
        var x1 = pixelCoordinates[d];
        var y1 = pixelCoordinates[d + 1];
        var x2 = pixelCoordinates[d + 2];
        var y2 = pixelCoordinates[d + 3];
        var dx = x2 - x1;
        var dy = y2 - y1;
        var r = Math.sqrt(dx * dx + dy * dy);
        context.moveTo(x1 + r, y1);
        context.arc(x1, y1, r, 0, 2 * Math.PI, true);
        ++i;
        break;

      case _instruction2.default.CLOSE_PATH:
        context.closePath();
        ++i;
        break;

      case _instruction2.default.CUSTOM:
        d =
        /** @type {number} */
        instruction[1];
        dd = instruction[2];
        var geometry =
        /** @type {ol.geom.SimpleGeometry} */
        instruction[3];
        var renderer = instruction[4];
        var fn = instruction.length == 6 ? instruction[5] : undefined;
        state.geometry = geometry;
        state.feature = feature;

        if (!(i in coordinateCache)) {
          coordinateCache[i] = [];
        }

        var coords = coordinateCache[i];

        if (fn) {
          fn(pixelCoordinates, d, dd, 2, coords);
        } else {
          coords[0] = pixelCoordinates[d];
          coords[1] = pixelCoordinates[d + 1];
          coords.length = 2;
        }

        renderer(coords, state);
        ++i;
        break;

      case _instruction2.default.DRAW_IMAGE:
        d =
        /** @type {number} */
        instruction[1];
        dd =
        /** @type {number} */
        instruction[2];
        image =
        /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */
        instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order

        anchorX =
        /** @type {number} */
        instruction[4];
        anchorY =
        /** @type {number} */
        instruction[5];
        declutterGroup = featureCallback ? null :
        /** @type {ol.DeclutterGroup} */
        instruction[6];
        var height =
        /** @type {number} */
        instruction[7];
        var opacity =
        /** @type {number} */
        instruction[8];
        var originX =
        /** @type {number} */
        instruction[9];
        var originY =
        /** @type {number} */
        instruction[10];
        var rotateWithView =
        /** @type {boolean} */
        instruction[11];
        var rotation =
        /** @type {number} */
        instruction[12];
        var scale =
        /** @type {number} */
        instruction[13];
        var snapToPixel =
        /** @type {boolean} */
        instruction[14];
        var width =
        /** @type {number} */
        instruction[15];
        var padding, backgroundFill, backgroundStroke;

        if (instruction.length > 16) {
          padding =
          /** @type {Array.<number>} */
          instruction[16];
          backgroundFill =
          /** @type {boolean} */
          instruction[17];
          backgroundStroke =
          /** @type {boolean} */
          instruction[18];
        } else {
          padding = _canvas2.default.defaultPadding;
          backgroundFill = backgroundStroke = false;
        }

        if (rotateWithView) {
          rotation += viewRotation;
        }

        for (; d < dd; d += 2) {
          this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?
          /** @type {Array.<*>} */
          lastFillInstruction : null, backgroundStroke ?
          /** @type {Array.<*>} */
          lastStrokeInstruction : null);
        }

        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;

      case _instruction2.default.DRAW_CHARS:
        var begin =
        /** @type {number} */
        instruction[1];
        var end =
        /** @type {number} */
        instruction[2];
        var baseline =
        /** @type {number} */
        instruction[3];
        declutterGroup = featureCallback ? null :
        /** @type {ol.DeclutterGroup} */
        instruction[4];
        var overflow =
        /** @type {number} */
        instruction[5];
        var fillKey =
        /** @type {string} */
        instruction[6];
        var maxAngle =
        /** @type {number} */
        instruction[7];
        var measure =
        /** @type {function(string):number} */
        instruction[8];
        var offsetY =
        /** @type {number} */
        instruction[9];
        var strokeKey =
        /** @type {string} */
        instruction[10];
        var strokeWidth =
        /** @type {number} */
        instruction[11];
        var text =
        /** @type {string} */
        instruction[12];
        var textKey =
        /** @type {string} */
        instruction[13];
        var textScale =
        /** @type {number} */
        instruction[14];

        var pathLength = _length2.default.lineString(pixelCoordinates, begin, end, 2);

        var textLength = measure(text);

        if (overflow || textLength <= pathLength) {
          var textAlign =
          /** @type {ol.render.canvas.TextReplay} */
          this.textStates[textKey].textAlign;
          var startM = (pathLength - textLength) * _replay2.default.TEXT_ALIGN[textAlign];

          var parts = _textpath2.default.lineString(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);

          if (parts) {
            var c, cc, chars, label, part;

            if (strokeKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c]; // x, y, anchorX, rotation, chunk

                chars =
                /** @type {string} */
                part[4];
                label =
                /** @type {ol.render.canvas.TextReplay} */
                this.getImage(chars, textKey, '', strokeKey);
                anchorX =
                /** @type {number} */
                part[2] + strokeWidth;
                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                this.replayImage_(context,
                /** @type {number} */
                part[0],
                /** @type {number} */
                part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                /** @type {number} */
                part[3], textScale, false, label.width, _canvas2.default.defaultPadding, null, null);
              }
            }

            if (fillKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c]; // x, y, anchorX, rotation, chunk

                chars =
                /** @type {string} */
                part[4];
                label =
                /** @type {ol.render.canvas.TextReplay} */
                this.getImage(chars, textKey, fillKey, '');
                anchorX =
                /** @type {number} */
                part[2];
                anchorY = baseline * label.height - offsetY;
                this.replayImage_(context,
                /** @type {number} */
                part[0],
                /** @type {number} */
                part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                /** @type {number} */
                part[3], textScale, false, label.width, _canvas2.default.defaultPadding, null, null);
              }
            }
          }
        }

        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;

      case _instruction2.default.END_GEOMETRY:
        if (featureCallback !== undefined) {
          feature =
          /** @type {ol.Feature|ol.render.Feature} */
          instruction[1];
          var result = featureCallback(feature);

          if (result) {
            return result;
          }
        }

        ++i;
        break;

      case _instruction2.default.FILL:
        if (batchSize) {
          pendingFill++;
        } else {
          this.fill_(context);
        }

        ++i;
        break;

      case _instruction2.default.MOVE_TO_LINE_TO:
        d =
        /** @type {number} */
        instruction[1];
        dd =
        /** @type {number} */
        instruction[2];
        x = pixelCoordinates[d];
        y = pixelCoordinates[d + 1];
        roundX = x + 0.5 | 0;
        roundY = y + 0.5 | 0;

        if (roundX !== prevX || roundY !== prevY) {
          context.moveTo(x, y);
          prevX = roundX;
          prevY = roundY;
        }

        for (d += 2; d < dd; d += 2) {
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;

          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
            context.lineTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
        }

        ++i;
        break;

      case _instruction2.default.SET_FILL_STYLE:
        lastFillInstruction = instruction;
        this.fillOrigin_ = instruction[2];

        if (pendingFill) {
          this.fill_(context);
          pendingFill = 0;

          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
        }

        context.fillStyle =
        /** @type {ol.ColorLike} */
        instruction[1];
        ++i;
        break;

      case _instruction2.default.SET_STROKE_STYLE:
        lastStrokeInstruction = instruction;

        if (pendingStroke) {
          context.stroke();
          pendingStroke = 0;
        }

        this.setStrokeStyle_(context,
        /** @type {Array.<*>} */
        instruction);
        ++i;
        break;

      case _instruction2.default.STROKE:
        if (batchSize) {
          pendingStroke++;
        } else {
          context.stroke();
        }

        ++i;
        break;

      default:
        ++i; // consume the instruction anyway, to avoid an infinite loop

        break;
    }
  }

  if (pendingFill) {
    this.fill_(context);
  }

  if (pendingStroke) {
    context.stroke();
  }

  return undefined;
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 */


_ol_render_canvas_Replay_.prototype.replay = function (context, transform, viewRotation, skippedFeaturesHash) {
  this.viewRotation_ = viewRotation;
  this.replay_(context, transform, skippedFeaturesHash, this.instructions, undefined, undefined);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_canvas_Replay_.prototype.replayHitDetection = function (context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {
  this.viewRotation_ = viewRotation;
  return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);
};
/**
 * Reverse the hit detection instructions.
 */


_ol_render_canvas_Replay_.prototype.reverseHitDetectionInstructions = function () {
  var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array

  hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks

  var i;
  var n = hitDetectionInstructions.length;
  var instruction;
  var type;
  var begin = -1;

  for (i = 0; i < n; ++i) {
    instruction = hitDetectionInstructions[i];
    type =
    /** @type {ol.render.canvas.Instruction} */
    instruction[0];

    if (type == _instruction2.default.END_GEOMETRY) {
      begin = i;
    } else if (type == _instruction2.default.BEGIN_GEOMETRY) {
      instruction[2] = i;

      _array2.default.reverseSubArray(this.hitDetectionInstructions, begin, i);

      begin = -1;
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_canvas_Replay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var state = this.state;

  if (fillStyle) {
    var fillStyleColor = fillStyle.getColor();
    state.fillStyle = _colorlike2.default.asColorLike(fillStyleColor ? fillStyleColor : _canvas2.default.defaultFillStyle);
  } else {
    state.fillStyle = undefined;
  }

  if (strokeStyle) {
    var strokeStyleColor = strokeStyle.getColor();
    state.strokeStyle = _colorlike2.default.asColorLike(strokeStyleColor ? strokeStyleColor : _canvas2.default.defaultStrokeStyle);
    var strokeStyleLineCap = strokeStyle.getLineCap();
    state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas2.default.defaultLineCap;
    var strokeStyleLineDash = strokeStyle.getLineDash();
    state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvas2.default.defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset;
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas2.default.defaultLineJoin;
    var strokeStyleWidth = strokeStyle.getWidth();
    state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas2.default.defaultLineWidth;
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas2.default.defaultMiterLimit;

    if (state.lineWidth > this.maxLineWidth) {
      this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache

      this.bufferedMaxExtent_ = null;
    }
  } else {
    state.strokeStyle = undefined;
    state.lineCap = undefined;
    state.lineDash = null;
    state.lineDashOffset = undefined;
    state.lineJoin = undefined;
    state.lineWidth = undefined;
    state.miterLimit = undefined;
  }
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */


_ol_render_canvas_Replay_.prototype.applyFill = function (state, geometry) {
  var fillStyle = state.fillStyle;
  var fillInstruction = [_instruction2.default.SET_FILL_STYLE, fillStyle];

  if (typeof fillStyle !== 'string') {
    var fillExtent = geometry.getExtent();
    fillInstruction.push([fillExtent[0], fillExtent[3]]);
  }

  this.instructions.push(fillInstruction);
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 */


_ol_render_canvas_Replay_.prototype.applyStroke = function (state) {
  this.instructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio]);
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState, (ol.geom.Geometry|ol.render.Feature))} applyFill Apply fill.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */


_ol_render_canvas_Replay_.prototype.updateFillStyle = function (state, applyFill, geometry) {
  var fillStyle = state.fillStyle;

  if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
    applyFill.call(this, state, geometry);
    state.currentFillStyle = fillStyle;
  }
};
/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState)} applyStroke Apply stroke.
 */


_ol_render_canvas_Replay_.prototype.updateStrokeStyle = function (state, applyStroke) {
  var strokeStyle = state.strokeStyle;
  var lineCap = state.lineCap;
  var lineDash = state.lineDash;
  var lineDashOffset = state.lineDashOffset;
  var lineJoin = state.lineJoin;
  var lineWidth = state.lineWidth;
  var miterLimit = state.miterLimit;

  if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !_array2.default.equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
    applyStroke.call(this, state);
    state.currentStrokeStyle = strokeStyle;
    state.currentLineCap = lineCap;
    state.currentLineDash = lineDash;
    state.currentLineDashOffset = lineDashOffset;
    state.currentLineJoin = lineJoin;
    state.currentLineWidth = lineWidth;
    state.currentMiterLimit = miterLimit;
  }
};
/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_canvas_Replay_.prototype.endGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_[2] = this.instructions.length;
  this.beginGeometryInstruction1_ = null;
  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
  this.beginGeometryInstruction2_ = null;
  var endGeometryInstruction = [_instruction2.default.END_GEOMETRY, feature];
  this.instructions.push(endGeometryInstruction);
  this.hitDetectionInstructions.push(endGeometryInstruction);
};
/**
 * FIXME empty description for jsdoc
 */


_ol_render_canvas_Replay_.prototype.finish = _index2.default.nullFunction;
/**
 * Get the buffered rendering extent.  Rendering will be clipped to the extent
 * provided to the constructor.  To account for symbolizers that may intersect
 * this extent, we calculate a buffered extent (e.g. based on stroke width).
 * @return {ol.Extent} The buffered rendering extent.
 * @protected
 */

_ol_render_canvas_Replay_.prototype.getBufferedMaxExtent = function () {
  if (!this.bufferedMaxExtent_) {
    this.bufferedMaxExtent_ = _extent2.default.clone(this.maxExtent);

    if (this.maxLineWidth > 0) {
      var width = this.resolution * (this.maxLineWidth + 1) / 2;

      _extent2.default.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
    }
  }

  return this.bufferedMaxExtent_;
};

exports.default = _ol_render_canvas_Replay_;

},{"../../array.js":30,"../../colorlike.js":38,"../../extent.js":55,"../../extent/relationship.js":57,"../../geom/flat/inflate.js":66,"../../geom/flat/length.js":69,"../../geom/flat/textpath.js":75,"../../geom/flat/transform.js":77,"../../geom/geometrytype.js":80,"../../has.js":85,"../../index.js":90,"../../obj.js":125,"../../transform.js":244,"../canvas.js":151,"../canvas/instruction.js":154,"../replay.js":162,"../vectorcontext.js":165}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _transform = require("../../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _replaygroup = require("../replaygroup.js");

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _replaytype = require("../replaytype.js");

var _replaytype2 = _interopRequireDefault(_replaytype);

var _replay = require("../canvas/replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _imagereplay = require("../canvas/imagereplay.js");

var _imagereplay2 = _interopRequireDefault(_imagereplay);

var _linestringreplay = require("../canvas/linestringreplay.js");

var _linestringreplay2 = _interopRequireDefault(_linestringreplay);

var _polygonreplay = require("../canvas/polygonreplay.js");

var _polygonreplay2 = _interopRequireDefault(_polygonreplay);

var _textreplay = require("../canvas/textreplay.js");

var _textreplay2 = _interopRequireDefault(_textreplay);

var _replay3 = require("../replay.js");

var _replay4 = _interopRequireDefault(_replay3);

var _transform3 = require("../../transform.js");

var _transform4 = _interopRequireDefault(_transform3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay group can have overlapping geometries.
 * @param {?} declutterTree Declutter tree
 * for declutter processing in postrender.
 * @param {number=} opt_renderBuffer Optional rendering buffer.
 * @struct
 */
var _ol_render_canvas_ReplayGroup_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {
  _replaygroup2.default.call(this);
  /**
   * Declutter tree.
   * @private
   */


  this.declutterTree_ = declutterTree;
  /**
   * @type {ol.DeclutterGroup}
   * @private
   */

  this.declutterGroup_ = null;
  /**
   * @private
   * @type {number}
   */

  this.tolerance_ = tolerance;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.maxExtent_ = maxExtent;
  /**
   * @private
   * @type {boolean}
   */

  this.overlaps_ = overlaps;
  /**
   * @private
   * @type {number}
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @private
   * @type {number}
   */

  this.resolution_ = resolution;
  /**
   * @private
   * @type {number|undefined}
   */

  this.renderBuffer_ = opt_renderBuffer;
  /**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.canvas.Replay>>}
   */

  this.replaysByZIndex_ = {};
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.hitDetectionContext_ = _dom2.default.createCanvasContext2D(1, 1);
  /**
   * @private
   * @type {ol.Transform}
   */

  this.hitDetectionTransform_ = _transform4.default.create();
};

_index2.default.inherits(_ol_render_canvas_ReplayGroup_, _replaygroup2.default);
/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}
 * @private
 */


_ol_render_canvas_ReplayGroup_.circleArrayCache_ = {
  0: [[true]]
};
/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @private
 */

_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_ = function (array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);

  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
};
/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.
 * @private
 */


_ol_render_canvas_ReplayGroup_.getCircleArray_ = function (radius) {
  if (_ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] !== undefined) {
    return _ol_render_canvas_ReplayGroup_.circleArrayCache_[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);

  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius + y);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius + x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius + x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius + y);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius - y);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius - x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius - x);

    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius - y);

    y++;
    error += 1 + 2 * y;

    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  _ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] = arr;
  return arr;
};
/**
 * @param {!Object.<string, Array.<*>>} declutterReplays Declutter replays.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 */


_ol_render_canvas_ReplayGroup_.replayDeclutter = function (declutterReplays, context, rotation) {
  var zs = Object.keys(declutterReplays).map(Number).sort(_array2.default.numberSafeCompareFunction);
  var skippedFeatureUids = {};

  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var replayData = declutterReplays[zs[z].toString()];

    for (var i = 0, ii = replayData.length; i < ii;) {
      var replay = replayData[i++];
      var transform = replayData[i++];
      replay.replay(context, transform, rotation, skippedFeatureUids);
    }
  }
};
/**
 * @param {boolean} group Group with previous replay.
 * @return {ol.DeclutterGroup} Declutter instruction group.
 */


_ol_render_canvas_ReplayGroup_.prototype.addDeclutter = function (group) {
  var declutter = null;

  if (this.declutterTree_) {
    if (group) {
      declutter = this.declutterGroup_;
      /** @type {number} */

      declutter[4]++;
    } else {
      declutter = this.declutterGroup_ = _extent2.default.createEmpty();
      declutter.push(1);
    }
  }

  return declutter;
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 */


_ol_render_canvas_ReplayGroup_.prototype.clip = function (context, transform) {
  var flatClipCoords = this.getClipCoords(transform);
  context.beginPath();
  context.moveTo(flatClipCoords[0], flatClipCoords[1]);
  context.lineTo(flatClipCoords[2], flatClipCoords[3]);
  context.lineTo(flatClipCoords[4], flatClipCoords[5]);
  context.lineTo(flatClipCoords[6], flatClipCoords[7]);
  context.clip();
};
/**
 * @param {Array.<ol.render.ReplayType>} replays Replays.
 * @return {boolean} Has replays of the provided types.
 */


_ol_render_canvas_ReplayGroup_.prototype.hasReplays = function (replays) {
  for (var zIndex in this.replaysByZIndex_) {
    var candidates = this.replaysByZIndex_[zIndex];

    for (var i = 0, ii = replays.length; i < ii; ++i) {
      if (replays[i] in candidates) {
        return true;
      }
    }
  }

  return false;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_render_canvas_ReplayGroup_.prototype.finish = function () {
  var zKey;

  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;

    for (replayKey in replays) {
      replays[replayKey].finish();
    }
  }
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @param {Object.<string, ol.DeclutterGroup>} declutterReplays Declutter
 *     replays.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_canvas_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {
  hitTolerance = Math.round(hitTolerance);
  var contextSize = hitTolerance * 2 + 1;

  var transform = _transform4.default.compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);

  var context = this.hitDetectionContext_;

  if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
    context.canvas.width = contextSize;
    context.canvas.height = contextSize;
  } else {
    context.clearRect(0, 0, contextSize, contextSize);
  }
  /**
   * @type {ol.Extent}
   */


  var hitExtent;

  if (this.renderBuffer_ !== undefined) {
    hitExtent = _extent2.default.createEmpty();

    _extent2.default.extendCoordinate(hitExtent, coordinate);

    _extent2.default.buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
  }

  var mask = _ol_render_canvas_ReplayGroup_.getCircleArray_(hitTolerance);

  var declutteredFeatures;

  if (this.declutterTree_) {
    declutteredFeatures = this.declutterTree_.all().map(function (entry) {
      return entry.value;
    });
  }
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */


  function hitDetectionCallback(feature) {
    var imageData = context.getImageData(0, 0, contextSize, contextSize).data;

    for (var i = 0; i < contextSize; i++) {
      for (var j = 0; j < contextSize; j++) {
        if (mask[i][j]) {
          if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
            var result;

            if (!declutteredFeatures || declutteredFeatures.indexOf(feature) !== -1) {
              result = callback(feature);
            }

            if (result) {
              return result;
            } else {
              context.clearRect(0, 0, contextSize, contextSize);
              return undefined;
            }
          }
        }
      }
    }
  }

  return this.replayHitDetection_(context, transform, rotation, skippedFeaturesHash, hitDetectionCallback, hitExtent, declutterReplays);
};
/**
 * @param {ol.Transform} transform Transform.
 * @return {Array.<number>} Clip coordinates.
 */


_ol_render_canvas_ReplayGroup_.prototype.getClipCoords = function (transform) {
  var maxExtent = this.maxExtent_;
  var minX = maxExtent[0];
  var minY = maxExtent[1];
  var maxX = maxExtent[2];
  var maxY = maxExtent[3];
  var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];

  _transform2.default.transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);

  return flatClipCoords;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
  var replays = this.replaysByZIndex_[zIndexKey];

  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }

  var replay = replays[replayType];

  if (replay === undefined) {
    var Constructor = _ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
    replays[replayType] = replay;
  }

  return replay;
};
/**
 * @return {Object.<string, Object.<ol.render.ReplayType, ol.render.canvas.Replay>>} Replays.
 */


_ol_render_canvas_ReplayGroup_.prototype.getReplays = function () {
  return this.replaysByZIndex_;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_ReplayGroup_.prototype.isEmpty = function () {
  return _obj2.default.isEmpty(this.replaysByZIndex_);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<ol.render.ReplayType>=} opt_replayTypes Ordered replay types
 *     to replay. Default is {@link ol.render.replay.ORDER}
 * @param {Object.<string, ol.DeclutterGroup>=} opt_declutterReplays Declutter
 *     replays.
 */


_ol_render_canvas_ReplayGroup_.prototype.replay = function (context, transform, viewRotation, skippedFeaturesHash, opt_replayTypes, opt_declutterReplays) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(_array2.default.numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not
  // visible outside the current extent when panning

  context.save();
  this.clip(context, transform);
  var replayTypes = opt_replayTypes ? opt_replayTypes : _replay4.default.ORDER;
  var i, ii, j, jj, replays, replay;

  for (i = 0, ii = zs.length; i < ii; ++i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];

    for (j = 0, jj = replayTypes.length; j < jj; ++j) {
      var replayType = replayTypes[j];
      replay = replays[replayType];

      if (replay !== undefined) {
        if (opt_declutterReplays && (replayType == _replaytype2.default.IMAGE || replayType == _replaytype2.default.TEXT)) {
          var declutter = opt_declutterReplays[zIndexKey];

          if (!declutter) {
            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          replay.replay(context, transform, viewRotation, skippedFeaturesHash);
        }
      }
    }
  }

  context.restore();
};
/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @param {Object.<string, ol.DeclutterGroup>=} opt_declutterReplays Declutter
 *     replays.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_canvas_ReplayGroup_.prototype.replayHitDetection_ = function (context, transform, viewRotation, skippedFeaturesHash, featureCallback, opt_hitExtent, opt_declutterReplays) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(_array2.default.numberSafeCompareFunction);
  var i, j, replays, replay, result;

  for (i = zs.length - 1; i >= 0; --i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];

    for (j = _replay4.default.ORDER.length - 1; j >= 0; --j) {
      var replayType = _replay4.default.ORDER[j];
      replay = replays[replayType];

      if (replay !== undefined) {
        if (opt_declutterReplays && (replayType == _replaytype2.default.IMAGE || replayType == _replaytype2.default.TEXT)) {
          var declutter = opt_declutterReplays[zIndexKey];

          if (!declutter) {
            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          result = replay.replayHitDetection(context, transform, viewRotation, skippedFeaturesHash, featureCallback, opt_hitExtent);

          if (result) {
            return result;
          }
        }
      }
    }
  }

  return undefined;
};
/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.canvas.Replay, number, ol.Extent,
 *                number, number, boolean, Array.<ol.DeclutterGroup>)>}
 */


_ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
  'Circle': _polygonreplay2.default,
  'Default': _replay2.default,
  'Image': _imagereplay2.default,
  'LineString': _linestringreplay2.default,
  'Polygon': _polygonreplay2.default,
  'Text': _textreplay2.default
};
exports.default = _ol_render_canvas_ReplayGroup_;

},{"../../array.js":30,"../../dom.js":47,"../../extent.js":55,"../../geom/flat/transform.js":77,"../../index.js":90,"../../obj.js":125,"../../transform.js":244,"../canvas/imagereplay.js":152,"../canvas/linestringreplay.js":155,"../canvas/polygonreplay.js":156,"../canvas/replay.js":157,"../canvas/textreplay.js":159,"../replay.js":162,"../replaygroup.js":163,"../replaytype.js":164}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _colorlike = require("../../colorlike.js");

var _colorlike2 = _interopRequireDefault(_colorlike);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _straightchunk = require("../../geom/flat/straightchunk.js");

var _straightchunk2 = _interopRequireDefault(_straightchunk);

var _geometrytype = require("../../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _has = require("../../has.js");

var _has2 = _interopRequireDefault(_has);

var _canvas = require("../canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _instruction = require("../canvas/instruction.js");

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require("../canvas/replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _replay3 = require("../replay.js");

var _replay4 = _interopRequireDefault(_replay3);

var _textplacement = require("../../style/textplacement.js");

var _textplacement2 = _interopRequireDefault(_textplacement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var _ol_render_canvas_TextReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  _replay2.default.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  /**
   * @private
   * @type {ol.DeclutterGroup}
   */


  this.declutterGroup_;
  /**
   * @private
   * @type {Array.<HTMLCanvasElement>}
   */

  this.labels_ = null;
  /**
   * @private
   * @type {string}
   */

  this.text_ = '';
  /**
   * @private
   * @type {number}
   */

  this.textOffsetX_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.textOffsetY_ = 0;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.textRotateWithView_ = undefined;
  /**
   * @private
   * @type {number}
   */

  this.textRotation_ = 0;
  /**
   * @private
   * @type {?ol.CanvasFillState}
   */

  this.textFillState_ = null;
  /**
   * @type {Object.<string, ol.CanvasFillState>}
   */

  this.fillStates = {};
  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */

  this.textStrokeState_ = null;
  /**
   * @type {Object.<string, ol.CanvasStrokeState>}
   */

  this.strokeStates = {};
  /**
   * @private
   * @type {ol.CanvasTextState}
   */

  this.textState_ =
  /** @type {ol.CanvasTextState} */
  {};
  /**
   * @type {Object.<string, ol.CanvasTextState>}
   */

  this.textStates = {};
  /**
   * @private
   * @type {string}
   */

  this.textKey_ = '';
  /**
   * @private
   * @type {string}
   */

  this.fillKey_ = '';
  /**
   * @private
   * @type {string}
   */

  this.strokeKey_ = '';
  /**
   * @private
   * @type {Object.<string, Object.<string, number>>}
   */

  this.widths_ = {};
  var labelCache = _canvas2.default.labelCache;
  labelCache.prune();
};

_index2.default.inherits(_ol_render_canvas_TextReplay_, _replay2.default);
/**
 * @param {string} font Font to use for measuring.
 * @param {Array.<string>} lines Lines to measure.
 * @param {Array.<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */


_ol_render_canvas_TextReplay_.measureTextWidths = function (font, lines, widths) {
  var numLines = lines.length;
  var width = 0;
  var currentWidth, i;

  for (i = 0; i < numLines; ++i) {
    currentWidth = _canvas2.default.measureTextWidth(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }

  return width;
};
/**
 * @inheritDoc
 */


_ol_render_canvas_TextReplay_.prototype.drawText = function (geometry, feature) {
  var fillState = this.textFillState_;
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;

  if (this.text_ === '' || !textState || !fillState && !strokeState) {
    return;
  }

  var begin = this.coordinates.length;
  var geometryType = geometry.getType();
  var flatCoordinates = null;
  var end = 2;
  var stride = 2;
  var i, ii;

  if (textState.placement === _textplacement2.default.LINE) {
    if (!_extent2.default.intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
      return;
    }

    var ends;
    flatCoordinates = geometry.getFlatCoordinates();
    stride = geometry.getStride();

    if (geometryType == _geometrytype2.default.LINE_STRING) {
      ends = [flatCoordinates.length];
    } else if (geometryType == _geometrytype2.default.MULTI_LINE_STRING) {
      ends = geometry.getEnds();
    } else if (geometryType == _geometrytype2.default.POLYGON) {
      ends = geometry.getEnds().slice(0, 1);
    } else if (geometryType == _geometrytype2.default.MULTI_POLYGON) {
      var endss = geometry.getEndss();
      ends = [];

      for (i = 0, ii = endss.length; i < ii; ++i) {
        ends.push(endss[i][0]);
      }
    }

    this.beginGeometry(geometry, feature);
    var textAlign = textState.textAlign;
    var flatOffset = 0;
    var flatEnd;

    for (var o = 0, oo = ends.length; o < oo; ++o) {
      if (textAlign == undefined) {
        var range = _straightchunk2.default.lineString(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);

        flatOffset = range[0];
        flatEnd = range[1];
      } else {
        flatEnd = ends[o];
      }

      for (i = flatOffset; i < flatEnd; i += stride) {
        this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
      }

      end = this.coordinates.length;
      flatOffset = ends[o];
      this.drawChars_(begin, end, this.declutterGroup_);
      begin = end;
    }

    this.endGeometry(geometry, feature);
  } else {
    var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
    var width = label.width / this.pixelRatio;

    switch (geometryType) {
      case _geometrytype2.default.POINT:
      case _geometrytype2.default.MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        break;

      case _geometrytype2.default.LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.LineString} */
        geometry.getFlatMidpoint();
        break;

      case _geometrytype2.default.CIRCLE:
        flatCoordinates =
        /** @type {ol.geom.Circle} */
        geometry.getCenter();
        break;

      case _geometrytype2.default.MULTI_LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.MultiLineString} */
        geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;

      case _geometrytype2.default.POLYGON:
        flatCoordinates =
        /** @type {ol.geom.Polygon} */
        geometry.getFlatInteriorPoint();

        if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
          return;
        }

        stride = 3;
        break;

      case _geometrytype2.default.MULTI_POLYGON:
        var interiorPoints =
        /** @type {ol.geom.MultiPolygon} */
        geometry.getFlatInteriorPoints();
        flatCoordinates = [];

        for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
          if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
        }

        end = flatCoordinates.length;

        if (end == 0) {
          return;
        }

        break;

      default:
    }

    end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
    this.beginGeometry(geometry, feature);

    if (textState.backgroundFill || textState.backgroundStroke) {
      this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
      this.updateFillStyle(this.state, this.applyFill, geometry);
      this.updateStrokeStyle(this.state, this.applyStroke);
    }

    this.drawTextImage_(label, begin, end);
    this.endGeometry(geometry, feature);
  }
};
/**
 * @param {string} text Text.
 * @param {string} textKey Text style key.
 * @param {string} fillKey Fill style key.
 * @param {string} strokeKey Stroke style key.
 * @return {HTMLCanvasElement} Image.
 */


_ol_render_canvas_TextReplay_.prototype.getImage = function (text, textKey, fillKey, strokeKey) {
  var label;
  var key = strokeKey + textKey + text + fillKey + this.pixelRatio;
  var labelCache = _canvas2.default.labelCache;

  if (!labelCache.containsKey(key)) {
    var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
    var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
    var textState = this.textStates[textKey] || this.textState_;
    var pixelRatio = this.pixelRatio;
    var scale = textState.scale * pixelRatio;
    var align = _replay4.default.TEXT_ALIGN[textState.textAlign || _canvas2.default.defaultTextAlign];
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var lines = text.split('\n');
    var numLines = lines.length;
    var widths = [];

    var width = _ol_render_canvas_TextReplay_.measureTextWidths(textState.font, lines, widths);

    var lineHeight = _canvas2.default.measureTextHeight(textState.font);

    var height = lineHeight * numLines;
    var renderWidth = width + strokeWidth;

    var context = _dom2.default.createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));

    label = context.canvas;
    labelCache.set(key, label);

    if (scale != 1) {
      context.scale(scale, scale);
    }

    context.font = textState.font;

    if (strokeKey) {
      context.strokeStyle = strokeState.strokeStyle;
      context.lineWidth = strokeWidth * (_has2.default.SAFARI ? scale : 1);
      context.lineCap = strokeState.lineCap;
      context.lineJoin = strokeState.lineJoin;
      context.miterLimit = strokeState.miterLimit;

      if (_has2.default.CANVAS_LINE_DASH && strokeState.lineDash.length) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
    }

    if (fillKey) {
      context.fillStyle = fillState.fillStyle;
    }

    context.textBaseline = 'middle';
    context.textAlign = 'center';
    var leftRight = 0.5 - align;
    var x = align * label.width / scale + leftRight * strokeWidth;
    var i;

    if (strokeKey) {
      for (i = 0; i < numLines; ++i) {
        context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }

    if (fillKey) {
      for (i = 0; i < numLines; ++i) {
        context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }
  }

  return labelCache.get(key);
};
/**
 * @private
 * @param {HTMLCanvasElement} label Label.
 * @param {number} begin Begin.
 * @param {number} end End.
 */


_ol_render_canvas_TextReplay_.prototype.drawTextImage_ = function (label, begin, end) {
  var textState = this.textState_;
  var strokeState = this.textStrokeState_;
  var pixelRatio = this.pixelRatio;
  var align = _replay4.default.TEXT_ALIGN[textState.textAlign || _canvas2.default.defaultTextAlign];
  var baseline = _replay4.default.TEXT_ALIGN[textState.textBaseline];
  var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
  var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
  var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
  this.instructions.push([_instruction2.default.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, true, label.width, textState.padding == _canvas2.default.defaultPadding ? _canvas2.default.defaultPadding : textState.padding.map(function (p) {
    return p * pixelRatio;
  }), !!textState.backgroundFill, !!textState.backgroundStroke]);
  this.hitDetectionInstructions.push([_instruction2.default.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, true, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);
};
/**
 * @private
 * @param {number} begin Begin.
 * @param {number} end End.
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 */


_ol_render_canvas_TextReplay_.prototype.drawChars_ = function (begin, end, declutterGroup) {
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;
  var fillState = this.textFillState_;
  var strokeKey = this.strokeKey_;

  if (strokeState) {
    if (!(strokeKey in this.strokeStates)) {
      this.strokeStates[strokeKey] =
      /** @type {ol.CanvasStrokeState} */
      {
        strokeStyle: strokeState.strokeStyle,
        lineCap: strokeState.lineCap,
        lineDashOffset: strokeState.lineDashOffset,
        lineWidth: strokeState.lineWidth,
        lineJoin: strokeState.lineJoin,
        miterLimit: strokeState.miterLimit,
        lineDash: strokeState.lineDash
      };
    }
  }

  var textKey = this.textKey_;

  if (!(this.textKey_ in this.textStates)) {
    this.textStates[this.textKey_] =
    /** @type {ol.CanvasTextState} */
    {
      font: textState.font,
      textAlign: textState.textAlign || _canvas2.default.defaultTextAlign,
      scale: textState.scale
    };
  }

  var fillKey = this.fillKey_;

  if (fillState) {
    if (!(fillKey in this.fillStates)) {
      this.fillStates[fillKey] =
      /** @type {ol.CanvasFillState} */
      {
        fillStyle: fillState.fillStyle
      };
    }
  }

  var pixelRatio = this.pixelRatio;
  var baseline = _replay4.default.TEXT_ALIGN[textState.textBaseline];
  var offsetY = this.textOffsetY_ * pixelRatio;
  var text = this.text_;
  var font = textState.font;
  var textScale = textState.scale;
  var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
  var widths = this.widths_[font];

  if (!widths) {
    this.widths_[font] = widths = {};
  }

  this.instructions.push([_instruction2.default.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {
    var width = widths[text];

    if (!width) {
      width = widths[text] = _canvas2.default.measureTextWidth(font, text);
    }

    return width * textScale * pixelRatio;
  }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
  this.hitDetectionInstructions.push([_instruction2.default.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {
    var width = widths[text];

    if (!width) {
      width = widths[text] = _canvas2.default.measureTextWidth(font, text);
    }

    return width * textScale;
  }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
};
/**
 * @inheritDoc
 */


_ol_render_canvas_TextReplay_.prototype.setTextStyle = function (textStyle, declutterGroup) {
  var textState, fillState, strokeState;

  if (!textStyle) {
    this.text_ = '';
  } else {
    this.declutterGroup_ =
    /** @type {ol.DeclutterGroup} */
    declutterGroup;
    var textFillStyle = textStyle.getFill();

    if (!textFillStyle) {
      fillState = this.textFillState_ = null;
    } else {
      fillState = this.textFillState_;

      if (!fillState) {
        fillState = this.textFillState_ =
        /** @type {ol.CanvasFillState} */
        {};
      }

      fillState.fillStyle = _colorlike2.default.asColorLike(textFillStyle.getColor() || _canvas2.default.defaultFillStyle);
    }

    var textStrokeStyle = textStyle.getStroke();

    if (!textStrokeStyle) {
      strokeState = this.textStrokeState_ = null;
    } else {
      strokeState = this.textStrokeState_;

      if (!strokeState) {
        strokeState = this.textStrokeState_ =
        /** @type {ol.CanvasStrokeState} */
        {};
      }

      var lineDash = textStrokeStyle.getLineDash();
      var lineDashOffset = textStrokeStyle.getLineDashOffset();
      var lineWidth = textStrokeStyle.getWidth();
      var miterLimit = textStrokeStyle.getMiterLimit();
      strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas2.default.defaultLineCap;
      strokeState.lineDash = lineDash ? lineDash.slice() : _canvas2.default.defaultLineDash;
      strokeState.lineDashOffset = lineDashOffset === undefined ? _canvas2.default.defaultLineDashOffset : lineDashOffset;
      strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas2.default.defaultLineJoin;
      strokeState.lineWidth = lineWidth === undefined ? _canvas2.default.defaultLineWidth : lineWidth;
      strokeState.miterLimit = miterLimit === undefined ? _canvas2.default.defaultMiterLimit : miterLimit;
      strokeState.strokeStyle = _colorlike2.default.asColorLike(textStrokeStyle.getColor() || _canvas2.default.defaultStrokeStyle);
    }

    textState = this.textState_;

    var font = textStyle.getFont() || _canvas2.default.defaultFont;

    _canvas2.default.checkFont(font);

    var textScale = textStyle.getScale();
    textState.overflow = textStyle.getOverflow();
    textState.font = font;
    textState.maxAngle = textStyle.getMaxAngle();
    textState.placement = textStyle.getPlacement();
    textState.textAlign = textStyle.getTextAlign();
    textState.textBaseline = textStyle.getTextBaseline() || _canvas2.default.defaultTextBaseline;
    textState.backgroundFill = textStyle.getBackgroundFill();
    textState.backgroundStroke = textStyle.getBackgroundStroke();
    textState.padding = textStyle.getPadding() || _canvas2.default.defaultPadding;
    textState.scale = textScale === undefined ? 1 : textScale;
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    this.text_ = textStyle.getText() || '';
    this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
    this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
    this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
    this.textRotation_ = textRotation === undefined ? 0 : textRotation;
    this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : _index2.default.getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
    this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');
    this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + _index2.default.getUid(fillState.fillStyle) : '';
  }
};

exports.default = _ol_render_canvas_TextReplay_;

},{"../../colorlike.js":38,"../../dom.js":47,"../../extent.js":55,"../../geom/flat/straightchunk.js":74,"../../geom/geometrytype.js":80,"../../has.js":85,"../../index.js":90,"../../style/textplacement.js":237,"../canvas.js":151,"../canvas/instruction.js":154,"../canvas/replay.js":157,"../replay.js":162}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _event = require("../events/event.js");

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.render.Event}
 * @param {ol.render.EventType} type Type.
 * @param {ol.render.VectorContext=} opt_vectorContext Vector context.
 * @param {olx.FrameState=} opt_frameState Frame state.
 * @param {?CanvasRenderingContext2D=} opt_context Context.
 * @param {?ol.webgl.Context=} opt_glContext WebGL Context.
 */
var _ol_render_Event_ = function (type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {
  _event2.default.call(this, type);
  /**
   * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.
   * @type {ol.render.VectorContext|undefined}
   * @api
   */


  this.vectorContext = opt_vectorContext;
  /**
   * An object representing the current render frame state.
   * @type {olx.FrameState|undefined}
   * @api
   */

  this.frameState = opt_frameState;
  /**
   * Canvas context. Only available when a Canvas renderer is used, null
   * otherwise.
   * @type {CanvasRenderingContext2D|null|undefined}
   * @api
   */

  this.context = opt_context;
  /**
   * WebGL context. Only available when a WebGL renderer is used, null
   * otherwise.
   * @type {ol.webgl.Context|null|undefined}
   * @api
   */

  this.glContext = opt_glContext;
};

_index2.default.inherits(_ol_render_Event_, _event2.default);

exports.default = _ol_render_Event_;

},{"../events/event.js":51,"../index.js":90}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_render_EventType_ = {
  /**
   * @event ol.render.Event#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * @event ol.render.Event#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * @event ol.render.Event#render
   * @api
   */
  RENDER: 'render'
};
exports.default = _ol_render_EventType_;

},{}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _replaytype = require("../render/replaytype.js");

var _replaytype2 = _interopRequireDefault(_replaytype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_render_replay_ = {};
/**
 * @const
 * @type {Array.<ol.render.ReplayType>}
 */

_ol_render_replay_.ORDER = [_replaytype2.default.POLYGON, _replaytype2.default.CIRCLE, _replaytype2.default.LINE_STRING, _replaytype2.default.IMAGE, _replaytype2.default.TEXT, _replaytype2.default.DEFAULT];
/**
 * @const
 * @enum {number}
 */

_ol_render_replay_.TEXT_ALIGN = {};
_ol_render_replay_.TEXT_ALIGN['left'] = 0;
_ol_render_replay_.TEXT_ALIGN['end'] = 0;
_ol_render_replay_.TEXT_ALIGN['center'] = 0.5;
_ol_render_replay_.TEXT_ALIGN['right'] = 1;
_ol_render_replay_.TEXT_ALIGN['start'] = 1;
_ol_render_replay_.TEXT_ALIGN['top'] = 0;
_ol_render_replay_.TEXT_ALIGN['middle'] = 0.5;
_ol_render_replay_.TEXT_ALIGN['hanging'] = 0.2;
_ol_render_replay_.TEXT_ALIGN['alphabetic'] = 0.8;
_ol_render_replay_.TEXT_ALIGN['ideographic'] = 0.8;
_ol_render_replay_.TEXT_ALIGN['bottom'] = 1;
exports.default = _ol_render_replay_;

},{"../render/replaytype.js":164}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Base class for replay groups.
 * @constructor
 * @abstract
 */
var _ol_render_ReplayGroup_ = function () {};
/**
 * @abstract
 * @param {number|undefined} zIndex Z index.
 * @param {ol.render.ReplayType} replayType Replay type.
 * @return {ol.render.VectorContext} Replay.
 */


_ol_render_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {};
/**
 * @abstract
 * @return {boolean} Is empty.
 */


_ol_render_ReplayGroup_.prototype.isEmpty = function () {};

exports.default = _ol_render_ReplayGroup_;

},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_render_ReplayType_ = {
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
};
exports.default = _ol_render_ReplayType_;

},{}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @constructor
 * @abstract
 * @struct
 * @api
 */
var _ol_render_VectorContext_ = function () {};
/**
 * Render a geometry with a custom renderer.
 *
 * @param {ol.geom.SimpleGeometry} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {Function} renderer Renderer.
 */


_ol_render_VectorContext_.prototype.drawCustom = function (geometry, feature, renderer) {};
/**
 * Render a geometry.
 *
 * @param {ol.geom.Geometry} geometry The geometry to render.
 */


_ol_render_VectorContext_.prototype.drawGeometry = function (geometry) {};
/**
 * Set the rendering style.
 *
 * @param {ol.style.Style} style The rendering style.
 */


_ol_render_VectorContext_.prototype.setStyle = function (style) {};
/**
 * @param {ol.geom.Circle} circleGeometry Circle geometry.
 * @param {ol.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawCircle = function (circleGeometry, feature) {};
/**
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 */


_ol_render_VectorContext_.prototype.drawFeature = function (feature, style) {};
/**
 * @param {ol.geom.GeometryCollection} geometryCollectionGeometry Geometry
 *     collection.
 * @param {ol.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) {};
/**
 * @param {ol.geom.LineString|ol.render.Feature} lineStringGeometry Line
 *     string geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawLineString = function (lineStringGeometry, feature) {};
/**
 * @param {ol.geom.MultiLineString|ol.render.Feature} multiLineStringGeometry
 *     MultiLineString geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {};
/**
 * @param {ol.geom.MultiPoint|ol.render.Feature} multiPointGeometry MultiPoint
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {};
/**
 * @param {ol.geom.MultiPolygon} multiPolygonGeometry MultiPolygon geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {};
/**
 * @param {ol.geom.Point|ol.render.Feature} pointGeometry Point geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawPoint = function (pointGeometry, feature) {};
/**
 * @param {ol.geom.Polygon|ol.render.Feature} polygonGeometry Polygon
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawPolygon = function (polygonGeometry, feature) {};
/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */


_ol_render_VectorContext_.prototype.drawText = function (geometry, feature) {};
/**
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 */


_ol_render_VectorContext_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {};
/**
 * @param {ol.style.Image} imageStyle Image style.
 * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.
 */


_ol_render_VectorContext_.prototype.setImageStyle = function (imageStyle, opt_declutterGroup) {};
/**
 * @param {ol.style.Text} textStyle Text style.
 * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.
 */


_ol_render_VectorContext_.prototype.setTextStyle = function (textStyle, opt_declutterGroup) {};

exports.default = _ol_render_VectorContext_;

},{}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_render_webgl_ = {};
/**
 * @const
 * @type {string}
 */

_ol_render_webgl_.defaultFont = '10px sans-serif';
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_webgl_.defaultFillStyle = [0.0, 0.0, 0.0, 1.0];
/**
 * @const
 * @type {string}
 */

_ol_render_webgl_.defaultLineCap = 'round';
/**
 * @const
 * @type {Array.<number>}
 */

_ol_render_webgl_.defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultLineDashOffset = 0;
/**
 * @const
 * @type {string}
 */

_ol_render_webgl_.defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultMiterLimit = 10;
/**
 * @const
 * @type {ol.Color}
 */

_ol_render_webgl_.defaultStrokeStyle = [0.0, 0.0, 0.0, 1.0];
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultTextAlign = 0.5;
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultTextBaseline = 0.5;
/**
 * @const
 * @type {number}
 */

_ol_render_webgl_.defaultLineWidth = 1;
/**
 * Calculates the orientation of a triangle based on the determinant method.
 * @param {number} x1 First X coordinate.
 * @param {number} y1 First Y coordinate.
 * @param {number} x2 Second X coordinate.
 * @param {number} y2 Second Y coordinate.
 * @param {number} x3 Third X coordinate.
 * @param {number} y3 Third Y coordinate.
 * @return {boolean|undefined} Triangle is clockwise.
 */

_ol_render_webgl_.triangleIsCounterClockwise = function (x1, y1, x2, y2, x3, y3) {
  var area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
  return area <= _ol_render_webgl_.EPSILON && area >= -_ol_render_webgl_.EPSILON ? undefined : area > 0;
};
/**
 * @const
 * @type {number}
 */


_ol_render_webgl_.EPSILON = Number.EPSILON || 2.220446049250313e-16;
exports.default = _ol_render_webgl_;

},{}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _color = require("../../color.js");

var _color2 = _interopRequireDefault(_color);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _transform = require("../../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _defaultshader = require("../webgl/circlereplay/defaultshader.js");

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _locations = require("../webgl/circlereplay/defaultshader/locations.js");

var _locations2 = _interopRequireDefault(_locations);

var _replay = require("../webgl/replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _webgl3 = require("../../webgl.js");

var _webgl4 = _interopRequireDefault(_webgl3);

var _buffer = require("../../webgl/buffer.js");

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var _ol_render_webgl_CircleReplay_ = function (tolerance, maxExtent) {
  _replay2.default.call(this, tolerance, maxExtent);
  /**
   * @private
   * @type {ol.render.webgl.circlereplay.defaultshader.Locations}
   */


  this.defaultLocations_ = null;
  /**
   * @private
   * @type {Array.<Array.<Array.<number>|number>>}
   */

  this.styles_ = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.styleIndices_ = [];
  /**
   * @private
   * @type {number}
   */

  this.radius_ = 0;
  /**
   * @private
   * @type {{fillColor: (Array.<number>|null),
   *         strokeColor: (Array.<number>|null),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineWidth: (number|undefined),
   *         changed: boolean}|null}
   */

  this.state_ = {
    fillColor: null,
    strokeColor: null,
    lineDash: null,
    lineDashOffset: undefined,
    lineWidth: undefined,
    changed: false
  };
};

_index2.default.inherits(_ol_render_webgl_CircleReplay_, _replay2.default);
/**
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */


_ol_render_webgl_CircleReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length;
  var n = numVertices / 4;
  var i, ii;

  for (i = offset, ii = end; i < ii; i += stride) {
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 0;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 1;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 2;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 3;
    this.vertices[numVertices++] = this.radius_;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
    this.indices[numIndices++] = n;
    n += 4;
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.drawCircle = function (circleGeometry, feature) {
  var radius = circleGeometry.getRadius();
  var stride = circleGeometry.getStride();

  if (radius) {
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);

    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }

    this.radius_ = radius;
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    flatCoordinates = _transform2.default.translate(flatCoordinates, 0, 2, stride, -this.origin[0], -this.origin[1]);
    this.drawCoordinates_(flatCoordinates, 0, 2, stride);
  } else {
    if (this.state_.changed) {
      this.styles_.pop();

      if (this.styles_.length) {
        var lastState = this.styles_[this.styles_.length - 1];
        this.state_.fillColor =
        /** @type {Array.<number>} */
        lastState[0];
        this.state_.strokeColor =
        /** @type {Array.<number>} */
        lastState[1];
        this.state_.lineWidth =
        /** @type {number} */
        lastState[2];
        this.state_.changed = false;
      }
    }
  }
};
/**
 * @inheritDoc
 **/


_ol_render_webgl_CircleReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new _buffer2.default(this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _buffer2.default(this.indices);
  this.startIndices.push(this.indices.length); //Clean up, if there is nothing to draw

  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.getDeleteResourcesFunction = function (context) {
  // We only delete our stuff here. The shaders and the program may
  // be used by other CircleReplay instances (for other layers). And
  // they will be deleted when disposing of the ol.webgl.Context
  // object.
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = _defaultshader2.default.fragment;
  vertexShader = _defaultshader2.default.vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations_) {
    locations = new _locations2.default(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl4.default.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(locations.a_instruction);
  gl.vertexAttribPointer(locations.a_instruction, 1, _webgl4.default.FLOAT, false, 16, 8);
  gl.enableVertexAttribArray(locations.a_radius);
  gl.vertexAttribPointer(locations.a_radius, 1, _webgl4.default.FLOAT, false, 16, 12); // Enable renderer specific uniforms.

  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_instruction);
  gl.disableVertexAttribArray(locations.a_radius);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];

    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl,
      /** @type {Array.<number>} */
      nextStyle[0]);
      this.setStrokeStyle_(gl,
      /** @type {Array.<number>} */
      nextStyle[1],
      /** @type {number} */
      nextStyle[2]);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[0]);
    this.setStrokeStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[1],
    /** @type {number} */
    nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      featureIndex--;
      end = start;
    }
  }

  return undefined;
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */


_ol_render_webgl_CircleReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[0]);
    this.setStrokeStyle_(gl,
    /** @type {Array.<number>} */
    nextStyle[1],
    /** @type {number} */
    nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
        }

        end = featureStart;
      }

      featureIndex--;
      start = featureStart;
    }

    if (start !== end) {
      this.drawElements(gl, context, start, end);
    }

    start = end = groupStart;
  }
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 */


_ol_render_webgl_CircleReplay_.prototype.setFillStyle_ = function (gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_fillColor, color);
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 * @param {number} lineWidth Line width.
 */


_ol_render_webgl_CircleReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth) {
  gl.uniform4fv(this.defaultLocations_.u_strokeColor, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_CircleReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var strokeStyleColor, strokeStyleWidth;

  if (strokeStyle) {
    var strokeStyleLineDash = strokeStyle.getLineDash();
    this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : _webgl2.default.defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _webgl2.default.defaultLineDashOffset;
    strokeStyleColor = strokeStyle.getColor();

    if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
      strokeStyleColor = _color2.default.asArray(strokeStyleColor).map(function (c, i) {
        return i != 3 ? c / 255 : c;
      }) || _webgl2.default.defaultStrokeStyle;
    } else {
      strokeStyleColor = _webgl2.default.defaultStrokeStyle;
    }

    strokeStyleWidth = strokeStyle.getWidth();
    strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _webgl2.default.defaultLineWidth;
  } else {
    strokeStyleColor = [0, 0, 0, 0];
    strokeStyleWidth = 0;
  }

  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];

  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = _color2.default.asArray(fillStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || _webgl2.default.defaultFillStyle;
  } else {
    fillStyleColor = _webgl2.default.defaultFillStyle;
  }

  if (!this.state_.strokeColor || !_array2.default.equals(this.state_.strokeColor, strokeStyleColor) || !this.state_.fillColor || !_array2.default.equals(this.state_.fillColor, fillStyleColor) || this.state_.lineWidth !== strokeStyleWidth) {
    this.state_.changed = true;
    this.state_.fillColor = fillStyleColor;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.styles_.push([fillStyleColor, strokeStyleColor, strokeStyleWidth]);
  }
};

exports.default = _ol_render_webgl_CircleReplay_;

},{"../../array.js":30,"../../color.js":37,"../../extent.js":55,"../../geom/flat/transform.js":77,"../../index.js":90,"../../obj.js":125,"../../webgl.js":249,"../../webgl/buffer.js":250,"../webgl.js":166,"../webgl/circlereplay/defaultshader.js":168,"../webgl/circlereplay/defaultshader/locations.js":169,"../webgl/replay.js":178}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../index.js");

var _index2 = _interopRequireDefault(_index);

var _fragment = require("../../../webgl/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require("../../../webgl/vertex.js");

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit
var _ol_render_webgl_circlereplay_defaultshader_ = {};
_ol_render_webgl_circlereplay_defaultshader_.fragment = new _fragment2.default(_index2.default.DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_fillColor;\nuniform vec4 u_strokeColor;\nuniform vec2 u_size;\n\nvoid main(void) {\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  float radius = length(windowCenter - windowOffset);\n  float dist = length(windowCenter - gl_FragCoord.xy);\n  if (dist > radius + v_halfWidth) {\n    if (u_strokeColor.a == 0.0) {\n      gl_FragColor = u_fillColor;\n    } else {\n      gl_FragColor = u_strokeColor;\n    }\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\n  } else if (u_fillColor.a == 0.0) {\n    // Hooray, no fill, just stroke. We can use real antialiasing.\n    gl_FragColor = u_strokeColor;\n    if (dist < radius - v_halfWidth) {\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\n    }\n  } else {\n    gl_FragColor = u_fillColor;\n    float strokeDist = radius - v_halfWidth;\n    float antialias = 2.0 * v_pixelRatio;\n    if (dist > strokeDist) {\n      gl_FragColor = u_strokeColor;\n    } else if (dist >= strokeDist - antialias) {\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\n    }\n  }\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n  if (gl_FragColor.a <= 0.0) {\n    discard;\n  }\n}\n' : 'precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}');
_ol_render_webgl_circlereplay_defaultshader_.vertex = new _vertex2.default(_index2.default.DEBUG_WEBGL ? 'varying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\nattribute vec2 a_position;\nattribute float a_instruction;\nattribute float a_radius;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\n  v_pixelRatio = u_pixelRatio;\n  float lineWidth = u_lineWidth * u_pixelRatio;\n  v_halfWidth = lineWidth / 2.0;\n  if (lineWidth == 0.0) {\n    lineWidth = 2.0 * u_pixelRatio;\n  }\n  vec2 offset;\n  // Radius with anitaliasing (roughly).\n  float radius = a_radius + 3.0 * u_pixelRatio;\n  // Until we get gl_VertexID in WebGL, we store an instruction.\n  if (a_instruction == 0.0) {\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\n    offset = vec2(-1.0, 1.0);\n  } else if (a_instruction == 1.0) {\n    offset = vec2(-1.0, -1.0);\n  } else if (a_instruction == 2.0) {\n    offset = vec2(1.0, -1.0);\n  } else {\n    offset = vec2(1.0, 1.0);\n  }\n\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\n      0.0, 1.0)).xy;\n\n  if (distance(v_center, v_offset) > 20000.0) {\n    gl_Position = vec4(v_center, 0.0, 1.0);\n  }\n}\n\n\n' : 'varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;//Until we get gl_VertexID in WebGL,we store an instruction.if(f==0.0){//Offsetting the edges of the triangle by lineWidth/2 is necessary,however//we should also leave some space for the antialiasing,thus we offset by lineWidth.offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}');
exports.default = _ol_render_webgl_circlereplay_defaultshader_;

},{"../../../index.js":90,"../../../webgl/fragment.js":253,"../../../webgl/vertex.js":255}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../../index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var _ol_render_webgl_circlereplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_lineWidth = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_lineWidth' : 'k');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_pixelRatio = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_pixelRatio' : 'l');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'm');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_fillColor = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_fillColor' : 'n');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_strokeColor = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_strokeColor' : 'o');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_size = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_size' : 'p');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'e');
  /**
   * @type {number}
   */

  this.a_instruction = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_instruction' : 'f');
  /**
   * @type {number}
   */

  this.a_radius = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_radius' : 'g');
};

exports.default = _ol_render_webgl_circlereplay_defaultshader_Locations_;

},{"../../../../index.js":90}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _texturereplay = require("../webgl/texturereplay.js");

var _texturereplay2 = _interopRequireDefault(_texturereplay);

var _buffer = require("../../webgl/buffer.js");

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.webgl.TextureReplay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var _ol_render_webgl_ImageReplay_ = function (tolerance, maxExtent) {
  _texturereplay2.default.call(this, tolerance, maxExtent);
  /**
   * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
   * @protected
   */


  this.images_ = [];
  /**
   * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
   * @protected
   */

  this.hitDetectionImages_ = [];
  /**
   * @type {Array.<WebGLTexture>}
   * @private
   */

  this.textures_ = [];
  /**
   * @type {Array.<WebGLTexture>}
   * @private
   */

  this.hitDetectionTextures_ = [];
};

_index2.default.inherits(_ol_render_webgl_ImageReplay_, _texturereplay2.default);
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.finish = function (context) {
  var gl = context.getGL();
  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices.push(this.indices.length); // create, bind, and populate the vertices buffer

  this.verticesBuffer = new _buffer2.default(this.vertices);
  var indices = this.indices; // create, bind, and populate the indices buffer

  this.indicesBuffer = new _buffer2.default(indices); // create textures

  /** @type {Object.<string, WebGLTexture>} */

  var texturePerImage = {};
  this.createTextures(this.textures_, this.images_, texturePerImage, gl);
  this.createTextures(this.hitDetectionTextures_, this.hitDetectionImages_, texturePerImage, gl);
  this.images_ = null;
  this.hitDetectionImages_ = null;

  _texturereplay2.default.prototype.finish.call(this, context);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.setImageStyle = function (imageStyle) {
  var anchor = imageStyle.getAnchor();
  var image = imageStyle.getImage(1);
  var imageSize = imageStyle.getImageSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var opacity = imageStyle.getOpacity();
  var origin = imageStyle.getOrigin();
  var rotateWithView = imageStyle.getRotateWithView();
  var rotation = imageStyle.getRotation();
  var size = imageStyle.getSize();
  var scale = imageStyle.getScale();
  var currentImage;

  if (this.images_.length === 0) {
    this.images_.push(image);
  } else {
    currentImage = this.images_[this.images_.length - 1];

    if (_index2.default.getUid(currentImage) != _index2.default.getUid(image)) {
      this.groupIndices.push(this.indices.length);
      this.images_.push(image);
    }
  }

  if (this.hitDetectionImages_.length === 0) {
    this.hitDetectionImages_.push(hitDetectionImage);
  } else {
    currentImage = this.hitDetectionImages_[this.hitDetectionImages_.length - 1];

    if (_index2.default.getUid(currentImage) != _index2.default.getUid(hitDetectionImage)) {
      this.hitDetectionGroupIndices.push(this.indices.length);
      this.hitDetectionImages_.push(hitDetectionImage);
    }
  }

  this.anchorX = anchor[0];
  this.anchorY = anchor[1];
  this.height = size[1];
  this.imageHeight = imageSize[1];
  this.imageWidth = imageSize[0];
  this.opacity = opacity;
  this.originX = origin[0];
  this.originY = origin[1];
  this.rotation = rotation;
  this.rotateWithView = rotateWithView;
  this.scale = scale;
  this.width = size[0];
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.getTextures = function (opt_all) {
  return opt_all ? this.textures_.concat(this.hitDetectionTextures_) : this.textures_;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ImageReplay_.prototype.getHitDetectionTextures = function () {
  return this.hitDetectionTextures_;
};

exports.default = _ol_render_webgl_ImageReplay_;

},{"../../index.js":90,"../../webgl/buffer.js":250,"../webgl/texturereplay.js":181}],171:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _geometrytype = require("../../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _replaytype = require("../replaytype.js");

var _replaytype2 = _interopRequireDefault(_replaytype);

var _vectorcontext = require("../vectorcontext.js");

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _replaygroup = require("../webgl/replaygroup.js");

var _replaygroup2 = _interopRequireDefault(_replaygroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent} extent Extent.
 * @param {number} pixelRatio Pixel ratio.
 * @struct
 */
var _ol_render_webgl_Immediate_ = function (context, center, resolution, rotation, size, extent, pixelRatio) {
  _vectorcontext2.default.call(this);
  /**
   * @private
   */


  this.context_ = context;
  /**
   * @private
   */

  this.center_ = center;
  /**
   * @private
   */

  this.extent_ = extent;
  /**
   * @private
   */

  this.pixelRatio_ = pixelRatio;
  /**
   * @private
   */

  this.size_ = size;
  /**
   * @private
   */

  this.rotation_ = rotation;
  /**
   * @private
   */

  this.resolution_ = resolution;
  /**
   * @private
   * @type {ol.style.Image}
   */

  this.imageStyle_ = null;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.fillStyle_ = null;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.strokeStyle_ = null;
  /**
   * @private
   * @type {ol.style.Text}
   */

  this.textStyle_ = null;
};

_index2.default.inherits(_ol_render_webgl_Immediate_, _vectorcontext2.default);
/**
 * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @private
 */


_ol_render_webgl_Immediate_.prototype.drawText_ = function (replayGroup, geometry) {
  var context = this.context_;
  var replay =
  /** @type {ol.render.webgl.TextReplay} */
  replayGroup.getReplay(0, _replaytype2.default.TEXT);
  replay.setTextStyle(this.textStyle_);
  replay.drawText(geometry, null);
  replay.finish(context); // default colors

  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
};
/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */


_ol_render_webgl_Immediate_.prototype.setStyle = function (style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};
/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.webgl.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */


_ol_render_webgl_Immediate_.prototype.drawGeometry = function (geometry) {
  var type = geometry.getType();

  switch (type) {
    case _geometrytype2.default.POINT:
      this.drawPoint(
      /** @type {ol.geom.Point} */
      geometry, null);
      break;

    case _geometrytype2.default.LINE_STRING:
      this.drawLineString(
      /** @type {ol.geom.LineString} */
      geometry, null);
      break;

    case _geometrytype2.default.POLYGON:
      this.drawPolygon(
      /** @type {ol.geom.Polygon} */
      geometry, null);
      break;

    case _geometrytype2.default.MULTI_POINT:
      this.drawMultiPoint(
      /** @type {ol.geom.MultiPoint} */
      geometry, null);
      break;

    case _geometrytype2.default.MULTI_LINE_STRING:
      this.drawMultiLineString(
      /** @type {ol.geom.MultiLineString} */
      geometry, null);
      break;

    case _geometrytype2.default.MULTI_POLYGON:
      this.drawMultiPolygon(
      /** @type {ol.geom.MultiPolygon} */
      geometry, null);
      break;

    case _geometrytype2.default.GEOMETRY_COLLECTION:
      this.drawGeometryCollection(
      /** @type {ol.geom.GeometryCollection} */
      geometry, null);
      break;

    case _geometrytype2.default.CIRCLE:
      this.drawCircle(
      /** @type {ol.geom.Circle} */
      geometry, null);
      break;

    default: // pass

  }
};
/**
 * @inheritDoc
 * @api
 */


_ol_render_webgl_Immediate_.prototype.drawFeature = function (feature, style) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry || !_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }

  this.setStyle(style);
  this.drawGeometry(geometry);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawGeometryCollection = function (geometry, data) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawPoint = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _replaygroup2.default(1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.ImageReplay} */
  replayGroup.getReplay(0, _replaytype2.default.IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawPoint(geometry, data);
  replay.finish(context); // default colors

  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawMultiPoint = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _replaygroup2.default(1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.ImageReplay} */
  replayGroup.getReplay(0, _replaytype2.default.IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawMultiPoint(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawLineString = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _replaygroup2.default(1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.LineStringReplay} */
  replayGroup.getReplay(0, _replaytype2.default.LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawMultiLineString = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _replaygroup2.default(1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.LineStringReplay} */
  replayGroup.getReplay(0, _replaytype2.default.LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawMultiLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawPolygon = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _replaygroup2.default(1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.PolygonReplay} */
  replayGroup.getReplay(0, _replaytype2.default.POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawMultiPolygon = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _replaygroup2.default(1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.PolygonReplay} */
  replayGroup.getReplay(0, _replaytype2.default.POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawMultiPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.drawCircle = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new _replaygroup2.default(1, this.extent_);
  var replay =
  /** @type {ol.render.webgl.CircleReplay} */
  replayGroup.getReplay(0, _replaytype2.default.CIRCLE);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawCircle(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.setImageStyle = function (imageStyle) {
  this.imageStyle_ = imageStyle;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  this.fillStyle_ = fillStyle;
  this.strokeStyle_ = strokeStyle;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_Immediate_.prototype.setTextStyle = function (textStyle) {
  this.textStyle_ = textStyle;
};

exports.default = _ol_render_webgl_Immediate_;

},{"../../extent.js":55,"../../geom/geometrytype.js":80,"../../index.js":90,"../replaytype.js":164,"../vectorcontext.js":165,"../webgl/replaygroup.js":179}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _color = require("../../color.js");

var _color2 = _interopRequireDefault(_color);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _orient = require("../../geom/flat/orient.js");

var _orient2 = _interopRequireDefault(_orient);

var _transform = require("../../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _topology = require("../../geom/flat/topology.js");

var _topology2 = _interopRequireDefault(_topology);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _replay = require("../webgl/replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _defaultshader = require("../webgl/linestringreplay/defaultshader.js");

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _locations = require("../webgl/linestringreplay/defaultshader/locations.js");

var _locations2 = _interopRequireDefault(_locations);

var _webgl3 = require("../../webgl.js");

var _webgl4 = _interopRequireDefault(_webgl3);

var _buffer = require("../../webgl/buffer.js");

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var _ol_render_webgl_LineStringReplay_ = function (tolerance, maxExtent) {
  _replay2.default.call(this, tolerance, maxExtent);
  /**
   * @private
   * @type {ol.render.webgl.linestringreplay.defaultshader.Locations}
   */


  this.defaultLocations_ = null;
  /**
   * @private
   * @type {Array.<Array.<?>>}
   */

  this.styles_ = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.styleIndices_ = [];
  /**
   * @private
   * @type {{strokeColor: (Array.<number>|null),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: (number|undefined),
   *         miterLimit: (number|undefined),
   *         changed: boolean}|null}
   */

  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: undefined,
    miterLimit: undefined,
    changed: false
  };
};

_index2.default.inherits(_ol_render_webgl_LineStringReplay_, _replay2.default);
/**
 * Draw one segment.
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */


_ol_render_webgl_LineStringReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var i, ii;
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length; //To save a vertex, the direction of a point is a product of the sign (1 or -1), a prime from
  //ol.render.webgl.LineStringReplay.Instruction_, and a rounding factor (1 or 2). If the product is even,
  //we round it. If it is odd, we don't.

  var lineJoin = this.state_.lineJoin === 'bevel' ? 0 : this.state_.lineJoin === 'miter' ? 1 : 2;
  var lineCap = this.state_.lineCap === 'butt' ? 0 : this.state_.lineCap === 'square' ? 1 : 2;

  var closed = _topology2.default.lineStringIsClosed(flatCoordinates, offset, end, stride);

  var startCoords, sign, n;
  var lastIndex = numIndices;
  var lastSign = 1; //We need the adjacent vertices to define normals in joins. p0 = last, p1 = current, p2 = next.

  var p0, p1, p2;

  for (i = offset, ii = end; i < ii; i += stride) {
    n = numVertices / 7;
    p0 = p1;
    p1 = p2 || [flatCoordinates[i], flatCoordinates[i + 1]]; //First vertex.

    if (i === offset) {
      p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];

      if (end - offset === stride * 2 && _array2.default.equals(p1, p2)) {
        break;
      }

      if (closed) {
        //A closed line! Complete the circle.
        p0 = [flatCoordinates[end - stride * 2], flatCoordinates[end - stride * 2 + 1]];
        startCoords = p2;
      } else {
        //Add the first two/four vertices.
        if (lineCap) {
          numVertices = this.addVertices_([0, 0], p1, p2, lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);
          numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);
          this.indices[numIndices++] = n + 2;
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 3;
          this.indices[numIndices++] = n + 2;
        }

        numVertices = this.addVertices_([0, 0], p1, p2, lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);
        numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);
        lastIndex = numVertices / 7 - 1;
        continue;
      }
    } else if (i === end - stride) {
      //Last vertex.
      if (closed) {
        //Same as the first vertex.
        p2 = startCoords;
        break;
      } else {
        p0 = p0 || [0, 0];
        numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);
        numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);
        this.indices[numIndices++] = n;
        this.indices[numIndices++] = lastIndex - 1;
        this.indices[numIndices++] = lastIndex;
        this.indices[numIndices++] = lastIndex;
        this.indices[numIndices++] = n + 1;
        this.indices[numIndices++] = n;

        if (lineCap) {
          numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);
          numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);
          this.indices[numIndices++] = n + 2;
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 3;
          this.indices[numIndices++] = n + 2;
        }

        break;
      }
    } else {
      p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
    } // We group CW and straight lines, thus the not so inituitive CCW checking function.


    sign = _webgl2.default.triangleIsCounterClockwise(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]) ? -1 : 1;
    numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_SECOND * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, -sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);

    if (i > offset) {
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastIndex - 1;
      this.indices[numIndices++] = lastIndex;
      this.indices[numIndices++] = n + 2;
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
    }

    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 1;
    lastIndex = n + 2;
    lastSign = sign; //Add miter

    if (lineJoin) {
      numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_TOP * lineJoin, numVertices);
      this.indices[numIndices++] = n + 1;
      this.indices[numIndices++] = n + 3;
      this.indices[numIndices++] = n;
    }
  }

  if (closed) {
    n = n || numVertices / 7;
    sign = _orient2.default.linearRingIsClockwise([p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]], 0, 6, 2) ? 1 : -1;
    numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, -sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastIndex - 1;
    this.indices[numIndices++] = lastIndex;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
  }
};
/**
 * @param {Array.<number>} p0 Last coordinates.
 * @param {Array.<number>} p1 Current coordinates.
 * @param {Array.<number>} p2 Next coordinates.
 * @param {number} product Sign, instruction, and rounding product.
 * @param {number} numVertices Vertex counter.
 * @return {number} Vertex counter.
 * @private
 */


_ol_render_webgl_LineStringReplay_.prototype.addVertices_ = function (p0, p1, p2, product, numVertices) {
  this.vertices[numVertices++] = p0[0];
  this.vertices[numVertices++] = p0[1];
  this.vertices[numVertices++] = p1[0];
  this.vertices[numVertices++] = p1[1];
  this.vertices[numVertices++] = p2[0];
  this.vertices[numVertices++] = p2[1];
  this.vertices[numVertices++] = product;
  return numVertices;
};
/**
 * Check if the linestring can be drawn (i. e. valid).
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring can be drawn.
 * @private
 */


_ol_render_webgl_LineStringReplay_.prototype.isValid_ = function (flatCoordinates, offset, end, stride) {
  var range = end - offset;

  if (range < stride * 2) {
    return false;
  } else if (range === stride * 2) {
    var firstP = [flatCoordinates[offset], flatCoordinates[offset + 1]];
    var lastP = [flatCoordinates[offset + stride], flatCoordinates[offset + stride + 1]];
    return !_array2.default.equals(firstP, lastP);
  }

  return true;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();

  if (this.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates = _transform2.default.translate(flatCoordinates, 0, flatCoordinates.length, stride, -this.origin[0], -this.origin[1]);

    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }

    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
  var indexCount = this.indices.length;
  var ends = multiLineStringGeometry.getEnds();
  ends.unshift(0);
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var i, ii;

  if (ends.length > 1) {
    for (i = 1, ii = ends.length; i < ii; ++i) {
      if (this.isValid_(flatCoordinates, ends[i - 1], ends[i], stride)) {
        var lineString = _transform2.default.translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);

        this.drawCoordinates_(lineString, 0, lineString.length, stride);
      }
    }
  }

  if (this.indices.length > indexCount) {
    this.startIndices.push(indexCount);
    this.startIndicesFeature.push(feature);

    if (this.state_.changed) {
      this.styleIndices_.push(indexCount);
      this.state_.changed = false;
    }
  }
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
 * @param {number} stride Stride.
 */


_ol_render_webgl_LineStringReplay_.prototype.drawPolygonCoordinates = function (flatCoordinates, holeFlatCoordinates, stride) {
  if (!_topology2.default.lineStringIsClosed(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates.push(flatCoordinates[0]);
    flatCoordinates.push(flatCoordinates[1]);
  }

  this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);

  if (holeFlatCoordinates.length) {
    var i, ii;

    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      if (!_topology2.default.lineStringIsClosed(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride)) {
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][0]);
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][1]);
      }

      this.drawCoordinates_(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride);
    }
  }
};
/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number=} opt_index Index count.
 */


_ol_render_webgl_LineStringReplay_.prototype.setPolygonStyle = function (feature, opt_index) {
  var index = opt_index === undefined ? this.indices.length : opt_index;
  this.startIndices.push(index);
  this.startIndicesFeature.push(feature);

  if (this.state_.changed) {
    this.styleIndices_.push(index);
    this.state_.changed = false;
  }
};
/**
 * @return {number} Current index.
 */


_ol_render_webgl_LineStringReplay_.prototype.getCurrentIndex = function () {
  return this.indices.length;
};
/**
 * @inheritDoc
 **/


_ol_render_webgl_LineStringReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new _buffer2.default(this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _buffer2.default(this.indices);
  this.startIndices.push(this.indices.length); //Clean up, if there is nothing to draw

  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = _defaultshader2.default.fragment;
  vertexShader = _defaultshader2.default.vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations_) {
    locations = new _locations2.default(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_lastPos);
  gl.vertexAttribPointer(locations.a_lastPos, 2, _webgl4.default.FLOAT, false, 28, 0);
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl4.default.FLOAT, false, 28, 8);
  gl.enableVertexAttribArray(locations.a_nextPos);
  gl.vertexAttribPointer(locations.a_nextPos, 2, _webgl4.default.FLOAT, false, 28, 16);
  gl.enableVertexAttribArray(locations.a_direction);
  gl.vertexAttribPointer(locations.a_direction, 1, _webgl4.default.FLOAT, false, 28, 24); // Enable renderer specific uniforms.

  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_lastPos);
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_nextPos);
  gl.disableVertexAttribArray(locations.a_direction);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  //Save GL parameters.
  var tmpDepthFunc =
  /** @type {number} */
  gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask =
  /** @type {boolean} */
  gl.getParameter(gl.DEPTH_WRITEMASK);

  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }

  if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];

    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      end = start;
    }
  }

  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT); //Restore GL parameters.

    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */


_ol_render_webgl_LineStringReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }

        end = featureStart;
      }

      featureIndex--;
      start = featureStart;
    }

    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }

    start = end = groupStart;
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      featureIndex--;
      end = start;
    }
  }

  return undefined;
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 * @param {number} lineWidth Line width.
 * @param {number} miterLimit Miter limit.
 */


_ol_render_webgl_LineStringReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth, miterLimit) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
  gl.uniform1f(this.defaultLocations_.u_miterLimit, miterLimit);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_LineStringReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var strokeStyleLineCap = strokeStyle.getLineCap();
  this.state_.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _webgl2.default.defaultLineCap;
  var strokeStyleLineDash = strokeStyle.getLineDash();
  this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : _webgl2.default.defaultLineDash;
  var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
  this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _webgl2.default.defaultLineDashOffset;
  var strokeStyleLineJoin = strokeStyle.getLineJoin();
  this.state_.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _webgl2.default.defaultLineJoin;
  var strokeStyleColor = strokeStyle.getColor();

  if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
    strokeStyleColor = _color2.default.asArray(strokeStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || _webgl2.default.defaultStrokeStyle;
  } else {
    strokeStyleColor = _webgl2.default.defaultStrokeStyle;
  }

  var strokeStyleWidth = strokeStyle.getWidth();
  strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _webgl2.default.defaultLineWidth;
  var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
  strokeStyleMiterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _webgl2.default.defaultMiterLimit;

  if (!this.state_.strokeColor || !_array2.default.equals(this.state_.strokeColor, strokeStyleColor) || this.state_.lineWidth !== strokeStyleWidth || this.state_.miterLimit !== strokeStyleMiterLimit) {
    this.state_.changed = true;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.state_.miterLimit = strokeStyleMiterLimit;
    this.styles_.push([strokeStyleColor, strokeStyleWidth, strokeStyleMiterLimit]);
  }
};
/**
 * @enum {number}
 * @private
 */


_ol_render_webgl_LineStringReplay_.Instruction_ = {
  ROUND: 2,
  BEGIN_LINE: 3,
  END_LINE: 5,
  BEGIN_LINE_CAP: 7,
  END_LINE_CAP: 11,
  BEVEL_FIRST: 13,
  BEVEL_SECOND: 17,
  MITER_BOTTOM: 19,
  MITER_TOP: 23
};
exports.default = _ol_render_webgl_LineStringReplay_;

},{"../../array.js":30,"../../color.js":37,"../../extent.js":55,"../../geom/flat/orient.js":70,"../../geom/flat/topology.js":76,"../../geom/flat/transform.js":77,"../../index.js":90,"../../obj.js":125,"../../webgl.js":249,"../../webgl/buffer.js":250,"../webgl.js":166,"../webgl/linestringreplay/defaultshader.js":173,"../webgl/linestringreplay/defaultshader/locations.js":174,"../webgl/replay.js":178}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../index.js");

var _index2 = _interopRequireDefault(_index);

var _fragment = require("../../../webgl/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require("../../../webgl/vertex.js");

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit
var _ol_render_webgl_linestringreplay_defaultshader_ = {};
_ol_render_webgl_linestringreplay_defaultshader_.fragment = new _fragment2.default(_index2.default.DEBUG_WEBGL ? 'precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;varying float a;varying vec2 aVertex;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((aVertex.x+1.0)/2.0*o.x*p,(aVertex.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');
_ol_render_webgl_linestringreplay_defaultshader_.vertex = new _vertex2.default(_index2.default.DEBUG_WEBGL ? 'varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nbool nearlyEquals(in float value, in float ref) {\n  float epsilon = 0.000000000001;\n  return value >= ref - epsilon && value <= ref + epsilon;\n}\n\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\n  vec2 dirVect = nextP - a_position;\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\n  offset = u_lineWidth / 2.0 * normal * direction;\n}\n\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\n  float halfWidth = u_lineWidth / 2.0;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_nextPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n  offset = normal * direction * miterLength;\n  round = 0.0;\n  if (isRound) {\n    round = 1.0;\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\n    offset = halfWidth * tmpNormal * direction;\n  }\n}\n\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\n  bool degenerate = false;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_lastPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  vec2 longOffset, shortOffset, longVertex;\n  vec4 shortProjVertex;\n  float halfWidth = u_lineWidth / 2.0;\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n    longOffset = tmpNormal * direction * halfWidth;\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_nextPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\n  } else {\n    shortOffset = tmpNormal * direction * halfWidth;\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_lastPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\n  }\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  float epsilon = 0.000000000001;\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\n    offset = shortProjVertex.xy;\n    degenerate = true;\n  } else {\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n    offset = normal * direction * miterLength;\n  }\n  return degenerate;\n}\n\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\n    in float turnDir, in float direction) {\n  round = 0.0;\n  vec2 dirVect = a_position - nextP;\n  vec2 firstNormal = normalize(dirVect);\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n  offset = normal * length;\n  if (isRound) {\n    round = 1.0;\n  }\n}\n\nvoid main(void) {\n  bool degenerate = false;\n  float direction = float(sign(a_direction));\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  vec2 offset;\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\n\n  v_round = 0.0;\n  v_halfWidth = u_lineWidth / 2.0;\n  v_roundVertex = projPos.xy;\n\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\n    alongNormal(offset, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\n    alongNormal(offset, a_lastPos, -1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\n    miterUp(offset, v_round, round, direction);\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\n  }\n  if (!degenerate) {\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\n    gl_Position = projPos + offsets;\n  } else {\n    gl_Position = vec4(offset, 0.0, 1.0);\n  }\n}\n\n\n' : 'varying float a;varying vec2 aVertex;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;aVertex=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}');
exports.default = _ol_render_webgl_linestringreplay_defaultshader_;

},{"../../../index.js":90,"../../../webgl/fragment.js":253,"../../../webgl/vertex.js":255}],174:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../../index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var _ol_render_webgl_linestringreplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_lineWidth = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_lineWidth' : 'k');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_miterLimit = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_miterLimit' : 'l');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'm');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_color = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_color' : 'n');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_size = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_size' : 'o');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_pixelRatio = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_pixelRatio' : 'p');
  /**
   * @type {number}
   */

  this.a_lastPos = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_lastPos' : 'd');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'e');
  /**
   * @type {number}
   */

  this.a_nextPos = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_nextPos' : 'f');
  /**
   * @type {number}
   */

  this.a_direction = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_direction' : 'g');
};

exports.default = _ol_render_webgl_linestringreplay_defaultshader_Locations_;

},{"../../../../index.js":90}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _color = require("../../color.js");

var _color2 = _interopRequireDefault(_color);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _contains = require("../../geom/flat/contains.js");

var _contains2 = _interopRequireDefault(_contains);

var _orient = require("../../geom/flat/orient.js");

var _orient2 = _interopRequireDefault(_orient);

var _transform = require("../../geom/flat/transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _defaultshader = require("../webgl/polygonreplay/defaultshader.js");

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _locations = require("../webgl/polygonreplay/defaultshader/locations.js");

var _locations2 = _interopRequireDefault(_locations);

var _linestringreplay = require("../webgl/linestringreplay.js");

var _linestringreplay2 = _interopRequireDefault(_linestringreplay);

var _replay = require("../webgl/replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _stroke = require("../../style/stroke.js");

var _stroke2 = _interopRequireDefault(_stroke);

var _linkedlist = require("../../structs/linkedlist.js");

var _linkedlist2 = _interopRequireDefault(_linkedlist);

var _rbush = require("../../structs/rbush.js");

var _rbush2 = _interopRequireDefault(_rbush);

var _webgl3 = require("../../webgl.js");

var _webgl4 = _interopRequireDefault(_webgl3);

var _buffer = require("../../webgl/buffer.js");

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var _ol_render_webgl_PolygonReplay_ = function (tolerance, maxExtent) {
  _replay2.default.call(this, tolerance, maxExtent);

  this.lineStringReplay = new _linestringreplay2.default(tolerance, maxExtent);
  /**
   * @private
   * @type {ol.render.webgl.polygonreplay.defaultshader.Locations}
   */

  this.defaultLocations_ = null;
  /**
   * @private
   * @type {Array.<Array.<number>>}
   */

  this.styles_ = [];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.styleIndices_ = [];
  /**
   * @private
   * @type {{fillColor: (Array.<number>|null),
   *         changed: boolean}|null}
   */

  this.state_ = {
    fillColor: null,
    changed: false
  };
};

_index2.default.inherits(_ol_render_webgl_PolygonReplay_, _replay2.default);
/**
 * Draw one polygon.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
 * @param {number} stride Stride.
 * @private
 */


_ol_render_webgl_PolygonReplay_.prototype.drawCoordinates_ = function (flatCoordinates, holeFlatCoordinates, stride) {
  // Triangulate the polygon
  var outerRing = new _linkedlist2.default();
  var rtree = new _rbush2.default(); // Initialize the outer ring

  this.processFlatCoordinates_(flatCoordinates, stride, outerRing, rtree, true);
  var maxCoords = this.getMaxCoords_(outerRing); // Eliminate holes, if there are any

  if (holeFlatCoordinates.length) {
    var i, ii;
    var holeLists = [];

    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      var holeList = {
        list: new _linkedlist2.default(),
        maxCoords: undefined,
        rtree: new _rbush2.default()
      };
      holeLists.push(holeList);
      this.processFlatCoordinates_(holeFlatCoordinates[i], stride, holeList.list, holeList.rtree, false);
      this.classifyPoints_(holeList.list, holeList.rtree, true);
      holeList.maxCoords = this.getMaxCoords_(holeList.list);
    }

    holeLists.sort(function (a, b) {
      return b.maxCoords[0] === a.maxCoords[0] ? a.maxCoords[1] - b.maxCoords[1] : b.maxCoords[0] - a.maxCoords[0];
    });

    for (i = 0; i < holeLists.length; ++i) {
      var currList = holeLists[i].list;
      var start = currList.firstItem();
      var currItem = start;
      var intersection;

      do {
        //TODO: Triangulate holes when they intersect the outer ring.
        if (this.getIntersections_(currItem, rtree).length) {
          intersection = true;
          break;
        }

        currItem = currList.nextItem();
      } while (start !== currItem);

      if (!intersection) {
        if (this.bridgeHole_(currList, holeLists[i].maxCoords[0], outerRing, maxCoords[0], rtree)) {
          rtree.concat(holeLists[i].rtree);
          this.classifyPoints_(outerRing, rtree, false);
        }
      }
    }
  } else {
    this.classifyPoints_(outerRing, rtree, false);
  }

  this.triangulate_(outerRing, rtree);
};
/**
 * Inserts flat coordinates in a linked list and adds them to the vertex buffer.
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} stride Stride.
 * @param {ol.structs.LinkedList} list Linked list.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} clockwise Coordinate order should be clockwise.
 */


_ol_render_webgl_PolygonReplay_.prototype.processFlatCoordinates_ = function (flatCoordinates, stride, list, rtree, clockwise) {
  var isClockwise = _orient2.default.linearRingIsClockwise(flatCoordinates, 0, flatCoordinates.length, stride);

  var i, ii;
  var n = this.vertices.length / 2;
  /** @type {ol.WebglPolygonVertex} */

  var start;
  /** @type {ol.WebglPolygonVertex} */

  var p0;
  /** @type {ol.WebglPolygonVertex} */

  var p1;
  var extents = [];
  var segments = [];

  if (clockwise === isClockwise) {
    start = this.createPoint_(flatCoordinates[0], flatCoordinates[1], n++);
    p0 = start;

    for (i = stride, ii = flatCoordinates.length; i < ii; i += stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }

    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  } else {
    var end = flatCoordinates.length - stride;
    start = this.createPoint_(flatCoordinates[end], flatCoordinates[end + 1], n++);
    p0 = start;

    for (i = end - stride, ii = 0; i >= ii; i -= stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }

    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  }

  rtree.load(extents, segments);
};
/**
 * Returns the rightmost coordinates of a polygon on the X axis.
 * @private
 * @param {ol.structs.LinkedList} list Polygons ring.
 * @return {Array.<number>} Max X coordinates.
 */


_ol_render_webgl_PolygonReplay_.prototype.getMaxCoords_ = function (list) {
  var start = list.firstItem();
  var seg = start;
  var maxCoords = [seg.p0.x, seg.p0.y];

  do {
    seg = list.nextItem();

    if (seg.p0.x > maxCoords[0]) {
      maxCoords = [seg.p0.x, seg.p0.y];
    }
  } while (seg !== start);

  return maxCoords;
};
/**
 * Classifies the points of a polygon list as convex, reflex. Removes collinear vertices.
 * @private
 * @param {ol.structs.LinkedList} list Polygon ring.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} ccw The orientation of the polygon is counter-clockwise.
 * @return {boolean} There were reclassified points.
 */


_ol_render_webgl_PolygonReplay_.prototype.classifyPoints_ = function (list, rtree, ccw) {
  var start = list.firstItem();
  var s0 = start;
  var s1 = list.nextItem();
  var pointsReclassified = false;

  do {
    var reflex = ccw ? _webgl2.default.triangleIsCounterClockwise(s1.p1.x, s1.p1.y, s0.p1.x, s0.p1.y, s0.p0.x, s0.p0.y) : _webgl2.default.triangleIsCounterClockwise(s0.p0.x, s0.p0.y, s0.p1.x, s0.p1.y, s1.p1.x, s1.p1.y);

    if (reflex === undefined) {
      this.removeItem_(s0, s1, list, rtree);
      pointsReclassified = true;

      if (s1 === start) {
        start = list.getNextItem();
      }

      s1 = s0;
      list.prevItem();
    } else if (s0.p1.reflex !== reflex) {
      s0.p1.reflex = reflex;
      pointsReclassified = true;
    }

    s0 = s1;
    s1 = list.nextItem();
  } while (s0 !== start);

  return pointsReclassified;
};
/**
 * @private
 * @param {ol.structs.LinkedList} hole Linked list of the hole.
 * @param {number} holeMaxX Maximum X value of the hole.
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {number} listMaxX Maximum X value of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @return {boolean} Bridging was successful.
 */


_ol_render_webgl_PolygonReplay_.prototype.bridgeHole_ = function (hole, holeMaxX, list, listMaxX, rtree) {
  var seg = hole.firstItem();

  while (seg.p1.x !== holeMaxX) {
    seg = hole.nextItem();
  }

  var p1 = seg.p1;
  /** @type {ol.WebglPolygonVertex} */

  var p2 = {
    x: listMaxX,
    y: p1.y,
    i: -1
  };
  var minDist = Infinity;
  var i, ii, bestPoint;
  /** @type {ol.WebglPolygonVertex} */

  var p5;
  var intersectingSegments = this.getIntersections_({
    p0: p1,
    p1: p2
  }, rtree, true);

  for (i = 0, ii = intersectingSegments.length; i < ii; ++i) {
    var currSeg = intersectingSegments[i];
    var intersection = this.calculateIntersection_(p1, p2, currSeg.p0, currSeg.p1, true);
    var dist = Math.abs(p1.x - intersection[0]);

    if (dist < minDist && _webgl2.default.triangleIsCounterClockwise(p1.x, p1.y, currSeg.p0.x, currSeg.p0.y, currSeg.p1.x, currSeg.p1.y) !== undefined) {
      minDist = dist;
      p5 = {
        x: intersection[0],
        y: intersection[1],
        i: -1
      };
      seg = currSeg;
    }
  }

  if (minDist === Infinity) {
    return false;
  }

  bestPoint = seg.p1;

  if (minDist > 0) {
    var pointsInTriangle = this.getPointsInTriangle_(p1, p5, seg.p1, rtree);

    if (pointsInTriangle.length) {
      var theta = Infinity;

      for (i = 0, ii = pointsInTriangle.length; i < ii; ++i) {
        var currPoint = pointsInTriangle[i];
        var currTheta = Math.atan2(p1.y - currPoint.y, p2.x - currPoint.x);

        if (currTheta < theta || currTheta === theta && currPoint.x < bestPoint.x) {
          theta = currTheta;
          bestPoint = currPoint;
        }
      }
    }
  }

  seg = list.firstItem();

  while (seg.p1.x !== bestPoint.x || seg.p1.y !== bestPoint.y) {
    seg = list.nextItem();
  } //We clone the bridge points as they can have different convexity.


  var p0Bridge = {
    x: p1.x,
    y: p1.y,
    i: p1.i,
    reflex: undefined
  };
  var p1Bridge = {
    x: seg.p1.x,
    y: seg.p1.y,
    i: seg.p1.i,
    reflex: undefined
  };
  hole.getNextItem().p0 = p0Bridge;
  this.insertItem_(p1, seg.p1, hole, rtree);
  this.insertItem_(p1Bridge, p0Bridge, hole, rtree);
  seg.p1 = p1Bridge;
  hole.setFirstItem();
  list.concat(hole);
  return true;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 */


_ol_render_webgl_PolygonReplay_.prototype.triangulate_ = function (list, rtree) {
  var ccw = false;
  var simple = this.isSimple_(list, rtree); // Start clipping ears

  while (list.getLength() > 3) {
    if (simple) {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        if (!this.classifyPoints_(list, rtree, ccw)) {
          // Due to the behavior of OL's PIP algorithm, the ear clipping cannot
          // introduce touching segments. However, the original data may have some.
          if (!this.resolveSelfIntersections_(list, rtree, true)) {
            break;
          }
        }
      }
    } else {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        // We ran out of ears, try to reclassify.
        if (!this.classifyPoints_(list, rtree, ccw)) {
          // We have a bad polygon, try to resolve local self-intersections.
          if (!this.resolveSelfIntersections_(list, rtree)) {
            simple = this.isSimple_(list, rtree);

            if (!simple) {
              // We have a really bad polygon, try more time consuming methods.
              this.splitPolygon_(list, rtree);
              break;
            } else {
              ccw = !this.isClockwise_(list);
              this.classifyPoints_(list, rtree, ccw);
            }
          }
        }
      }
    }
  }

  if (list.getLength() === 3) {
    var numIndices = this.indices.length;
    this.indices[numIndices++] = list.getPrevItem().p0.i;
    this.indices[numIndices++] = list.getCurrItem().p0.i;
    this.indices[numIndices++] = list.getNextItem().p0.i;
  }
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} simple The polygon is simple.
 * @param {boolean} ccw Orientation of the polygon is counter-clockwise.
 * @return {boolean} There were processed ears.
 */


_ol_render_webgl_PolygonReplay_.prototype.clipEars_ = function (list, rtree, simple, ccw) {
  var numIndices = this.indices.length;
  var start = list.firstItem();
  var s0 = list.getPrevItem();
  var s1 = start;
  var s2 = list.nextItem();
  var s3 = list.getNextItem();
  var p0, p1, p2;
  var processedEars = false;

  do {
    p0 = s1.p0;
    p1 = s1.p1;
    p2 = s2.p1;

    if (p1.reflex === false) {
      // We might have a valid ear
      var variableCriterion;

      if (simple) {
        variableCriterion = this.getPointsInTriangle_(p0, p1, p2, rtree, true).length === 0;
      } else {
        variableCriterion = ccw ? this.diagonalIsInside_(s3.p1, p2, p1, p0, s0.p0) : this.diagonalIsInside_(s0.p0, p0, p1, p2, s3.p1);
      }

      if ((simple || this.getIntersections_({
        p0: p0,
        p1: p2
      }, rtree).length === 0) && variableCriterion) {
        //The diagonal is completely inside the polygon
        if (simple || p0.reflex === false || p2.reflex === false || _orient2.default.linearRingIsClockwise([s0.p0.x, s0.p0.y, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, s3.p1.x, s3.p1.y], 0, 10, 2) === !ccw) {
          //The diagonal is persumably valid, we have an ear
          this.indices[numIndices++] = p0.i;
          this.indices[numIndices++] = p1.i;
          this.indices[numIndices++] = p2.i;
          this.removeItem_(s1, s2, list, rtree);

          if (s2 === start) {
            start = s3;
          }

          processedEars = true;
        }
      }
    } // Else we have a reflex point.


    s0 = list.getPrevItem();
    s1 = list.getCurrItem();
    s2 = list.nextItem();
    s3 = list.getNextItem();
  } while (s1 !== start && list.getLength() > 3);

  return processedEars;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_touch Resolve touching segments.
 * @return {boolean} There were resolved intersections.
*/


_ol_render_webgl_PolygonReplay_.prototype.resolveSelfIntersections_ = function (list, rtree, opt_touch) {
  var start = list.firstItem();
  list.nextItem();
  var s0 = start;
  var s1 = list.nextItem();
  var resolvedIntersections = false;

  do {
    var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1, opt_touch);

    if (intersection) {
      var breakCond = false;
      var numVertices = this.vertices.length;
      var numIndices = this.indices.length;
      var n = numVertices / 2;
      var seg = list.prevItem();
      list.removeItem();
      rtree.remove(seg);
      breakCond = seg === start;
      var p;

      if (opt_touch) {
        if (intersection[0] === s0.p0.x && intersection[1] === s0.p0.y) {
          list.prevItem();
          p = s0.p0;
          s1.p0 = p;
          rtree.remove(s0);
          breakCond = breakCond || s0 === start;
        } else {
          p = s1.p1;
          s0.p1 = p;
          rtree.remove(s1);
          breakCond = breakCond || s1 === start;
        }

        list.removeItem();
      } else {
        p = this.createPoint_(intersection[0], intersection[1], n);
        s0.p1 = p;
        s1.p0 = p;
        rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
        rtree.update([Math.min(s1.p0.x, s1.p1.x), Math.min(s1.p0.y, s1.p1.y), Math.max(s1.p0.x, s1.p1.x), Math.max(s1.p0.y, s1.p1.y)], s1);
      }

      this.indices[numIndices++] = seg.p0.i;
      this.indices[numIndices++] = seg.p1.i;
      this.indices[numIndices++] = p.i;
      resolvedIntersections = true;

      if (breakCond) {
        break;
      }
    }

    s0 = list.getPrevItem();
    s1 = list.nextItem();
  } while (s0 !== start);

  return resolvedIntersections;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @return {boolean} The polygon is simple.
 */


_ol_render_webgl_PolygonReplay_.prototype.isSimple_ = function (list, rtree) {
  var start = list.firstItem();
  var seg = start;

  do {
    if (this.getIntersections_(seg, rtree).length) {
      return false;
    }

    seg = list.nextItem();
  } while (seg !== start);

  return true;
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @return {boolean} Orientation is clockwise.
 */


_ol_render_webgl_PolygonReplay_.prototype.isClockwise_ = function (list) {
  var length = list.getLength() * 2;
  var flatCoordinates = new Array(length);
  var start = list.firstItem();
  var seg = start;
  var i = 0;

  do {
    flatCoordinates[i++] = seg.p0.x;
    flatCoordinates[i++] = seg.p0.y;
    seg = list.nextItem();
  } while (seg !== start);

  return _orient2.default.linearRingIsClockwise(flatCoordinates, 0, length, 2);
};
/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 */


_ol_render_webgl_PolygonReplay_.prototype.splitPolygon_ = function (list, rtree) {
  var start = list.firstItem();
  var s0 = start;

  do {
    var intersections = this.getIntersections_(s0, rtree);

    if (intersections.length) {
      var s1 = intersections[0];
      var n = this.vertices.length / 2;
      var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1);
      var p = this.createPoint_(intersection[0], intersection[1], n);
      var newPolygon = new _linkedlist2.default();
      var newRtree = new _rbush2.default();
      this.insertItem_(p, s0.p1, newPolygon, newRtree);
      s0.p1 = p;
      rtree.update([Math.min(s0.p0.x, p.x), Math.min(s0.p0.y, p.y), Math.max(s0.p0.x, p.x), Math.max(s0.p0.y, p.y)], s0);
      var currItem = list.nextItem();

      while (currItem !== s1) {
        this.insertItem_(currItem.p0, currItem.p1, newPolygon, newRtree);
        rtree.remove(currItem);
        list.removeItem();
        currItem = list.getCurrItem();
      }

      this.insertItem_(s1.p0, p, newPolygon, newRtree);
      s1.p0 = p;
      rtree.update([Math.min(s1.p1.x, p.x), Math.min(s1.p1.y, p.y), Math.max(s1.p1.x, p.x), Math.max(s1.p1.y, p.y)], s1);
      this.classifyPoints_(list, rtree, false);
      this.triangulate_(list, rtree);
      this.classifyPoints_(newPolygon, newRtree, false);
      this.triangulate_(newPolygon, newRtree);
      break;
    }

    s0 = list.nextItem();
  } while (s0 !== start);
};
/**
 * @private
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} i Index.
 * @return {ol.WebglPolygonVertex} List item.
 */


_ol_render_webgl_PolygonReplay_.prototype.createPoint_ = function (x, y, i) {
  var numVertices = this.vertices.length;
  this.vertices[numVertices++] = x;
  this.vertices[numVertices++] = y;
  /** @type {ol.WebglPolygonVertex} */

  var p = {
    x: x,
    y: y,
    i: i,
    reflex: undefined
  };
  return p;
};
/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point of segment.
 * @param {ol.WebglPolygonVertex} p1 Second point of segment.
 * @param {ol.structs.LinkedList} list Polygon ring.
 * @param {ol.structs.RBush=} opt_rtree Insert the segment into the R-Tree.
 * @return {ol.WebglPolygonSegment} segment.
 */


_ol_render_webgl_PolygonReplay_.prototype.insertItem_ = function (p0, p1, list, opt_rtree) {
  var seg = {
    p0: p0,
    p1: p1
  };
  list.insertItem(seg);

  if (opt_rtree) {
    opt_rtree.insert([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)], seg);
  }

  return seg;
};
/**
  * @private
  * @param {ol.WebglPolygonSegment} s0 Segment before the remove candidate.
  * @param {ol.WebglPolygonSegment} s1 Remove candidate segment.
  * @param {ol.structs.LinkedList} list Polygon ring.
  * @param {ol.structs.RBush} rtree R-Tree of the polygon.
  */


_ol_render_webgl_PolygonReplay_.prototype.removeItem_ = function (s0, s1, list, rtree) {
  if (list.getCurrItem() === s1) {
    list.removeItem();
    s0.p1 = s1.p1;
    rtree.remove(s1);
    rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
  }
};
/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point.
 * @param {ol.WebglPolygonVertex} p1 Second point.
 * @param {ol.WebglPolygonVertex} p2 Third point.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_reflex Only include reflex points.
 * @return {Array.<ol.WebglPolygonVertex>} Points in the triangle.
 */


_ol_render_webgl_PolygonReplay_.prototype.getPointsInTriangle_ = function (p0, p1, p2, rtree, opt_reflex) {
  var i, ii, j, p;
  var result = [];
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y), Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y)]);

  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    for (j in segmentsInExtent[i]) {
      p = segmentsInExtent[i][j];

      if (typeof p === 'object' && (!opt_reflex || p.reflex)) {
        if ((p.x !== p0.x || p.y !== p0.y) && (p.x !== p1.x || p.y !== p1.y) && (p.x !== p2.x || p.y !== p2.y) && result.indexOf(p) === -1 && _contains2.default.linearRingContainsXY([p0.x, p0.y, p1.x, p1.y, p2.x, p2.y], 0, 6, 2, p.x, p.y)) {
          result.push(p);
        }
      }
    }
  }

  return result;
};
/**
 * @private
 * @param {ol.WebglPolygonSegment} segment Segment.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_touch Touching segments should be considered an intersection.
 * @return {Array.<ol.WebglPolygonSegment>} Intersecting segments.
 */


_ol_render_webgl_PolygonReplay_.prototype.getIntersections_ = function (segment, rtree, opt_touch) {
  var p0 = segment.p0;
  var p1 = segment.p1;
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  var result = [];
  var i, ii;

  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    var currSeg = segmentsInExtent[i];

    if (segment !== currSeg && (opt_touch || currSeg.p0 !== p1 || currSeg.p1 !== p0) && this.calculateIntersection_(p0, p1, currSeg.p0, currSeg.p1, opt_touch)) {
      result.push(currSeg);
    }
  }

  return result;
};
/**
 * Line intersection algorithm by Paul Bourke.
 * @see http://paulbourke.net/geometry/pointlineplane/
 *
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point.
 * @param {ol.WebglPolygonVertex} p1 Second point.
 * @param {ol.WebglPolygonVertex} p2 Third point.
 * @param {ol.WebglPolygonVertex} p3 Fourth point.
 * @param {boolean=} opt_touch Touching segments should be considered an intersection.
 * @return {Array.<number>|undefined} Intersection coordinates.
 */


_ol_render_webgl_PolygonReplay_.prototype.calculateIntersection_ = function (p0, p1, p2, p3, opt_touch) {
  var denom = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y);

  if (denom !== 0) {
    var ua = ((p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x)) / denom;
    var ub = ((p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x)) / denom;

    if (!opt_touch && ua > _webgl2.default.EPSILON && ua < 1 - _webgl2.default.EPSILON && ub > _webgl2.default.EPSILON && ub < 1 - _webgl2.default.EPSILON || opt_touch && ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return [p0.x + ua * (p1.x - p0.x), p0.y + ua * (p1.y - p0.y)];
    }
  }

  return undefined;
};
/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 Point before the start of the diagonal.
 * @param {ol.WebglPolygonVertex} p1 Start point of the diagonal.
 * @param {ol.WebglPolygonVertex} p2 Ear candidate.
 * @param {ol.WebglPolygonVertex} p3 End point of the diagonal.
 * @param {ol.WebglPolygonVertex} p4 Point after the end of the diagonal.
 * @return {boolean} Diagonal is inside the polygon.
 */


_ol_render_webgl_PolygonReplay_.prototype.diagonalIsInside_ = function (p0, p1, p2, p3, p4) {
  if (p1.reflex === undefined || p3.reflex === undefined) {
    return false;
  }

  var p1IsLeftOf = (p2.x - p3.x) * (p1.y - p3.y) > (p2.y - p3.y) * (p1.x - p3.x);
  var p1IsRightOf = (p4.x - p3.x) * (p1.y - p3.y) < (p4.y - p3.y) * (p1.x - p3.x);
  var p3IsLeftOf = (p0.x - p1.x) * (p3.y - p1.y) > (p0.y - p1.y) * (p3.x - p1.x);
  var p3IsRightOf = (p2.x - p1.x) * (p3.y - p1.y) < (p2.y - p1.y) * (p3.x - p1.x);
  var p1InCone = p3.reflex ? p1IsRightOf || p1IsLeftOf : p1IsRightOf && p1IsLeftOf;
  var p3InCone = p1.reflex ? p3IsRightOf || p3IsLeftOf : p3IsRightOf && p3IsLeftOf;
  return p1InCone && p3InCone;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
  var endss = multiPolygonGeometry.getEndss();
  var stride = multiPolygonGeometry.getStride();
  var currIndex = this.indices.length;
  var currLineIndex = this.lineStringReplay.getCurrentIndex();
  var flatCoordinates = multiPolygonGeometry.getFlatCoordinates();
  var i, ii, j, jj;
  var start = 0;

  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (ends.length > 0) {
      var outerRing = _transform2.default.translate(flatCoordinates, start, ends[0], stride, -this.origin[0], -this.origin[1]);

      if (outerRing.length) {
        var holes = [];
        var holeFlatCoords;

        for (j = 1, jj = ends.length; j < jj; ++j) {
          if (ends[j] !== ends[j - 1]) {
            holeFlatCoords = _transform2.default.translate(flatCoordinates, ends[j - 1], ends[j], stride, -this.origin[0], -this.origin[1]);
            holes.push(holeFlatCoords);
          }
        }

        this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
        this.drawCoordinates_(outerRing, holes, stride);
      }
    }

    start = ends[ends.length - 1];
  }

  if (this.indices.length > currIndex) {
    this.startIndices.push(currIndex);
    this.startIndicesFeature.push(feature);

    if (this.state_.changed) {
      this.styleIndices_.push(currIndex);
      this.state_.changed = false;
    }
  }

  if (this.lineStringReplay.getCurrentIndex() > currLineIndex) {
    this.lineStringReplay.setPolygonStyle(feature, currLineIndex);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
  var ends = polygonGeometry.getEnds();
  var stride = polygonGeometry.getStride();

  if (ends.length > 0) {
    var flatCoordinates = polygonGeometry.getFlatCoordinates().map(Number);

    var outerRing = _transform2.default.translate(flatCoordinates, 0, ends[0], stride, -this.origin[0], -this.origin[1]);

    if (outerRing.length) {
      var holes = [];
      var i, ii, holeFlatCoords;

      for (i = 1, ii = ends.length; i < ii; ++i) {
        if (ends[i] !== ends[i - 1]) {
          holeFlatCoords = _transform2.default.translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);
          holes.push(holeFlatCoords);
        }
      }

      this.startIndices.push(this.indices.length);
      this.startIndicesFeature.push(feature);

      if (this.state_.changed) {
        this.styleIndices_.push(this.indices.length);
        this.state_.changed = false;
      }

      this.lineStringReplay.setPolygonStyle(feature);
      this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
      this.drawCoordinates_(outerRing, holes, stride);
    }
  }
};
/**
 * @inheritDoc
 **/


_ol_render_webgl_PolygonReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new _buffer2.default(this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _buffer2.default(this.indices);
  this.startIndices.push(this.indices.length);
  this.lineStringReplay.finish(context); //Clean up, if there is nothing to draw

  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var lineDeleter = this.lineStringReplay.getDeleteResourcesFunction(context);
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
    lineDeleter();
  };
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = _defaultshader2.default.fragment;
  vertexShader = _defaultshader2.default.vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations_) {
    locations = new _locations2.default(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl4.default.FLOAT, false, 8, 0);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  //Save GL parameters.
  var tmpDepthFunc =
  /** @type {number} */
  gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask =
  /** @type {boolean} */
  gl.getParameter(gl.DEPTH_WRITEMASK);

  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }

  if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];

    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl, nextStyle);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }

  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT); //Restore GL parameters.

    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      featureIndex--;
      end = start;
    }
  }

  return undefined;
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */


_ol_render_webgl_PolygonReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];

  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }

        end = featureStart;
      }

      featureIndex--;
      start = featureStart;
    }

    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }

    start = end = groupStart;
  }
};
/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 */


_ol_render_webgl_PolygonReplay_.prototype.setFillStyle_ = function (gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_PolygonReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];

  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = _color2.default.asArray(fillStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || _webgl2.default.defaultFillStyle;
  } else {
    fillStyleColor = _webgl2.default.defaultFillStyle;
  }

  if (!this.state_.fillColor || !_array2.default.equals(fillStyleColor, this.state_.fillColor)) {
    this.state_.fillColor = fillStyleColor;
    this.state_.changed = true;
    this.styles_.push(fillStyleColor);
  } //Provide a null stroke style, if no strokeStyle is provided. Required for the draw interaction to work.


  if (strokeStyle) {
    this.lineStringReplay.setFillStrokeStyle(null, strokeStyle);
  } else {
    var nullStrokeStyle = new _stroke2.default({
      color: [0, 0, 0, 0],
      lineWidth: 0
    });
    this.lineStringReplay.setFillStrokeStyle(null, nullStrokeStyle);
  }
};

exports.default = _ol_render_webgl_PolygonReplay_;

},{"../../array.js":30,"../../color.js":37,"../../extent.js":55,"../../geom/flat/contains.js":64,"../../geom/flat/orient.js":70,"../../geom/flat/transform.js":77,"../../index.js":90,"../../obj.js":125,"../../structs/linkedlist.js":218,"../../structs/rbush.js":221,"../../style/stroke.js":234,"../../webgl.js":249,"../../webgl/buffer.js":250,"../webgl.js":166,"../webgl/linestringreplay.js":172,"../webgl/polygonreplay/defaultshader.js":176,"../webgl/polygonreplay/defaultshader/locations.js":177,"../webgl/replay.js":178}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../index.js");

var _index2 = _interopRequireDefault(_index);

var _fragment = require("../../../webgl/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require("../../../webgl/vertex.js");

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit
var _ol_render_webgl_polygonreplay_defaultshader_ = {};
_ol_render_webgl_polygonreplay_defaultshader_.fragment = new _fragment2.default(_index2.default.DEBUG_WEBGL ? 'precision mediump float;\n\n\n\nuniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');
_ol_render_webgl_polygonreplay_defaultshader_.vertex = new _vertex2.default(_index2.default.DEBUG_WEBGL ? '\n\nattribute vec2 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n}\n\n\n' : 'attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}');
exports.default = _ol_render_webgl_polygonreplay_defaultshader_;

},{"../../../index.js":90,"../../../webgl/fragment.js":253,"../../../webgl/vertex.js":255}],177:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../../index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var _ol_render_webgl_polygonreplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'b');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'c');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'd');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_color = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_color' : 'e');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'f');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'a');
};

exports.default = _ol_render_webgl_polygonreplay_defaultshader_Locations_;

},{"../../../../index.js":90}],178:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _vectorcontext = require("../vectorcontext.js");

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _mat = require("../../vec/mat4.js");

var _mat2 = _interopRequireDefault(_mat);

var _webgl = require("../../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var _ol_render_webgl_Replay_ = function (tolerance, maxExtent) {
  _vectorcontext2.default.call(this);
  /**
   * @protected
   * @type {number}
   */


  this.tolerance = tolerance;
  /**
   * @protected
   * @const
   * @type {ol.Extent}
   */

  this.maxExtent = maxExtent;
  /**
   * The origin of the coordinate system for the point coordinates sent to
   * the GPU. To eliminate jitter caused by precision problems in the GPU
   * we use the "Rendering Relative to Eye" technique described in the "3D
   * Engine Design for Virtual Globes" book.
   * @protected
   * @type {ol.Coordinate}
   */

  this.origin = _extent2.default.getCenter(maxExtent);
  /**
   * @private
   * @type {ol.Transform}
   */

  this.projectionMatrix_ = _transform2.default.create();
  /**
   * @private
   * @type {ol.Transform}
   */

  this.offsetRotateMatrix_ = _transform2.default.create();
  /**
   * @private
   * @type {ol.Transform}
   */

  this.offsetScaleMatrix_ = _transform2.default.create();
  /**
   * @private
   * @type {Array.<number>}
   */

  this.tmpMat4_ = _mat2.default.create();
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.indices = [];
  /**
   * @protected
   * @type {?ol.webgl.Buffer}
   */

  this.indicesBuffer = null;
  /**
   * Start index per feature (the index).
   * @protected
   * @type {Array.<number>}
   */

  this.startIndices = [];
  /**
   * Start index per feature (the feature).
   * @protected
   * @type {Array.<ol.Feature|ol.render.Feature>}
   */

  this.startIndicesFeature = [];
  /**
   * @protected
   * @type {Array.<number>}
   */

  this.vertices = [];
  /**
   * @protected
   * @type {?ol.webgl.Buffer}
   */

  this.verticesBuffer = null;
  /**
   * Optional parameter for PolygonReplay instances.
   * @protected
   * @type {ol.render.webgl.LineStringReplay|undefined}
   */

  this.lineStringReplay = undefined;
};

_index2.default.inherits(_ol_render_webgl_Replay_, _vectorcontext2.default);
/**
 * @abstract
 * @param {ol.webgl.Context} context WebGL context.
 * @return {function()} Delete resources function.
 */


_ol_render_webgl_Replay_.prototype.getDeleteResourcesFunction = function (context) {};
/**
 * @abstract
 * @param {ol.webgl.Context} context Context.
 */


_ol_render_webgl_Replay_.prototype.finish = function (context) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @return {ol.render.webgl.circlereplay.defaultshader.Locations|
            ol.render.webgl.linestringreplay.defaultshader.Locations|
            ol.render.webgl.polygonreplay.defaultshader.Locations|
            ol.render.webgl.texturereplay.defaultshader.Locations} Locations.
 */


_ol_render_webgl_Replay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.render.webgl.circlereplay.defaultshader.Locations|
           ol.render.webgl.linestringreplay.defaultshader.Locations|
           ol.render.webgl.polygonreplay.defaultshader.Locations|
           ol.render.webgl.texturereplay.defaultshader.Locations} locations Locations.
 */


_ol_render_webgl_Replay_.prototype.shutDownProgram = function (gl, locations) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {boolean} hitDetection Hit detection mode.
 */


_ol_render_webgl_Replay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {};
/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {};
/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.drawHitDetectionReplay = function (gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  if (!oneByOne) {
    // draw all hit-detection features in "once" (by texture group)
    return this.drawHitDetectionReplayAll(gl, context, skippedFeaturesHash, featureCallback);
  } else {
    // draw hit-detection features one by one
    return this.drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent);
  }
};
/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.drawHitDetectionReplayAll = function (gl, context, skippedFeaturesHash, featureCallback) {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  this.drawReplay(gl, context, skippedFeaturesHash, true);
  var result = featureCallback(null);

  if (result) {
    return result;
  } else {
    return undefined;
  }
};
/**
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_Replay_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  var gl = context.getGL();
  var tmpStencil, tmpStencilFunc, tmpStencilMaskVal, tmpStencilRef, tmpStencilMask, tmpStencilOpFail, tmpStencilOpPass, tmpStencilOpZFail;

  if (this.lineStringReplay) {
    tmpStencil = gl.isEnabled(gl.STENCIL_TEST);
    tmpStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
    tmpStencilMaskVal = gl.getParameter(gl.STENCIL_VALUE_MASK);
    tmpStencilRef = gl.getParameter(gl.STENCIL_REF);
    tmpStencilMask = gl.getParameter(gl.STENCIL_WRITEMASK);
    tmpStencilOpFail = gl.getParameter(gl.STENCIL_FAIL);
    tmpStencilOpPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
    tmpStencilOpZFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
    gl.enable(gl.STENCIL_TEST);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilMask(255);
    gl.stencilFunc(gl.ALWAYS, 1, 255);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
    this.lineStringReplay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
    gl.stencilMask(0);
    gl.stencilFunc(gl.NOTEQUAL, 1, 255);
  }

  context.bindBuffer(_webgl2.default.ARRAY_BUFFER, this.verticesBuffer);
  context.bindBuffer(_webgl2.default.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
  var locations = this.setUpProgram(gl, context, size, pixelRatio); // set the "uniform" values

  var projectionMatrix = _transform2.default.reset(this.projectionMatrix_);

  _transform2.default.scale(projectionMatrix, 2 / (resolution * size[0]), 2 / (resolution * size[1]));

  _transform2.default.rotate(projectionMatrix, -rotation);

  _transform2.default.translate(projectionMatrix, -(center[0] - this.origin[0]), -(center[1] - this.origin[1]));

  var offsetScaleMatrix = _transform2.default.reset(this.offsetScaleMatrix_);

  _transform2.default.scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);

  var offsetRotateMatrix = _transform2.default.reset(this.offsetRotateMatrix_);

  if (rotation !== 0) {
    _transform2.default.rotate(offsetRotateMatrix, -rotation);
  }

  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, projectionMatrix));
  gl.uniformMatrix4fv(locations.u_offsetScaleMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, offsetScaleMatrix));
  gl.uniformMatrix4fv(locations.u_offsetRotateMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, offsetRotateMatrix));
  gl.uniform1f(locations.u_opacity, opacity); // draw!

  var result;

  if (featureCallback === undefined) {
    this.drawReplay(gl, context, skippedFeaturesHash, false);
  } else {
    // draw feature by feature for the hit-detection
    result = this.drawHitDetectionReplay(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
  } // disable the vertex attrib arrays


  this.shutDownProgram(gl, locations);

  if (this.lineStringReplay) {
    if (!tmpStencil) {
      gl.disable(gl.STENCIL_TEST);
    }

    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc(
    /** @type {number} */
    tmpStencilFunc,
    /** @type {number} */
    tmpStencilRef,
    /** @type {number} */
    tmpStencilMaskVal);
    gl.stencilMask(
    /** @type {number} */
    tmpStencilMask);
    gl.stencilOp(
    /** @type {number} */
    tmpStencilOpFail,
    /** @type {number} */
    tmpStencilOpZFail,
    /** @type {number} */
    tmpStencilOpPass);
  }

  return result;
};
/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {number} start Start index.
 * @param {number} end End index.
 */


_ol_render_webgl_Replay_.prototype.drawElements = function (gl, context, start, end) {
  var elementType = context.hasOESElementIndexUint ? _webgl2.default.UNSIGNED_INT : _webgl2.default.UNSIGNED_SHORT;
  var elementSize = context.hasOESElementIndexUint ? 4 : 2;
  var numItems = end - start;
  var offsetInBytes = start * elementSize;
  gl.drawElements(_webgl2.default.TRIANGLES, numItems, elementType, offsetInBytes);
};

exports.default = _ol_render_webgl_Replay_;

},{"../../extent.js":55,"../../index.js":90,"../../transform.js":244,"../../vec/mat4.js":245,"../../webgl.js":249,"../vectorcontext.js":165}],179:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _replay = require("../replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _replaygroup = require("../replaygroup.js");

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _circlereplay = require("../webgl/circlereplay.js");

var _circlereplay2 = _interopRequireDefault(_circlereplay);

var _imagereplay = require("../webgl/imagereplay.js");

var _imagereplay2 = _interopRequireDefault(_imagereplay);

var _linestringreplay = require("../webgl/linestringreplay.js");

var _linestringreplay2 = _interopRequireDefault(_linestringreplay);

var _polygonreplay = require("../webgl/polygonreplay.js");

var _polygonreplay2 = _interopRequireDefault(_polygonreplay);

var _textreplay = require("../webgl/textreplay.js");

var _textreplay2 = _interopRequireDefault(_textreplay);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number=} opt_renderBuffer Render buffer.
 * @struct
 */
var _ol_render_webgl_ReplayGroup_ = function (tolerance, maxExtent, opt_renderBuffer) {
  _replaygroup2.default.call(this);
  /**
   * @type {ol.Extent}
   * @private
   */


  this.maxExtent_ = maxExtent;
  /**
   * @type {number}
   * @private
   */

  this.tolerance_ = tolerance;
  /**
   * @type {number|undefined}
   * @private
   */

  this.renderBuffer_ = opt_renderBuffer;
  /**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.webgl.Replay>>}
   */

  this.replaysByZIndex_ = {};
};

_index2.default.inherits(_ol_render_webgl_ReplayGroup_, _replaygroup2.default);
/**
 * @param {ol.style.Style} style Style.
 * @param {boolean} group Group with previous replay.
 */


_ol_render_webgl_ReplayGroup_.prototype.addDeclutter = function (style, group) {};
/**
 * @param {ol.webgl.Context} context WebGL context.
 * @return {function()} Delete resources function.
 */


_ol_render_webgl_ReplayGroup_.prototype.getDeleteResourcesFunction = function (context) {
  var functions = [];
  var zKey;

  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;

    for (replayKey in replays) {
      functions.push(replays[replayKey].getDeleteResourcesFunction(context));
    }
  }

  return function () {
    var length = functions.length;
    var result;

    for (var i = 0; i < length; i++) {
      result = functions[i].apply(this, arguments);
    }

    return result;
  };
};
/**
 * @param {ol.webgl.Context} context Context.
 */


_ol_render_webgl_ReplayGroup_.prototype.finish = function (context) {
  var zKey;

  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;

    for (replayKey in replays) {
      replays[replayKey].finish(context);
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
  var replays = this.replaysByZIndex_[zIndexKey];

  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }

  var replay = replays[replayType];

  if (replay === undefined) {
    /**
     * @type {Function}
     */
    var Constructor = _ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_);
    replays[replayType] = replay;
  }

  return replay;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_ReplayGroup_.prototype.isEmpty = function () {
  return _obj2.default.isEmpty(this.replaysByZIndex_);
};
/**
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 */


_ol_render_webgl_ReplayGroup_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(_array2.default.numberSafeCompareFunction);
  var i, ii, j, jj, replays, replay;

  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];

    for (j = 0, jj = _replay2.default.ORDER.length; j < jj; ++j) {
      replay = replays[_replay2.default.ORDER[j]];

      if (replay !== undefined) {
        replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, undefined, false);
      }
    }
  }
};
/**
 * @private
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_ReplayGroup_.prototype.replayHitDetection_ = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(function (a, b) {
    return b - a;
  });
  var i, ii, j, replays, replay, result;

  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];

    for (j = _replay2.default.ORDER.length - 1; j >= 0; --j) {
      replay = replays[_replay2.default.ORDER[j]];

      if (replay !== undefined) {
        result = replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);

        if (result) {
          return result;
        }
      }
    }
  }

  return undefined;
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} callback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_render_webgl_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, callback) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());
  /**
   * @type {ol.Extent}
   */

  var hitExtent;

  if (this.renderBuffer_ !== undefined) {
    // build an extent around the coordinate, so that only features that
    // intersect this extent are checked
    hitExtent = _extent2.default.buffer(_extent2.default.createOrUpdateFromCoordinate(coordinate), resolution * this.renderBuffer_);
  }

  return this.replayHitDetection_(context, coordinate, resolution, rotation, _ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

    if (imageData[3] > 0) {
      var result = callback(feature);

      if (result) {
        return result;
      }
    }
  }, true, hitExtent);
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @return {boolean} Is there a feature at the given coordinate?
 */


_ol_render_webgl_ReplayGroup_.prototype.hasFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());
  var hasFeature = this.replayHitDetection_(context, coordinate, resolution, rotation, _ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {boolean} Is there a feature?
   */
  function (feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
    return imageData[3] > 0;
  }, false);
  return hasFeature !== undefined;
};
/**
 * @const
 * @private
 * @type {Array.<number>}
 */


_ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_ = [1, 1];
/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.webgl.Replay, number,
 *                ol.Extent)>}
 */

_ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
  'Circle': _circlereplay2.default,
  'Image': _imagereplay2.default,
  'LineString': _linestringreplay2.default,
  'Polygon': _polygonreplay2.default,
  'Text': _textreplay2.default
};
exports.default = _ol_render_webgl_ReplayGroup_;

},{"../../array.js":30,"../../extent.js":55,"../../index.js":90,"../../obj.js":125,"../replay.js":162,"../replaygroup.js":163,"../webgl/circlereplay.js":167,"../webgl/imagereplay.js":170,"../webgl/linestringreplay.js":172,"../webgl/polygonreplay.js":175,"../webgl/textreplay.js":180}],180:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _colorlike = require("../../colorlike.js");

var _colorlike2 = _interopRequireDefault(_colorlike);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _geometrytype = require("../../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _has = require("../../has.js");

var _has2 = _interopRequireDefault(_has);

var _replay = require("../replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _texturereplay = require("../webgl/texturereplay.js");

var _texturereplay2 = _interopRequireDefault(_texturereplay);

var _atlasmanager = require("../../style/atlasmanager.js");

var _atlasmanager2 = _interopRequireDefault(_atlasmanager);

var _buffer = require("../../webgl/buffer.js");

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.render.webgl.TextureReplay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var _ol_render_webgl_TextReplay_ = function (tolerance, maxExtent) {
  _texturereplay2.default.call(this, tolerance, maxExtent);
  /**
   * @private
   * @type {Array.<HTMLCanvasElement>}
   */


  this.images_ = [];
  /**
   * @private
   * @type {Array.<WebGLTexture>}
   */

  this.textures_ = [];
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.measureCanvas_ = _dom2.default.createCanvasContext2D(0, 0).canvas;
  /**
   * @private
   * @type {{strokeColor: (ol.ColorLike|null),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: number,
   *         miterLimit: (number|undefined),
   *         fillColor: (ol.ColorLike|null),
   *         font: (string|undefined),
   *         scale: (number|undefined)}}
   */

  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: 0,
    miterLimit: undefined,
    fillColor: null,
    font: undefined,
    scale: undefined
  };
  /**
   * @private
   * @type {string}
   */

  this.text_ = '';
  /**
   * @private
   * @type {number|undefined}
   */

  this.textAlign_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.textBaseline_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.offsetX_ = undefined;
  /**
   * @private
   * @type {number|undefined}
   */

  this.offsetY_ = undefined;
  /**
   * @private
   * @type {Object.<string, ol.WebglGlyphAtlas>}
   */

  this.atlases_ = {};
  /**
   * @private
   * @type {ol.WebglGlyphAtlas|undefined}
   */

  this.currAtlas_ = undefined;
  this.scale = 1;
  this.opacity = 1;
};

_index2.default.inherits(_ol_render_webgl_TextReplay_, _texturereplay2.default);
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.drawText = function (geometry, feature) {
  if (this.text_) {
    var flatCoordinates = null;
    var offset = 0;
    var end = 2;
    var stride = 2;

    switch (geometry.getType()) {
      case _geometrytype2.default.POINT:
      case _geometrytype2.default.MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        stride = geometry.getStride();
        break;

      case _geometrytype2.default.CIRCLE:
        flatCoordinates =
        /** @type {ol.geom.Circle} */
        geometry.getCenter();
        break;

      case _geometrytype2.default.LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.LineString} */
        geometry.getFlatMidpoint();
        break;

      case _geometrytype2.default.MULTI_LINE_STRING:
        flatCoordinates =
        /** @type {ol.geom.MultiLineString} */
        geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;

      case _geometrytype2.default.POLYGON:
        flatCoordinates =
        /** @type {ol.geom.Polygon} */
        geometry.getFlatInteriorPoint();
        break;

      case _geometrytype2.default.MULTI_POLYGON:
        flatCoordinates =
        /** @type {ol.geom.MultiPolygon} */
        geometry.getFlatInteriorPoints();
        end = flatCoordinates.length;
        break;

      default:
    }

    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    var glyphAtlas = this.currAtlas_;
    var lines = this.text_.split('\n');
    var textSize = this.getTextSize_(lines);
    var i, ii, j, jj, currX, currY, charArr, charInfo;
    var anchorX = Math.round(textSize[0] * this.textAlign_ - this.offsetX_);
    var anchorY = Math.round(textSize[1] * this.textBaseline_ - this.offsetY_);
    var lineWidth = this.state_.lineWidth / 2 * this.state_.scale;

    for (i = 0, ii = lines.length; i < ii; ++i) {
      currX = 0;
      currY = glyphAtlas.height * i;
      charArr = lines[i].split('');

      for (j = 0, jj = charArr.length; j < jj; ++j) {
        charInfo = glyphAtlas.atlas.getInfo(charArr[j]);

        if (charInfo) {
          var image = charInfo.image;
          this.anchorX = anchorX - currX;
          this.anchorY = anchorY - currY;
          this.originX = j === 0 ? charInfo.offsetX - lineWidth : charInfo.offsetX;
          this.originY = charInfo.offsetY;
          this.height = glyphAtlas.height;
          this.width = j === 0 || j === charArr.length - 1 ? glyphAtlas.width[charArr[j]] + lineWidth : glyphAtlas.width[charArr[j]];
          this.imageHeight = image.height;
          this.imageWidth = image.width;
          var currentImage;

          if (this.images_.length === 0) {
            this.images_.push(image);
          } else {
            currentImage = this.images_[this.images_.length - 1];

            if (_index2.default.getUid(currentImage) != _index2.default.getUid(image)) {
              this.groupIndices.push(this.indices.length);
              this.images_.push(image);
            }
          }

          this.drawText_(flatCoordinates, offset, end, stride);
        }

        currX += this.width;
      }
    }
  }
};
/**
 * @private
 * @param {Array.<string>} lines Label to draw split to lines.
 * @return {Array.<number>} Size of the label in pixels.
 */


_ol_render_webgl_TextReplay_.prototype.getTextSize_ = function (lines) {
  var self = this;
  var glyphAtlas = this.currAtlas_;
  var textHeight = lines.length * glyphAtlas.height; //Split every line to an array of chars, sum up their width, and select the longest.

  var textWidth = lines.map(function (str) {
    var sum = 0;
    var i, ii;

    for (i = 0, ii = str.length; i < ii; ++i) {
      var curr = str[i];

      if (!glyphAtlas.width[curr]) {
        self.addCharToAtlas_(curr);
      }

      sum += glyphAtlas.width[curr] ? glyphAtlas.width[curr] : 0;
    }

    return sum;
  }).reduce(function (max, curr) {
    return Math.max(max, curr);
  });
  return [textWidth, textHeight];
};
/**
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */


_ol_render_webgl_TextReplay_.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
  var i, ii;

  for (i = offset, ii = end; i < ii; i += stride) {
    this.drawCoordinates(flatCoordinates, offset, end, stride);
  }
};
/**
 * @private
 * @param {string} char Character.
 */


_ol_render_webgl_TextReplay_.prototype.addCharToAtlas_ = function (char) {
  if (char.length === 1) {
    var glyphAtlas = this.currAtlas_;
    var state = this.state_;
    var mCtx = this.measureCanvas_.getContext('2d');
    mCtx.font = state.font;
    var width = Math.ceil(mCtx.measureText(char).width * state.scale);
    var info = glyphAtlas.atlas.add(char, width, glyphAtlas.height, function (ctx, x, y) {
      //Parameterize the canvas
      ctx.font =
      /** @type {string} */
      state.font;
      ctx.fillStyle = state.fillColor;
      ctx.strokeStyle = state.strokeColor;
      ctx.lineWidth = state.lineWidth;
      ctx.lineCap =
      /*** @type {string} */
      state.lineCap;
      ctx.lineJoin =
      /** @type {string} */
      state.lineJoin;
      ctx.miterLimit =
      /** @type {number} */
      state.miterLimit;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      if (_has2.default.CANVAS_LINE_DASH && state.lineDash) {
        //FIXME: use pixelRatio
        ctx.setLineDash(state.lineDash);
        ctx.lineDashOffset =
        /** @type {number} */
        state.lineDashOffset;
      }

      if (state.scale !== 1) {
        //FIXME: use pixelRatio
        ctx.setTransform(
        /** @type {number} */
        state.scale, 0, 0,
        /** @type {number} */
        state.scale, 0, 0);
      } //Draw the character on the canvas


      if (state.strokeColor) {
        ctx.strokeText(char, x, y);
      }

      if (state.fillColor) {
        ctx.fillText(char, x, y);
      }
    });

    if (info) {
      glyphAtlas.width[char] = width;
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.finish = function (context) {
  var gl = context.getGL();
  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices = this.groupIndices; // create, bind, and populate the vertices buffer

  this.verticesBuffer = new _buffer2.default(this.vertices); // create, bind, and populate the indices buffer

  this.indicesBuffer = new _buffer2.default(this.indices); // create textures

  /** @type {Object.<string, WebGLTexture>} */

  var texturePerImage = {};
  this.createTextures(this.textures_, this.images_, texturePerImage, gl);
  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: 0,
    miterLimit: undefined,
    fillColor: null,
    font: undefined,
    scale: undefined
  };
  this.text_ = '';
  this.textAlign_ = undefined;
  this.textBaseline_ = undefined;
  this.offsetX_ = undefined;
  this.offsetY_ = undefined;
  this.images_ = null;
  this.atlases_ = {};
  this.currAtlas_ = undefined;

  _texturereplay2.default.prototype.finish.call(this, context);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.setTextStyle = function (textStyle) {
  var state = this.state_;
  var textFillStyle = textStyle.getFill();
  var textStrokeStyle = textStyle.getStroke();

  if (!textStyle || !textStyle.getText() || !textFillStyle && !textStrokeStyle) {
    this.text_ = '';
  } else {
    if (!textFillStyle) {
      state.fillColor = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      state.fillColor = _colorlike2.default.asColorLike(textFillStyleColor ? textFillStyleColor : _webgl2.default.defaultFillStyle);
    }

    if (!textStrokeStyle) {
      state.strokeColor = null;
      state.lineWidth = 0;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      state.strokeColor = _colorlike2.default.asColorLike(textStrokeStyleColor ? textStrokeStyleColor : _webgl2.default.defaultStrokeStyle);
      state.lineWidth = textStrokeStyle.getWidth() || _webgl2.default.defaultLineWidth;
      state.lineCap = textStrokeStyle.getLineCap() || _webgl2.default.defaultLineCap;
      state.lineDashOffset = textStrokeStyle.getLineDashOffset() || _webgl2.default.defaultLineDashOffset;
      state.lineJoin = textStrokeStyle.getLineJoin() || _webgl2.default.defaultLineJoin;
      state.miterLimit = textStrokeStyle.getMiterLimit() || _webgl2.default.defaultMiterLimit;
      var lineDash = textStrokeStyle.getLineDash();
      state.lineDash = lineDash ? lineDash.slice() : _webgl2.default.defaultLineDash;
    }

    state.font = textStyle.getFont() || _webgl2.default.defaultFont;
    state.scale = textStyle.getScale() || 1;
    this.text_ =
    /** @type {string} */
    textStyle.getText();

    var textAlign = _replay2.default.TEXT_ALIGN[textStyle.getTextAlign()];

    var textBaseline = _replay2.default.TEXT_ALIGN[textStyle.getTextBaseline()];

    this.textAlign_ = textAlign === undefined ? _webgl2.default.defaultTextAlign : textAlign;
    this.textBaseline_ = textBaseline === undefined ? _webgl2.default.defaultTextBaseline : textBaseline;
    this.offsetX_ = textStyle.getOffsetX() || 0;
    this.offsetY_ = textStyle.getOffsetY() || 0;
    this.rotateWithView = !!textStyle.getRotateWithView();
    this.rotation = textStyle.getRotation() || 0;
    this.currAtlas_ = this.getAtlas_(state);
  }
};
/**
 * @private
 * @param {Object} state Font attributes.
 * @return {ol.WebglGlyphAtlas} Glyph atlas.
 */


_ol_render_webgl_TextReplay_.prototype.getAtlas_ = function (state) {
  var params = [];
  var i;

  for (i in state) {
    if (state[i] || state[i] === 0) {
      if (Array.isArray(state[i])) {
        params = params.concat(state[i]);
      } else {
        params.push(state[i]);
      }
    }
  }

  var hash = this.calculateHash_(params);

  if (!this.atlases_[hash]) {
    var mCtx = this.measureCanvas_.getContext('2d');
    mCtx.font = state.font;
    var height = Math.ceil((mCtx.measureText('M').width * 1.5 + state.lineWidth / 2) * state.scale);
    this.atlases_[hash] = {
      atlas: new _atlasmanager2.default({
        space: state.lineWidth + 1
      }),
      width: {},
      height: height
    };
  }

  return this.atlases_[hash];
};
/**
 * @private
 * @param {Array.<string|number>} params Array of parameters.
 * @return {string} Hash string.
 */


_ol_render_webgl_TextReplay_.prototype.calculateHash_ = function (params) {
  //TODO: Create a more performant, reliable, general hash function.
  var i, ii;
  var hash = '';

  for (i = 0, ii = params.length; i < ii; ++i) {
    hash += params[i];
  }

  return hash;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.getTextures = function (opt_all) {
  return this.textures_;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextReplay_.prototype.getHitDetectionTextures = function () {
  return this.textures_;
};

exports.default = _ol_render_webgl_TextReplay_;

},{"../../colorlike.js":38,"../../dom.js":47,"../../geom/geometrytype.js":80,"../../has.js":85,"../../index.js":90,"../../style/atlasmanager.js":224,"../../webgl/buffer.js":250,"../replay.js":162,"../webgl.js":166,"../webgl/texturereplay.js":181}],181:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _defaultshader = require("../webgl/texturereplay/defaultshader.js");

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _locations = require("../webgl/texturereplay/defaultshader/locations.js");

var _locations2 = _interopRequireDefault(_locations);

var _replay = require("../webgl/replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _webgl = require("../../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _context = require("../../webgl/context.js");

var _context2 = _interopRequireDefault(_context);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var _ol_render_webgl_TextureReplay_ = function (tolerance, maxExtent) {
  _replay2.default.call(this, tolerance, maxExtent);
  /**
   * @type {number|undefined}
   * @protected
   */


  this.anchorX = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.anchorY = undefined;
  /**
   * @type {Array.<number>}
   * @protected
   */

  this.groupIndices = [];
  /**
   * @type {Array.<number>}
   * @protected
   */

  this.hitDetectionGroupIndices = [];
  /**
   * @type {number|undefined}
   * @protected
   */

  this.height = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.imageHeight = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.imageWidth = undefined;
  /**
   * @protected
   * @type {ol.render.webgl.texturereplay.defaultshader.Locations}
   */

  this.defaultLocations = null;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.opacity = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.originX = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.originY = undefined;
  /**
   * @protected
   * @type {boolean|undefined}
   */

  this.rotateWithView = undefined;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.rotation = undefined;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.scale = undefined;
  /**
   * @type {number|undefined}
   * @protected
   */

  this.width = undefined;
};

_index2.default.inherits(_ol_render_webgl_TextureReplay_, _replay2.default);
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var textures = this.getTextures(true);
  var gl = context.getGL();
  return function () {
    if (!gl.isContextLost()) {
      var i, ii;

      for (i = 0, ii = textures.length; i < ii; ++i) {
        gl.deleteTexture(textures[i]);
      }
    }

    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} My end.
 * @protected
 */


_ol_render_webgl_TextureReplay_.prototype.drawCoordinates = function (flatCoordinates, offset, end, stride) {
  var anchorX =
  /** @type {number} */
  this.anchorX;
  var anchorY =
  /** @type {number} */
  this.anchorY;
  var height =
  /** @type {number} */
  this.height;
  var imageHeight =
  /** @type {number} */
  this.imageHeight;
  var imageWidth =
  /** @type {number} */
  this.imageWidth;
  var opacity =
  /** @type {number} */
  this.opacity;
  var originX =
  /** @type {number} */
  this.originX;
  var originY =
  /** @type {number} */
  this.originY;
  var rotateWithView = this.rotateWithView ? 1.0 : 0.0; // this.rotation_ is anti-clockwise, but rotation is clockwise

  var rotation =
  /** @type {number} */
  -this.rotation;
  var scale =
  /** @type {number} */
  this.scale;
  var width =
  /** @type {number} */
  this.width;
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  var numIndices = this.indices.length;
  var numVertices = this.vertices.length;
  var i, n, offsetX, offsetY, x, y;

  for (i = offset; i < end; i += stride) {
    x = flatCoordinates[i] - this.origin[0];
    y = flatCoordinates[i + 1] - this.origin[1]; // There are 4 vertices per [x, y] point, one for each corner of the
    // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if
    // WebGL supported Geometry Shaders (which can emit new vertices), but that
    // is not currently the case.
    //
    // And each vertex includes 8 values: the x and y coordinates, the x and
    // y offsets used to calculate the position of the corner, the u and
    // v texture coordinates for the corner, the opacity, and whether the
    // the image should be rotated with the view (rotateWithView).

    n = numVertices / 8; // bottom-left corner

    offsetX = -scale * anchorX;
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView; // bottom-right corner

    offsetX = scale * (width - anchorX);
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView; // top-right corner

    offsetX = scale * (width - anchorX);
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView; // top-left corner

    offsetX = -scale * anchorX;
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
  }

  return numVertices;
};
/**
 * @protected
 * @param {Array.<WebGLTexture>} textures Textures.
 * @param {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images
 *    Images.
 * @param {Object.<string, WebGLTexture>} texturePerImage Texture cache.
 * @param {WebGLRenderingContext} gl Gl.
 */


_ol_render_webgl_TextureReplay_.prototype.createTextures = function (textures, images, texturePerImage, gl) {
  var texture, image, uid, i;
  var ii = images.length;

  for (i = 0; i < ii; ++i) {
    image = images[i];
    uid = _index2.default.getUid(image).toString();

    if (uid in texturePerImage) {
      texture = texturePerImage[uid];
    } else {
      texture = _context2.default.createTexture(gl, image, _webgl2.default.CLAMP_TO_EDGE, _webgl2.default.CLAMP_TO_EDGE);
      texturePerImage[uid] = texture;
    }

    textures[i] = texture;
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader = _defaultshader2.default.fragment;
  var vertexShader = _defaultshader2.default.vertex;
  var program = context.getProgram(fragmentShader, vertexShader); // get the locations

  var locations;

  if (!this.defaultLocations) {
    locations = new _locations2.default(gl, program);
    this.defaultLocations = locations;
  } else {
    locations = this.defaultLocations;
  } // use the program (FIXME: use the return value)


  context.useProgram(program); // enable the vertex attrib arrays

  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, _webgl2.default.FLOAT, false, 32, 0);
  gl.enableVertexAttribArray(locations.a_offsets);
  gl.vertexAttribPointer(locations.a_offsets, 2, _webgl2.default.FLOAT, false, 32, 8);
  gl.enableVertexAttribArray(locations.a_texCoord);
  gl.vertexAttribPointer(locations.a_texCoord, 2, _webgl2.default.FLOAT, false, 32, 16);
  gl.enableVertexAttribArray(locations.a_opacity);
  gl.vertexAttribPointer(locations.a_opacity, 1, _webgl2.default.FLOAT, false, 32, 24);
  gl.enableVertexAttribArray(locations.a_rotateWithView);
  gl.vertexAttribPointer(locations.a_rotateWithView, 1, _webgl2.default.FLOAT, false, 32, 28);
  return locations;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_offsets);
  gl.disableVertexAttribArray(locations.a_texCoord);
  gl.disableVertexAttribArray(locations.a_opacity);
  gl.disableVertexAttribArray(locations.a_rotateWithView);
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();
  var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;

  if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping(gl, context, skippedFeaturesHash, textures, groupIndices);
  } else {
    var i, ii, start;

    for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {
      gl.bindTexture(_webgl2.default.TEXTURE_2D, textures[i]);
      var end = groupIndices[i];
      this.drawElements(gl, context, start, end);
      start = end;
    }
  }
};
/**
 * Draw the replay while paying attention to skipped features.
 *
 * This functions creates groups of features that can be drawn to together,
 * so that the number of `drawElements` calls is minimized.
 *
 * For example given the following texture groups:
 *
 *    Group 1: A B C
 *    Group 2: D [E] F G
 *
 * If feature E should be skipped, the following `drawElements` calls will be
 * made:
 *
 *    drawElements with feature A, B and C
 *    drawElements with feature D
 *    drawElements with feature F and G
 *
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {Array.<WebGLTexture>} textures Textures.
 * @param {Array.<number>} groupIndices Texture group indices.
 */


_ol_render_webgl_TextureReplay_.prototype.drawReplaySkipping = function (gl, context, skippedFeaturesHash, textures, groupIndices) {
  var featureIndex = 0;
  var i, ii;

  for (i = 0, ii = textures.length; i < ii; ++i) {
    gl.bindTexture(_webgl2.default.TEXTURE_2D, textures[i]);
    var groupStart = i > 0 ? groupIndices[i - 1] : 0;
    var groupEnd = groupIndices[i];
    var start = groupStart;
    var end = groupStart;

    while (featureIndex < this.startIndices.length && this.startIndices[featureIndex] <= groupEnd) {
      var feature = this.startIndicesFeature[featureIndex];

      var featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] !== undefined) {
        // feature should be skipped
        if (start !== end) {
          // draw the features so far
          this.drawElements(gl, context, start, end);
        } // continue with the next feature


        start = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
        end = start;
      } else {
        // the feature is not skipped, augment the end index
        end = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
      }

      featureIndex++;
    }

    if (start !== end) {
      // draw the remaining features (in case there was no skipped feature
      // in this texture group, all features of a group are drawn together)
      this.drawElements(gl, context, start, end);
    }
  }
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, groupStart, start, end, feature, featureUid;
  var featureIndex = this.startIndices.length - 1;
  var hitDetectionTextures = this.getHitDetectionTextures();

  for (i = hitDetectionTextures.length - 1; i >= 0; --i) {
    gl.bindTexture(_webgl2.default.TEXTURE_2D, hitDetectionTextures[i]);
    groupStart = i > 0 ? this.hitDetectionGroupIndices[i - 1] : 0;
    end = this.hitDetectionGroupIndices[i]; // draw all features for this texture group

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = _index2.default.getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
      /** @type {Array<number>} */
      opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }

      end = start;
      featureIndex--;
    }
  }

  return undefined;
};
/**
 * @inheritDoc
 */


_ol_render_webgl_TextureReplay_.prototype.finish = function (context) {
  this.anchorX = undefined;
  this.anchorY = undefined;
  this.height = undefined;
  this.imageHeight = undefined;
  this.imageWidth = undefined;
  this.indices = null;
  this.opacity = undefined;
  this.originX = undefined;
  this.originY = undefined;
  this.rotateWithView = undefined;
  this.rotation = undefined;
  this.scale = undefined;
  this.vertices = null;
  this.width = undefined;
};
/**
 * @abstract
 * @protected
 * @param {boolean=} opt_all Return hit detection textures with regular ones.
 * @returns {Array.<WebGLTexture>} Textures.
 */


_ol_render_webgl_TextureReplay_.prototype.getTextures = function (opt_all) {};
/**
 * @abstract
 * @protected
 * @returns {Array.<WebGLTexture>} Textures.
 */


_ol_render_webgl_TextureReplay_.prototype.getHitDetectionTextures = function () {};

exports.default = _ol_render_webgl_TextureReplay_;

},{"../../extent.js":55,"../../index.js":90,"../../obj.js":125,"../../webgl.js":249,"../../webgl/context.js":251,"../webgl/replay.js":178,"../webgl/texturereplay/defaultshader.js":182,"../webgl/texturereplay/defaultshader/locations.js":183}],182:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../index.js");

var _index2 = _interopRequireDefault(_index);

var _fragment = require("../../../webgl/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require("../../../webgl/vertex.js");

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit
var _ol_render_webgl_texturereplay_defaultshader_ = {};
_ol_render_webgl_texturereplay_defaultshader_.fragment = new _fragment2.default(_index2.default.DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\nvarying float v_opacity;\n\nuniform float u_opacity;\nuniform sampler2D u_image;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  float alpha = texColor.a * v_opacity * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');
_ol_render_webgl_texturereplay_defaultshader_.vertex = new _vertex2.default(_index2.default.DEBUG_WEBGL ? 'varying vec2 v_texCoord;\nvarying float v_opacity;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_offsets;\nattribute float a_opacity;\nattribute float a_rotateWithView;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix;\n  if (a_rotateWithView == 1.0) {\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  }\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  v_texCoord = a_texCoord;\n  v_opacity = a_opacity;\n}\n\n\n' : 'varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}');
exports.default = _ol_render_webgl_texturereplay_defaultshader_;

},{"../../../index.js":90,"../../../webgl/fragment.js":253,"../../../webgl/vertex.js":255}],183:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../../index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var _ol_render_webgl_texturereplay_defaultshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'k');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_image = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_image' : 'l');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'c');
  /**
   * @type {number}
   */

  this.a_texCoord = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_texCoord' : 'd');
  /**
   * @type {number}
   */

  this.a_offsets = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_offsets' : 'e');
  /**
   * @type {number}
   */

  this.a_opacity = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_opacity' : 'f');
  /**
   * @type {number}
   */

  this.a_rotateWithView = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_rotateWithView' : 'g');
};

exports.default = _ol_render_webgl_texturereplay_defaultshader_Locations_;

},{"../../../../index.js":90}],184:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _imagecanvas = require("../../imagecanvas.js");

var _imagecanvas2 = _interopRequireDefault(_imagecanvas);

var _layertype = require("../../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _viewhint = require("../../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _vectorrendertype = require("../../layer/vectorrendertype.js");

var _vectorrendertype2 = _interopRequireDefault(_vectorrendertype);

var _obj = require("../../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _plugins = require("../../plugins.js");

var _plugins2 = _interopRequireDefault(_plugins);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _intermediatecanvas = require("../canvas/intermediatecanvas.js");

var _intermediatecanvas2 = _interopRequireDefault(_intermediatecanvas);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Image} imageLayer Single image layer.
 * @api
 */
var _ol_renderer_canvas_ImageLayer_ = function (imageLayer) {
  _intermediatecanvas2.default.call(this, imageLayer);
  /**
   * @private
   * @type {?ol.ImageBase}
   */


  this.image_ = null;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.imageTransform_ = _transform2.default.create();
  /**
   * @type {!Array.<string>}
   */

  this.skippedFeatures_ = [];
  /**
   * @private
   * @type {ol.renderer.canvas.VectorLayer}
   */

  this.vectorRenderer_ = null;
};

_index2.default.inherits(_ol_renderer_canvas_ImageLayer_, _intermediatecanvas2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_ImageLayer_['handles'] = function (type, layer) {
  return type === _type2.default.CANVAS && (layer.getType() === _layertype2.default.IMAGE || layer.getType() === _layertype2.default.VECTOR &&
  /** @type {ol.layer.Vector} */
  layer.getRenderMode() === _vectorrendertype2.default.IMAGE);
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.ImageLayer} The layer renderer.
 */


_ol_renderer_canvas_ImageLayer_['create'] = function (mapRenderer, layer) {
  var renderer = new _ol_renderer_canvas_ImageLayer_(
  /** @type {ol.layer.Image} */
  layer);

  if (layer.getType() === _layertype2.default.VECTOR) {
    var candidates = _plugins2.default.getLayerRendererPlugins();

    for (var i = 0, ii = candidates.length; i < ii; ++i) {
      var candidate =
      /** @type {Object.<string, Function>} */
      candidates[i];

      if (candidate !== _ol_renderer_canvas_ImageLayer_ && candidate['handles'](_type2.default.CANVAS, layer)) {
        renderer.setVectorRenderer(candidate['create'](mapRenderer, layer));
      }
    }
  }

  return renderer;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.getImage = function () {
  return !this.image_ ? null : this.image_.getImage();
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.getImageTransform = function () {
  return this.imageTransform_;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;
  var image;
  var imageLayer =
  /** @type {ol.layer.Image} */
  this.getLayer();
  var imageSource = imageLayer.getSource();
  var hints = frameState.viewHints;
  var renderedExtent = frameState.extent;

  if (layerState.extent !== undefined) {
    renderedExtent = _extent2.default.getIntersection(renderedExtent, layerState.extent);
  }

  if (!hints[_viewhint2.default.ANIMATING] && !hints[_viewhint2.default.INTERACTING] && !_extent2.default.isEmpty(renderedExtent)) {
    var projection = viewState.projection;

    if (!_index2.default.ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();

      if (sourceProjection) {
        projection = sourceProjection;
      }
    }

    var vectorRenderer = this.vectorRenderer_;

    if (vectorRenderer) {
      var context = vectorRenderer.context;

      var imageFrameState =
      /** @type {olx.FrameState} */
      _obj2.default.assign({}, frameState, {
        size: [_extent2.default.getWidth(renderedExtent) / viewResolution, _extent2.default.getHeight(renderedExtent) / viewResolution],
        viewState:
        /** @type {olx.ViewState} */
        _obj2.default.assign({}, frameState.viewState, {
          rotation: 0
        })
      });

      var skippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();

      if (vectorRenderer.prepareFrame(imageFrameState, layerState) && (vectorRenderer.replayGroupChanged || !_array2.default.equals(skippedFeatures, this.skippedFeatures_))) {
        context.canvas.width = imageFrameState.size[0] * pixelRatio;
        context.canvas.height = imageFrameState.size[1] * pixelRatio;
        vectorRenderer.composeFrame(imageFrameState, layerState, context);
        this.image_ = new _imagecanvas2.default(renderedExtent, viewResolution, pixelRatio, context.canvas);
        this.skippedFeatures_ = skippedFeatures;
      }
    } else {
      image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);

      if (image) {
        var loaded = this.loadImage(image);

        if (loaded) {
          this.image_ = image;
        }
      }
    }
  }

  if (this.image_) {
    image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);

    var transform = _transform2.default.compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);

    _transform2.default.compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);

    this.updateLogos(frameState, imageSource);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
  }

  return !!this.image_;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_ImageLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (this.vectorRenderer_) {
    return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
  } else {
    return _intermediatecanvas2.default.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);
  }
};
/**
 * @param {ol.renderer.canvas.VectorLayer} renderer Vector renderer.
 */


_ol_renderer_canvas_ImageLayer_.prototype.setVectorRenderer = function (renderer) {
  this.vectorRenderer_ = renderer;
};

exports.default = _ol_renderer_canvas_ImageLayer_;

},{"../../array.js":30,"../../extent.js":55,"../../imagecanvas.js":88,"../../index.js":90,"../../layer/vectorrendertype.js":112,"../../layertype.js":114,"../../obj.js":125,"../../plugins.js":132,"../../transform.js":244,"../../viewhint.js":247,"../canvas/intermediatecanvas.js":185,"../type.js":193}],185:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _coordinate = require("../../coordinate.js");

var _coordinate2 = _interopRequireDefault(_coordinate);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _layer = require("../canvas/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */
var _ol_renderer_canvas_IntermediateCanvas_ = function (layer) {
  _layer2.default.call(this, layer);
  /**
   * @protected
   * @type {ol.Transform}
   */


  this.coordinateToCanvasPixelTransform = _transform2.default.create();
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.hitCanvasContext_ = null;
};

_index2.default.inherits(_ol_renderer_canvas_IntermediateCanvas_, _layer2.default);
/**
 * @inheritDoc
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.composeFrame = function (frameState, layerState, context) {
  this.preCompose(context, frameState);
  var image = this.getImage();

  if (image) {
    // clipped rendering if layer extent is set
    var extent = layerState.extent;

    var clipped = extent !== undefined && !_extent2.default.containsExtent(extent, frameState.extent) && _extent2.default.intersects(extent, frameState.extent);

    if (clipped) {
      this.clip(context, frameState,
      /** @type {ol.Extent} */
      extent);
    }

    var imageTransform = this.getImageTransform(); // for performance reasons, context.save / context.restore is not used
    // to save and restore the transformation matrix and the opacity.
    // see http://jsperf.com/context-save-restore-versus-variable

    var alpha = context.globalAlpha;
    context.globalAlpha = layerState.opacity; // for performance reasons, context.setTransform is only used
    // when the view is rotated. see http://jsperf.com/canvas-transform

    var dx = imageTransform[4];
    var dy = imageTransform[5];
    var dw = image.width * imageTransform[0];
    var dh = image.height * imageTransform[3];
    context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    context.globalAlpha = alpha;

    if (clipped) {
      context.restore();
    }
  }

  this.postCompose(context, frameState, layerState);
};
/**
 * @abstract
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.getImage = function () {};
/**
 * @abstract
 * @return {!ol.Transform} Image transform.
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.getImageTransform = function () {};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    return callback.call(thisArg, feature, layer);
  });
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  if (!this.getImage()) {
    return undefined;
  }

  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _index2.default.nullFunction) {
    // for ImageCanvas sources use the original hit-detection logic,
    // so that for example also transparent polygons are detected
    return _layer2.default.prototype.forEachLayerAtCoordinate.apply(this, arguments);
  } else {
    var pixel = _transform2.default.apply(this.coordinateToCanvasPixelTransform, coordinate.slice());

    _coordinate2.default.scale(pixel, frameState.viewState.resolution / this.renderedResolution);

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = _dom2.default.createCanvasContext2D(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);
    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;

    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};

exports.default = _ol_renderer_canvas_IntermediateCanvas_;

},{"../../coordinate.js":44,"../../dom.js":47,"../../extent.js":55,"../../index.js":90,"../../transform.js":244,"../canvas/layer.js":186}],186:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _functions = require("../../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _event = require("../../render/event.js");

var _event2 = _interopRequireDefault(_event);

var _eventtype = require("../../render/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _canvas = require("../../render/canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _immediate = require("../../render/canvas/immediate.js");

var _immediate2 = _interopRequireDefault(_immediate);

var _layer = require("../layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */
var _ol_renderer_canvas_Layer_ = function (layer) {
  _layer2.default.call(this, layer);
  /**
   * @protected
   * @type {number}
   */


  this.renderedResolution;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.transform_ = _transform2.default.create();
};

_index2.default.inherits(_ol_renderer_canvas_Layer_, _layer2.default);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Extent} extent Clip extent.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.clip = function (context, frameState, extent) {
  var pixelRatio = frameState.pixelRatio;
  var width = frameState.size[0] * pixelRatio;
  var height = frameState.size[1] * pixelRatio;
  var rotation = frameState.viewState.rotation;

  var topLeft = _extent2.default.getTopLeft(
  /** @type {ol.Extent} */
  extent);

  var topRight = _extent2.default.getTopRight(
  /** @type {ol.Extent} */
  extent);

  var bottomRight = _extent2.default.getBottomRight(
  /** @type {ol.Extent} */
  extent);

  var bottomLeft = _extent2.default.getBottomLeft(
  /** @type {ol.Extent} */
  extent);

  _transform2.default.apply(frameState.coordinateToPixelTransform, topLeft);

  _transform2.default.apply(frameState.coordinateToPixelTransform, topRight);

  _transform2.default.apply(frameState.coordinateToPixelTransform, bottomRight);

  _transform2.default.apply(frameState.coordinateToPixelTransform, bottomLeft);

  context.save();

  _canvas2.default.rotateAtOffset(context, -rotation, width / 2, height / 2);

  context.beginPath();
  context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
  context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
  context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
  context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
  context.clip();

  _canvas2.default.rotateAtOffset(context, rotation, width / 2, height / 2);
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @private
 */


_ol_renderer_canvas_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState, opt_transform) {
  var layer = this.getLayer();

  if (layer.hasListener(type)) {
    var width = frameState.size[0] * frameState.pixelRatio;
    var height = frameState.size[1] * frameState.pixelRatio;
    var rotation = frameState.viewState.rotation;

    _canvas2.default.rotateAtOffset(context, -rotation, width / 2, height / 2);

    var transform = opt_transform !== undefined ? opt_transform : this.getTransform(frameState, 0);
    var render = new _immediate2.default(context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation);
    var composeEvent = new _event2.default(type, render, frameState, context, null);
    layer.dispatchEvent(composeEvent);

    _canvas2.default.rotateAtOffset(context, rotation, width / 2, height / 2);
  }
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_canvas_Layer_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _functions2.default.TRUE, this);

  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.postCompose = function (context, frameState, layerState, opt_transform) {
  this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, context, frameState, opt_transform);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.preCompose = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, context, frameState, opt_transform);
};
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */


_ol_renderer_canvas_Layer_.prototype.dispatchRenderEvent = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(_eventtype2.default.RENDER, context, frameState, opt_transform);
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} offsetX Offset on the x-axis in view coordinates.
 * @protected
 * @return {!ol.Transform} Transform.
 */


_ol_renderer_canvas_Layer_.prototype.getTransform = function (frameState, offsetX) {
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var dx1 = pixelRatio * frameState.size[0] / 2;
  var dy1 = pixelRatio * frameState.size[1] / 2;
  var sx = pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0] + offsetX;
  var dy2 = -viewState.center[1];
  return _transform2.default.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};
/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {CanvasRenderingContext2D} context Context.
 */


_ol_renderer_canvas_Layer_.prototype.composeFrame = function (frameState, layerState, context) {};
/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @return {boolean} whether composeFrame should be called.
 */


_ol_renderer_canvas_Layer_.prototype.prepareFrame = function (frameState, layerState) {};

exports.default = _ol_renderer_canvas_Layer_;

},{"../../extent.js":55,"../../functions.js":61,"../../index.js":90,"../../render/canvas.js":151,"../../render/canvas/immediate.js":153,"../../render/event.js":160,"../../render/eventtype.js":161,"../../transform.js":244,"../layer.js":191}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _css = require("../../css.js");

var _css2 = _interopRequireDefault(_css);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _layer = require("../../layer/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _event = require("../../render/event.js");

var _event2 = _interopRequireDefault(_event);

var _eventtype = require("../../render/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _canvas = require("../../render/canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _immediate = require("../../render/canvas/immediate.js");

var _immediate2 = _interopRequireDefault(_immediate);

var _map = require("../map.js");

var _map2 = _interopRequireDefault(_map);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _state = require("../../source/state.js");

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME offset panning

/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @api
 */
var _ol_renderer_canvas_Map_ = function (container, map) {
  _map2.default.call(this, container, map);
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */


  this.context_ = _dom2.default.createCanvasContext2D();
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = this.context_.canvas;
  this.canvas_.style.width = '100%';
  this.canvas_.style.height = '100%';
  this.canvas_.style.display = 'block';
  this.canvas_.className = _css2.default.CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);
  /**
   * @private
   * @type {boolean}
   */

  this.renderedVisible_ = true;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.transform_ = _transform2.default.create();
};

_index2.default.inherits(_ol_renderer_canvas_Map_, _map2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_Map_['handles'] = function (type) {
  return type === _type2.default.CANVAS;
};
/**
 * Create the map renderer.
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @return {ol.renderer.canvas.Map} The map renderer.
 */


_ol_renderer_canvas_Map_['create'] = function (container, map) {
  return new _ol_renderer_canvas_Map_(container, map);
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_canvas_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
  var map = this.getMap();
  var context = this.context_;

  if (map.hasListener(type)) {
    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;
    var transform = this.getTransform(frameState);
    var vectorContext = new _immediate2.default(context, pixelRatio, extent, transform, rotation);
    var composeEvent = new _event2.default(type, vectorContext, frameState, context, null);
    map.dispatchEvent(composeEvent);
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 * @return {!ol.Transform} Transform.
 */


_ol_renderer_canvas_Map_.prototype.getTransform = function (frameState) {
  var viewState = frameState.viewState;
  var dx1 = this.canvas_.width / 2;
  var dy1 = this.canvas_.height / 2;
  var sx = frameState.pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0];
  var dy2 = -viewState.center[1];
  return _transform2.default.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_Map_.prototype.getType = function () {
  return _type2.default.CANVAS;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_Map_.prototype.renderFrame = function (frameState) {
  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = 'none';
      this.renderedVisible_ = false;
    }

    return;
  }

  var context = this.context_;
  var pixelRatio = frameState.pixelRatio;
  var width = Math.round(frameState.size[0] * pixelRatio);
  var height = Math.round(frameState.size[1] * pixelRatio);

  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  } else {
    context.clearRect(0, 0, width, height);
  }

  var rotation = frameState.viewState.rotation;
  this.calculateMatrices2D(frameState);
  this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, frameState);
  var layerStatesArray = frameState.layerStatesArray;

  _array2.default.stableSort(layerStatesArray, _map2.default.sortByZIndex);

  if (rotation) {
    context.save();

    _canvas2.default.rotateAtOffset(context, rotation, width / 2, height / 2);
  }

  var viewResolution = frameState.viewState.resolution;
  var i, ii, layer, layerRenderer, layerState;

  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];
    layer = layerState.layer;
    layerRenderer =
    /** @type {ol.renderer.canvas.Layer} */
    this.getLayerRenderer(layer);

    if (!_layer2.default.visibleAtResolution(layerState, viewResolution) || layerState.sourceState != _state2.default.READY) {
      continue;
    }

    if (layerRenderer.prepareFrame(frameState, layerState)) {
      layerRenderer.composeFrame(frameState, layerState, context);
    }
  }

  if (rotation) {
    context.restore();
  }

  this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, frameState);

  if (!this.renderedVisible_) {
    this.canvas_.style.display = '';
    this.renderedVisible_ = true;
  }

  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;

  var coordinate = _transform2.default.apply(frameState.pixelToCoordinateTransform, pixel.slice());

  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer2.default.visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer =
      /** @type {ol.renderer.canvas.Layer} */
      this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, callback, thisArg);

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};

exports.default = _ol_renderer_canvas_Map_;

},{"../../array.js":30,"../../css.js":45,"../../dom.js":47,"../../index.js":90,"../../layer/layer.js":109,"../../render/canvas.js":151,"../../render/canvas/immediate.js":153,"../../render/event.js":160,"../../render/eventtype.js":161,"../../source/state.js":213,"../../transform.js":244,"../map.js":192,"../type.js":193}],188:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _tilerange = require("../../tilerange.js");

var _tilerange2 = _interopRequireDefault(_tilerange);

var _tilestate = require("../../tilestate.js");

var _tilestate2 = _interopRequireDefault(_tilestate);

var _viewhint = require("../../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _intermediatecanvas = require("../canvas/intermediatecanvas.js");

var _intermediatecanvas2 = _interopRequireDefault(_intermediatecanvas);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.
 * @api
 */
var _ol_renderer_canvas_TileLayer_ = function (tileLayer) {
  _intermediatecanvas2.default.call(this, tileLayer);
  /**
   * @protected
   * @type {CanvasRenderingContext2D}
   */


  this.context = this.context === null ? null : _dom2.default.createCanvasContext2D();
  /**
   * @private
   * @type {number}
   */

  this.oversampling_;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedExtent_ = null;
  /**
   * @protected
   * @type {number}
   */

  this.renderedRevision;
  /**
   * @protected
   * @type {!Array.<ol.Tile>}
   */

  this.renderedTiles = [];
  /**
   * @protected
   * @type {ol.Extent}
   */

  this.tmpExtent = _extent2.default.createEmpty();
  /**
   * @private
   * @type {ol.TileRange}
   */

  this.tmpTileRange_ = new _tilerange2.default(0, 0, 0, 0);
  /**
   * @private
   * @type {ol.Transform}
   */

  this.imageTransform_ = _transform2.default.create();
  /**
   * @protected
   * @type {number}
   */

  this.zDirection = 0;
};

_index2.default.inherits(_ol_renderer_canvas_TileLayer_, _intermediatecanvas2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_TileLayer_['handles'] = function (type, layer) {
  return type === _type2.default.CANVAS && layer.getType() === _layertype2.default.TILE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.TileLayer} The layer renderer.
 */


_ol_renderer_canvas_TileLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_canvas_TileLayer_(
  /** @type {ol.layer.Tile} */
  layer);
};
/**
 * @private
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Tile is drawable.
 */


_ol_renderer_canvas_TileLayer_.prototype.isDrawableTile_ = function (tile) {
  var tileState = tile.getState();
  var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();
  return tileState == _tilestate2.default.LOADED || tileState == _tilestate2.default.EMPTY || tileState == _tilestate2.default.ERROR && !useInterimTilesOnError;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_TileLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var viewResolution = viewState.resolution;
  var viewCenter = viewState.center;
  var tileLayer = this.getLayer();
  var tileSource =
  /** @type {ol.source.Tile} */
  tileLayer.getSource();
  var sourceRevision = tileSource.getRevision();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
  var tileResolution = tileGrid.getResolution(z);
  var oversampling = Math.round(viewResolution / tileResolution) || 1;
  var extent = frameState.extent;

  if (layerState.extent !== undefined) {
    extent = _extent2.default.getIntersection(extent, layerState.extent);
  }

  if (_extent2.default.isEmpty(extent)) {
    // Return false to prevent the rendering of the layer.
    return false;
  }

  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);
  var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
  /**
   * @type {Object.<number, Object.<string, ol.Tile>>}
   */

  var tilesToDrawByZ = {};
  tilesToDrawByZ[z] = {};
  var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
  var tmpExtent = this.tmpExtent;
  var tmpTileRange = this.tmpTileRange_;
  var newTiles = false;
  var tile, x, y;

  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tile = tileSource.getTile(z, x, y, pixelRatio, projection);

      if (tile.getState() == _tilestate2.default.ERROR) {
        if (!tileLayer.getUseInterimTilesOnError()) {
          // When useInterimTilesOnError is false, we consider the error tile as loaded.
          tile.setState(_tilestate2.default.LOADED);
        } else if (tileLayer.getPreload() > 0) {
          // Preloaded tiles for lower resolutions might have finished loading.
          newTiles = true;
        }
      }

      if (!this.isDrawableTile_(tile)) {
        tile = tile.getInterimTile();
      }

      if (this.isDrawableTile_(tile)) {
        var uid = _index2.default.getUid(this);

        if (tile.getState() == _tilestate2.default.LOADED) {
          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
          var inTransition = tile.inTransition(uid);

          if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
            newTiles = true;
          }
        }

        if (tile.getAlpha(uid, frameState.time) === 1) {
          // don't look for alt tiles if alpha is 1
          continue;
        }
      }

      var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
      var covered = false;

      if (childTileRange) {
        covered = findLoadedTiles(z + 1, childTileRange);
      }

      if (!covered) {
        tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
      }
    }
  }

  var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
  var hints = frameState.viewHints;
  var animatingOrInteracting = hints[_viewhint2.default.ANIMATING] || hints[_viewhint2.default.INTERACTING];

  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (newTiles || !(this.renderedExtent_ && _extent2.default.containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {
    var context = this.context;

    if (context) {
      var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
      var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
      var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
      var canvas = context.canvas;

      if (canvas.width != width || canvas.height != height) {
        this.oversampling_ = oversampling;
        canvas.width = width;
        canvas.height = height;
      } else {
        if (this.renderedExtent_ && !_extent2.default.equals(imageExtent, this.renderedExtent_)) {
          context.clearRect(0, 0, width, height);
        }

        oversampling = this.oversampling_;
      }
    }

    this.renderedTiles.length = 0;
    /** @type {Array.<number>} */

    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(function (a, b) {
      if (a === z) {
        return 1;
      } else if (b === z) {
        return -1;
      } else {
        return a > b ? 1 : a < b ? -1 : 0;
      }
    });
    var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
    var tileExtent, tileGutter, tilesToDraw, w, h;

    for (i = 0, ii = zs.length; i < ii; ++i) {
      currentZ = zs[i];
      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      currentResolution = tileGrid.getResolution(currentZ);
      currentScale = currentResolution / tileResolution;
      tileGutter = tilePixelRatio * tileSource.getGutter(projection);
      tilesToDraw = tilesToDrawByZ[currentZ];

      for (var tileCoordKey in tilesToDraw) {
        tile = tilesToDraw[tileCoordKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
        w = currentTilePixelSize[0] * currentScale / oversampling;
        h = currentTilePixelSize[1] * currentScale / oversampling;
        this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
        this.renderedTiles.push(tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    this.renderedExtent_ = imageExtent;
  }

  var scale = this.renderedResolution / viewResolution;

  var transform = _transform2.default.compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);

  _transform2.default.compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);

  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);
  return this.renderedTiles.length > 0;
};
/**
 * @param {ol.Tile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} x Left of the tile.
 * @param {number} y Top of the tile.
 * @param {number} w Width of the tile.
 * @param {number} h Height of the tile.
 * @param {number} gutter Tile gutter.
 * @param {boolean} transition Apply an alpha transition.
 */


_ol_renderer_canvas_TileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var image = tile.getImage(this.getLayer());

  if (!image) {
    return;
  }

  var uid = _index2.default.getUid(this);

  var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;

  if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {
    this.context.clearRect(x, y, w, h);
  }

  var alphaChanged = alpha !== this.context.globalAlpha;

  if (alphaChanged) {
    this.context.save();
    this.context.globalAlpha = alpha;
  }

  this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

  if (alphaChanged) {
    this.context.restore();
  }

  if (alpha !== 1) {
    frameState.animate = true;
  } else if (transition) {
    tile.endTransition(uid);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_TileLayer_.prototype.getImage = function () {
  var context = this.context;
  return context ? context.canvas : null;
};
/**
 * @function
 * @return {ol.layer.Tile|ol.layer.VectorTile}
 */


_ol_renderer_canvas_TileLayer_.prototype.getLayer;
/**
 * @inheritDoc
 */

_ol_renderer_canvas_TileLayer_.prototype.getImageTransform = function () {
  return this.imageTransform_;
};

exports.default = _ol_renderer_canvas_TileLayer_;

},{"../../dom.js":47,"../../extent.js":55,"../../index.js":90,"../../layertype.js":114,"../../tilerange.js":242,"../../tilestate.js":243,"../../transform.js":244,"../../viewhint.js":247,"../canvas/intermediatecanvas.js":185,"../type.js":193}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _viewhint = require("../../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("../../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _rbush = require("rbush");

var _rbush2 = _interopRequireDefault(_rbush);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _eventtype3 = require("../../render/eventtype.js");

var _eventtype4 = _interopRequireDefault(_eventtype3);

var _canvas = require("../../render/canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _replaygroup = require("../../render/canvas/replaygroup.js");

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _layer = require("../canvas/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _vector = require("../vector.js");

var _vector2 = _interopRequireDefault(_vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 * @api
 */
var _ol_renderer_canvas_VectorLayer_ = function (vectorLayer) {
  _layer2.default.call(this, vectorLayer);
  /**
   * Declutter tree.
   * @private
   */


  this.declutterTree_ = vectorLayer.getDeclutter() ? (0, _rbush2.default)(9) : null;
  /**
   * @private
   * @type {boolean}
   */

  this.dirty_ = false;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.renderedResolution_ = NaN;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedExtent_ = _extent2.default.createEmpty();
  /**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */

  this.renderedRenderOrder_ = null;
  /**
   * @private
   * @type {ol.render.canvas.ReplayGroup}
   */

  this.replayGroup_ = null;
  /**
   * A new replay group had to be created by `prepareFrame()`
   * @type {boolean}
   */

  this.replayGroupChanged = true;
  /**
   * @type {CanvasRenderingContext2D}
   */

  this.context = _dom2.default.createCanvasContext2D();

  _events2.default.listen(_canvas2.default.labelCache, _eventtype2.default.CLEAR, this.handleFontsChanged_, this);
};

_index2.default.inherits(_ol_renderer_canvas_VectorLayer_, _layer2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_VectorLayer_['handles'] = function (type, layer) {
  return type === _type2.default.CANVAS && layer.getType() === _layertype2.default.VECTOR;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.VectorLayer} The layer renderer.
 */


_ol_renderer_canvas_VectorLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_canvas_VectorLayer_(
  /** @type {ol.layer.Vector} */
  layer);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.disposeInternal = function () {
  _events2.default.unlisten(_canvas2.default.labelCache, _eventtype2.default.CLEAR, this.handleFontsChanged_, this);

  _layer2.default.prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {
  var extent = frameState.extent;
  var pixelRatio = frameState.pixelRatio;
  var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var rotation = viewState.rotation;
  var projectionExtent = projection.getExtent();
  var vectorSource =
  /** @type {ol.source.Vector} */
  this.getLayer().getSource();
  var transform = this.getTransform(frameState, 0);
  this.preCompose(context, frameState, transform); // clipped rendering if layer extent is set

  var clipExtent = layerState.extent;
  var clipped = clipExtent !== undefined;

  if (clipped) {
    this.clip(context, frameState,
    /** @type {ol.Extent} */
    clipExtent);
  }

  var replayGroup = this.replayGroup_;

  if (replayGroup && !replayGroup.isEmpty()) {
    if (this.declutterTree_) {
      this.declutterTree_.clear();
    }

    var layer =
    /** @type {ol.layer.Vector} */
    this.getLayer();
    var drawOffsetX = 0;
    var drawOffsetY = 0;
    var replayContext;
    var transparentLayer = layerState.opacity !== 1;
    var hasRenderListeners = layer.hasListener(_eventtype4.default.RENDER);

    if (transparentLayer || hasRenderListeners) {
      var drawWidth = context.canvas.width;
      var drawHeight = context.canvas.height;

      if (rotation) {
        var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
        drawOffsetX = (drawSize - drawWidth) / 2;
        drawOffsetY = (drawSize - drawHeight) / 2;
        drawWidth = drawHeight = drawSize;
      } // resize and clear


      this.context.canvas.width = drawWidth;
      this.context.canvas.height = drawHeight;
      replayContext = this.context;
    } else {
      replayContext = context;
    }

    var alpha = replayContext.globalAlpha;

    if (!transparentLayer) {
      // for performance reasons, context.save / context.restore is not used
      // to save and restore the transformation matrix and the opacity.
      // see http://jsperf.com/context-save-restore-versus-variable
      replayContext.globalAlpha = layerState.opacity;
    }

    if (replayContext != context) {
      replayContext.translate(drawOffsetX, drawOffsetY);
    }

    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;

    _canvas2.default.rotateAtOffset(replayContext, -rotation, width / 2, height / 2);

    replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);

    if (vectorSource.getWrapX() && projection.canWrapX() && !_extent2.default.containsExtent(projectionExtent, extent)) {
      var startX = extent[0];

      var worldWidth = _extent2.default.getWidth(projectionExtent);

      var world = 0;
      var offsetX;

      while (startX < projectionExtent[0]) {
        --world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX += worldWidth;
      }

      world = 0;
      startX = extent[2];

      while (startX > projectionExtent[2]) {
        ++world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX -= worldWidth;
      } // restore original transform for render and compose events


      transform = this.getTransform(frameState, 0);
    }

    _canvas2.default.rotateAtOffset(replayContext, rotation, width / 2, height / 2);

    if (replayContext != context) {
      if (hasRenderListeners) {
        this.dispatchRenderEvent(replayContext, frameState, transform);
      }

      if (transparentLayer) {
        var mainContextAlpha = context.globalAlpha;
        context.globalAlpha = layerState.opacity;
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
        context.globalAlpha = mainContextAlpha;
      } else {
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
      }

      replayContext.translate(-drawOffsetX, -drawOffsetY);
    }

    if (!transparentLayer) {
      replayContext.globalAlpha = alpha;
    }
  }

  if (clipped) {
    context.restore();
  }

  this.postCompose(context, frameState, layerState, transform);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_) {
    return undefined;
  } else {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer =
    /** @type {ol.layer.Vector} */
    this.getLayer();
    /** @type {Object.<string, boolean>} */

    var features = {};
    var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = _index2.default.getUid(feature).toString();

      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    }, null);
    return result;
  }
};
/**
 * @param {ol.events.Event} event Event.
 */


_ol_renderer_canvas_VectorLayer_.prototype.handleFontsChanged_ = function (event) {
  var layer = this.getLayer();

  if (layer.getVisible() && this.replayGroup_) {
    layer.changed();
  }
};
/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */


_ol_renderer_canvas_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var vectorLayer =
  /** @type {ol.layer.Vector} */
  this.getLayer();
  var vectorSource = vectorLayer.getSource();
  this.updateLogos(frameState, vectorSource);
  var animating = frameState.viewHints[_viewhint2.default.ANIMATING];
  var interacting = frameState.viewHints[_viewhint2.default.INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

  if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
    return true;
  }

  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = _vector2.default.defaultOrder;
  }

  var extent = _extent2.default.buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);

  var projectionExtent = viewState.projection.getExtent();

  if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !_extent2.default.containsExtent(projectionExtent, frameState.extent)) {
    // For the replay group, we need an extent that intersects the real world
    // (-180° to +180°). To support geometries in a coordinate range from -540°
    // to +540°, we add at least 1 world width on each side of the projection
    // extent. If the viewport is wider than the world, we need to add half of
    // the viewport width to make sure we cover the whole viewport.
    var worldWidth = _extent2.default.getWidth(projectionExtent);

    var buffer = Math.max(_extent2.default.getWidth(extent) / 2, worldWidth);
    extent[0] = projectionExtent[0] - buffer;
    extent[2] = projectionExtent[2] + buffer;
  }

  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && _extent2.default.containsExtent(this.renderedExtent_, extent)) {
    this.replayGroupChanged = false;
    return true;
  }

  this.replayGroup_ = null;
  this.dirty_ = false;
  var replayGroup = new _replaygroup2.default(_vector2.default.getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  /**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.canvas.VectorLayer}
   */

  var renderFeature = function (feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();

    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }

    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  }.bind(this);

  if (vectorLayerRenderOrder) {
    /** @type {Array.<ol.Feature>} */
    var features = [];
    vectorSource.forEachFeatureInExtent(extent,
    /**
     * @param {ol.Feature} feature Feature.
     */
    function (feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);

    for (var i = 0, ii = features.length; i < ii; ++i) {
      renderFeature(features[i]);
    }
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }

  replayGroup.finish();
  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;
  this.replayGroupChanged = true;
  return true;
};
/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */


_ol_renderer_canvas_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }

  var loading = false;

  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = _vector2.default.renderFeature(replayGroup, feature, styles[i], _vector2.default.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = _vector2.default.renderFeature(replayGroup, feature, styles, _vector2.default.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);
  }

  return loading;
};

exports.default = _ol_renderer_canvas_VectorLayer_;

},{"../../dom.js":47,"../../events.js":49,"../../events/eventtype.js":53,"../../extent.js":55,"../../index.js":90,"../../layertype.js":114,"../../render/canvas.js":151,"../../render/canvas/replaygroup.js":158,"../../render/eventtype.js":161,"../../viewhint.js":247,"../canvas/layer.js":186,"../type.js":193,"../vector.js":194,"rbush":258}],190:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _tilestate = require("../../tilestate.js");

var _tilestate2 = _interopRequireDefault(_tilestate);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("../../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _rbush = require("rbush");

var _rbush2 = _interopRequireDefault(_rbush);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _vectortilerendertype = require("../../layer/vectortilerendertype.js");

var _vectortilerendertype2 = _interopRequireDefault(_vectortilerendertype);

var _proj = require("../../proj.js");

var _proj2 = _interopRequireDefault(_proj);

var _units = require("../../proj/units.js");

var _units2 = _interopRequireDefault(_units);

var _replaytype = require("../../render/replaytype.js");

var _replaytype2 = _interopRequireDefault(_replaytype);

var _canvas = require("../../render/canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _replaygroup = require("../../render/canvas/replaygroup.js");

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _replay = require("../../render/replay.js");

var _replay2 = _interopRequireDefault(_replay);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _tilelayer = require("../canvas/tilelayer.js");

var _tilelayer2 = _interopRequireDefault(_tilelayer);

var _vector = require("../vector.js");

var _vector2 = _interopRequireDefault(_vector);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.renderer.canvas.TileLayer}
 * @param {ol.layer.VectorTile} layer VectorTile layer.
 * @api
 */
var _ol_renderer_canvas_VectorTileLayer_ = function (layer) {
  /**
   * @type {CanvasRenderingContext2D}
   */
  this.context = null;

  _tilelayer2.default.call(this, layer);
  /**
   * Declutter tree.
   * @private
     */


  this.declutterTree_ = layer.getDeclutter() ? (0, _rbush2.default)(9) : null;
  /**
   * @private
   * @type {boolean}
   */

  this.dirty_ = false;
  /**
   * @private
   * @type {number}
   */

  this.renderedLayerRevision_;
  /**
   * @private
   * @type {ol.Transform}
   */

  this.tmpTransform_ = _transform2.default.create(); // Use lower resolution for pure vector rendering. Closest resolution otherwise.

  this.zDirection = layer.getRenderMode() == _vectortilerendertype2.default.VECTOR ? 1 : 0;

  _events2.default.listen(_canvas2.default.labelCache, _eventtype2.default.CLEAR, this.handleFontsChanged_, this);
};

_index2.default.inherits(_ol_renderer_canvas_VectorTileLayer_, _tilelayer2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_canvas_VectorTileLayer_['handles'] = function (type, layer) {
  return type === _type2.default.CANVAS && layer.getType() === _layertype2.default.VECTOR_TILE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.VectorTileLayer} The layer renderer.
 */


_ol_renderer_canvas_VectorTileLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_canvas_VectorTileLayer_(
  /** @type {ol.layer.VectorTile} */
  layer);
};
/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */


_ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS = {
  'image': [_replaytype2.default.POLYGON, _replaytype2.default.CIRCLE, _replaytype2.default.LINE_STRING, _replaytype2.default.IMAGE, _replaytype2.default.TEXT],
  'hybrid': [_replaytype2.default.POLYGON, _replaytype2.default.LINE_STRING]
};
/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */

_ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS = {
  'image': [_replaytype2.default.DEFAULT],
  'hybrid': [_replaytype2.default.IMAGE, _replaytype2.default.TEXT, _replaytype2.default.DEFAULT],
  'vector': _replay2.default.ORDER
};
/**
 * @inheritDoc
 */

_ol_renderer_canvas_VectorTileLayer_.prototype.disposeInternal = function () {
  _events2.default.unlisten(_canvas2.default.labelCache, _eventtype2.default.CLEAR, this.handleFontsChanged_, this);

  _tilelayer2.default.prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var layer = this.getLayer();
  var layerRevision = layer.getRevision();

  if (this.renderedLayerRevision_ != layerRevision) {
    this.renderedTiles.length = 0;
    var renderMode = layer.getRenderMode();

    if (!this.context && renderMode != _vectortilerendertype2.default.VECTOR) {
      this.context = _dom2.default.createCanvasContext2D();
    }

    if (this.context && renderMode == _vectortilerendertype2.default.VECTOR) {
      this.context = null;
    }
  }

  this.renderedLayerRevision_ = layerRevision;
  return _tilelayer2.default.prototype.prepareFrame.apply(this, arguments);
};
/**
 * @param {ol.VectorImageTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.createReplayGroup_ = function (tile, frameState) {
  var layer = this.getLayer();
  var pixelRatio = frameState.pixelRatio;
  var projection = frameState.viewState.projection;
  var revision = layer.getRevision();
  var renderOrder =
  /** @type {ol.RenderOrderFunction} */
  layer.getRenderOrder() || null;
  var replayState = tile.getReplayState(layer);

  if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {
    return;
  }

  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var sourceTileGrid = source.getTileGrid();
  var tileGrid = source.getTileGridForProjection(projection);
  var resolution = tileGrid.getResolution(tile.tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
  var zIndexKeys = {};

  for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
    var sourceTile = tile.getTile(tile.tileKeys[t]);

    if (sourceTile.getState() == _tilestate2.default.ERROR) {
      continue;
    }

    var sourceTileCoord = sourceTile.tileCoord;
    var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);

    var sharedExtent = _extent2.default.getIntersection(tileExtent, sourceTileExtent);

    var bufferedExtent = _extent2.default.equals(sourceTileExtent, sharedExtent) ? null : _extent2.default.buffer(sharedExtent, layer.getRenderBuffer() * resolution);
    var tileProjection = sourceTile.getProjection();
    var reproject = false;

    if (!_proj2.default.equivalent(projection, tileProjection)) {
      reproject = true;
      sourceTile.setProjection(projection);
    }

    replayState.dirty = false;
    var replayGroup = new _replaygroup2.default(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());

    var squaredTolerance = _vector2.default.getSquaredTolerance(resolution, pixelRatio);
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @this {ol.renderer.canvas.VectorTileLayer}
     */


    var renderFeature = function (feature) {
      var styles;
      var styleFunction = feature.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction.call(
        /** @type {ol.Feature} */
        feature, resolution);
      } else {
        styleFunction = layer.getStyleFunction();

        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
      }

      if (styles) {
        var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
        replayState.dirty = replayState.dirty || dirty;
      }
    };

    var features = sourceTile.getFeatures();

    if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
      features.sort(renderOrder);
    }

    var feature;

    for (var i = 0, ii = features.length; i < ii; ++i) {
      feature = features[i];

      if (reproject) {
        if (tileProjection.getUnits() == _units2.default.TILE_PIXELS) {
          // projected tile extent
          tileProjection.setWorldExtent(sourceTileExtent); // tile extent in tile pixel space

          tileProjection.setExtent(sourceTile.getExtent());
        }

        feature.getGeometry().transform(tileProjection, projection);
      }

      if (!bufferedExtent || _extent2.default.intersects(bufferedExtent, feature.getGeometry().getExtent())) {
        renderFeature.call(this, feature);
      }
    }

    replayGroup.finish();

    for (var r in replayGroup.getReplays()) {
      zIndexKeys[r] = true;
    }

    sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
  }

  replayState.renderedRevision = revision;
  replayState.renderedRenderOrder = renderOrder;
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var vectorImageTile =
  /** @type {ol.VectorImageTile} */
  tile;
  this.createReplayGroup_(vectorImageTile, frameState);

  if (this.context) {
    this.renderTileImage_(vectorImageTile, frameState, layerState);

    _tilelayer2.default.prototype.drawTileImage.apply(this, arguments);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
  var layer = this.getLayer();
  /** @type {Object.<string, boolean>} */

  var features = {};
  /** @type {Array.<ol.VectorImageTile>} */

  var renderedTiles = this.renderedTiles;
  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var bufferedExtent, found;
  var i, ii, replayGroup;
  var tile, tileCoord, tileExtent;

  for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
    tile = renderedTiles[i];
    tileCoord = tile.wrappedTileCoord;
    tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    bufferedExtent = _extent2.default.buffer(tileExtent, hitTolerance * resolution, bufferedExtent);

    if (!_extent2.default.containsCoordinate(bufferedExtent, coordinate)) {
      continue;
    }

    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);

      if (sourceTile.getState() == _tilestate2.default.ERROR) {
        continue;
      }

      replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
      /**
       * @param {ol.Feature|ol.render.Feature} feature Feature.
       * @return {?} Callback result.
       */
      function (feature) {
        var key = _index2.default.getUid(feature).toString();

        if (!(key in features)) {
          features[key] = true;
          return callback.call(thisArg, feature, layer);
        }
      }, null);
    }
  }

  return found;
};
/**
 * @param {ol.VectorTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @return {ol.Transform} transform Transform.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.getReplayTransform_ = function (tile, frameState) {
  var layer = this.getLayer();
  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var tileGrid = source.getTileGrid();
  var tileCoord = tile.tileCoord;
  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var renderResolution = viewState.resolution / pixelRatio;
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
  var center = viewState.center;

  var origin = _extent2.default.getTopLeft(tileExtent);

  var size = frameState.size;
  var offsetX = Math.round(pixelRatio * size[0] / 2);
  var offsetY = Math.round(pixelRatio * size[1] / 2);
  return _transform2.default.compose(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);
};
/**
 * @param {ol.events.Event} event Event.
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.handleFontsChanged_ = function (event) {
  var layer = this.getLayer();

  if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
    layer.changed();
  }
};
/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};
/**
 * @inheritDoc
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.postCompose = function (context, frameState, layerState) {
  var layer = this.getLayer();
  var declutterReplays = layer.getDeclutter() ? {} : null;
  var source =
  /** @type {ol.source.VectorTile} */
  layer.getSource();
  var renderMode = layer.getRenderMode();
  var replayTypes = _ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS[renderMode];
  var pixelRatio = frameState.pixelRatio;
  var rotation = frameState.viewState.rotation;
  var size = frameState.size;
  var offsetX, offsetY;

  if (rotation) {
    offsetX = Math.round(pixelRatio * size[0] / 2);
    offsetY = Math.round(pixelRatio * size[1] / 2);

    _canvas2.default.rotateAtOffset(context, -rotation, offsetX, offsetY);
  }

  if (declutterReplays) {
    this.declutterTree_.clear();
  }

  var tiles = this.renderedTiles;
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var clips = [];
  var zs = [];

  for (var i = tiles.length - 1; i >= 0; --i) {
    var tile =
    /** @type {ol.VectorImageTile} */
    tiles[i];

    if (tile.getState() == _tilestate2.default.ABORT) {
      continue;
    }

    var tileCoord = tile.tileCoord;
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord)[0] - tileGrid.getTileCoordExtent(tile.wrappedTileCoord)[0];
    var transform = undefined;

    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);

      if (sourceTile.getState() == _tilestate2.default.ERROR) {
        continue;
      }

      var replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());

      if (renderMode != _vectortilerendertype2.default.VECTOR && !replayGroup.hasReplays(replayTypes)) {
        continue;
      }

      if (!transform) {
        transform = this.getTransform(frameState, worldOffset);
      }

      var currentZ = sourceTile.tileCoord[0];
      var currentClip = replayGroup.getClipCoords(transform);
      context.save();
      context.globalAlpha = layerState.opacity; // Create a clip mask for regions in this low resolution tile that are
      // already filled by a higher resolution tile

      for (var j = 0, jj = clips.length; j < jj; ++j) {
        var clip = clips[j];

        if (currentZ < zs[j]) {
          context.beginPath(); // counter-clockwise (outer ring) for current tile

          context.moveTo(currentClip[0], currentClip[1]);
          context.lineTo(currentClip[2], currentClip[3]);
          context.lineTo(currentClip[4], currentClip[5]);
          context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile

          context.moveTo(clip[6], clip[7]);
          context.lineTo(clip[4], clip[5]);
          context.lineTo(clip[2], clip[3]);
          context.lineTo(clip[0], clip[1]);
          context.clip();
        }
      }

      replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);
      context.restore();
      clips.push(currentClip);
      zs.push(currentZ);
    }
  }

  if (declutterReplays) {
    _replaygroup2.default.replayDeclutter(declutterReplays, context, rotation);
  }

  if (rotation) {
    _canvas2.default.rotateAtOffset(context, rotation,
    /** @type {number} */
    offsetX,
    /** @type {number} */
    offsetY);
  }

  _tilelayer2.default.prototype.postCompose.apply(this, arguments);
};
/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.renderFeature = function (feature, squaredTolerance, styles, replayGroup) {
  if (!styles) {
    return false;
  }

  var loading = false;

  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = _vector2.default.renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = _vector2.default.renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);
  }

  return loading;
};
/**
 * @param {ol.VectorImageTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @private
 */


_ol_renderer_canvas_VectorTileLayer_.prototype.renderTileImage_ = function (tile, frameState, layerState) {
  var layer = this.getLayer();
  var replayState = tile.getReplayState(layer);
  var revision = layer.getRevision();

  var replays = _ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS[layer.getRenderMode()];

  if (replays && replayState.renderedTileRevision !== revision) {
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var pixelRatio = frameState.pixelRatio;
    var source =
    /** @type {ol.source.VectorTile} */
    layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer);
    var size = source.getTilePixelSize(z, pixelRatio, frameState.viewState.projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord);

    for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
      var sourceTile = tile.getTile(tile.tileKeys[i]);

      if (sourceTile.getState() == _tilestate2.default.ERROR) {
        continue;
      }

      var pixelScale = pixelRatio / resolution;

      var transform = _transform2.default.reset(this.tmpTransform_);

      _transform2.default.scale(transform, pixelScale, -pixelScale);

      _transform2.default.translate(transform, -tileExtent[0], -tileExtent[3]);

      var replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      replayGroup.replay(context, transform, 0, {}, replays);
    }
  }
};

exports.default = _ol_renderer_canvas_VectorTileLayer_;

},{"../../dom.js":47,"../../events.js":49,"../../events/eventtype.js":53,"../../extent.js":55,"../../index.js":90,"../../layer/vectortilerendertype.js":113,"../../layertype.js":114,"../../proj.js":142,"../../proj/units.js":149,"../../render/canvas.js":151,"../../render/canvas/replaygroup.js":158,"../../render/replay.js":162,"../../render/replaytype.js":164,"../../tilestate.js":243,"../../transform.js":244,"../canvas/tilelayer.js":188,"../type.js":193,"../vector.js":194,"rbush":258}],191:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _observable = require("../observable.js");

var _observable2 = _interopRequireDefault(_observable);

var _tilestate = require("../tilestate.js");

var _tilestate2 = _interopRequireDefault(_tilestate);

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _state = require("../source/state.js");

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.Observable}
 * @param {ol.layer.Layer} layer Layer.
 * @struct
 */
var _ol_renderer_Layer_ = function (layer) {
  _observable2.default.call(this);
  /**
   * @private
   * @type {ol.layer.Layer}
   */


  this.layer_ = layer;
};

_index2.default.inherits(_ol_renderer_Layer_, _observable2.default);
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}
 *     callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T
 */


_ol_renderer_Layer_.prototype.forEachFeatureAtCoordinate = _index2.default.nullFunction;
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @return {boolean} Is there a feature at the given coordinate?
 */

_ol_renderer_Layer_.prototype.hasFeatureAtCoordinate = _functions2.default.FALSE;
/**
 * Create a function that adds loaded tiles to the tile lookup.
 * @param {ol.source.Tile} source Tile source.
 * @param {ol.proj.Projection} projection Projection of the tiles.
 * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded
 *     tiles by zoom level.
 * @return {function(number, ol.TileRange):boolean} A function that can be
 *     called with a zoom level and a tile range to add loaded tiles to the
 *     lookup.
 * @protected
 */

_ol_renderer_Layer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
  return (
    /**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */
    function (zoom, tileRange) {
      function callback(tile) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }

        tiles[zoom][tile.tileCoord.toString()] = tile;
      }

      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }
  );
};
/**
 * @return {ol.layer.Layer} Layer.
 */


_ol_renderer_Layer_.prototype.getLayer = function () {
  return this.layer_;
};
/**
 * Handle changes in image state.
 * @param {ol.events.Event} event Image change event.
 * @private
 */


_ol_renderer_Layer_.prototype.handleImageChange_ = function (event) {
  var image =
  /** @type {ol.Image} */
  event.target;

  if (image.getState() === _imagestate2.default.LOADED) {
    this.renderIfReadyAndVisible();
  }
};
/**
 * Load the image if not already loaded, and register the image change
 * listener if needed.
 * @param {ol.ImageBase} image Image.
 * @return {boolean} `true` if the image is already loaded, `false`
 *     otherwise.
 * @protected
 */


_ol_renderer_Layer_.prototype.loadImage = function (image) {
  var imageState = image.getState();

  if (imageState != _imagestate2.default.LOADED && imageState != _imagestate2.default.ERROR) {
    _events2.default.listen(image, _eventtype2.default.CHANGE, this.handleImageChange_, this);
  }

  if (imageState == _imagestate2.default.IDLE) {
    image.load();
    imageState = image.getState();
  }

  return imageState == _imagestate2.default.LOADED;
};
/**
 * @protected
 */


_ol_renderer_Layer_.prototype.renderIfReadyAndVisible = function () {
  var layer = this.getLayer();

  if (layer.getVisible() && layer.getSourceState() == _state2.default.READY) {
    this.changed();
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @protected
 */


_ol_renderer_Layer_.prototype.scheduleExpireCache = function (frameState, tileSource) {
  if (tileSource.canExpireCache()) {
    /**
     * @param {ol.source.Tile} tileSource Tile source.
     * @param {ol.PluggableMap} map Map.
     * @param {olx.FrameState} frameState Frame state.
     */
    var postRenderFunction = function (tileSource, map, frameState) {
      var tileSourceKey = _index2.default.getUid(tileSource).toString();

      if (tileSourceKey in frameState.usedTiles) {
        tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
      }
    }.bind(null, tileSource);

    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */
    postRenderFunction);
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Source} source Source.
 * @protected
 */


_ol_renderer_Layer_.prototype.updateLogos = function (frameState, source) {
  var logo = source.getLogo();

  if (logo !== undefined) {
    if (typeof logo === 'string') {
      frameState.logos[logo] = '';
    } else if (logo) {
      _asserts2.default.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.


      _asserts2.default.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.


      frameState.logos[logo.src] = logo.href;
    }
  }
};
/**
 * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {number} z Z.
 * @param {ol.TileRange} tileRange Tile range.
 * @protected
 */


_ol_renderer_Layer_.prototype.updateUsedTiles = function (usedTiles, tileSource, z, tileRange) {
  // FIXME should we use tilesToDrawByZ instead?
  var tileSourceKey = _index2.default.getUid(tileSource).toString();

  var zKey = z.toString();

  if (tileSourceKey in usedTiles) {
    if (zKey in usedTiles[tileSourceKey]) {
      usedTiles[tileSourceKey][zKey].extend(tileRange);
    } else {
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  } else {
    usedTiles[tileSourceKey] = {};
    usedTiles[tileSourceKey][zKey] = tileRange;
  }
};
/**
 * Manage tile pyramid.
 * This function performs a number of functions related to the tiles at the
 * current zoom and lower zoom levels:
 * - registers idle tiles in frameState.wantedTiles so that they are not
 *   discarded by the tile queue
 * - enqueues missing tiles
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {ol.Extent} extent Extent.
 * @param {number} currentZ Current Z.
 * @param {number} preload Load low resolution tiles up to 'preload' levels.
 * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.
 * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
 * @protected
 * @template T
 */


_ol_renderer_Layer_.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {
  var tileSourceKey = _index2.default.getUid(tileSource).toString();

  if (!(tileSourceKey in frameState.wantedTiles)) {
    frameState.wantedTiles[tileSourceKey] = {};
  }

  var wantedTiles = frameState.wantedTiles[tileSourceKey];
  var tileQueue = frameState.tileQueue;
  var minZoom = tileGrid.getMinZoom();
  var tile, tileRange, tileResolution, x, y, z;

  for (z = minZoom; z <= currentZ; ++z) {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
    tileResolution = tileGrid.getResolution(z);

    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (currentZ - z <= preload) {
          tile = tileSource.getTile(z, x, y, pixelRatio, projection);

          if (tile.getState() == _tilestate2.default.IDLE) {
            wantedTiles[tile.getKey()] = true;

            if (!tileQueue.isKeyQueued(tile.getKey())) {
              tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
            }
          }

          if (opt_tileCallback !== undefined) {
            opt_tileCallback.call(opt_this, tile);
          }
        } else {
          tileSource.useTile(z, x, y, projection);
        }
      }
    }
  }
};

exports.default = _ol_renderer_Layer_;

},{"../asserts.js":32,"../events.js":49,"../events/eventtype.js":53,"../functions.js":61,"../imagestate.js":89,"../index.js":90,"../observable.js":128,"../source/state.js":213,"../tilestate.js":243}],192:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _disposable = require("../disposable.js");

var _disposable2 = _interopRequireDefault(_disposable);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _layer = require("../layer/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _plugins = require("../plugins.js");

var _plugins2 = _interopRequireDefault(_plugins);

var _style = require("../style.js");

var _style2 = _interopRequireDefault(_style);

var _transform = require("../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @extends {ol.Disposable}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @struct
 */
var _ol_renderer_Map_ = function (container, map) {
  _disposable2.default.call(this);
  /**
   * @private
   * @type {ol.PluggableMap}
   */


  this.map_ = map;
  /**
   * @private
   * @type {Object.<string, ol.renderer.Layer>}
   */

  this.layerRenderers_ = {};
  /**
   * @private
   * @type {Object.<string, ol.EventsKey>}
   */

  this.layerRendererListeners_ = {};
};

_index2.default.inherits(_ol_renderer_Map_, _disposable2.default);
/**
 * @param {olx.FrameState} frameState FrameState.
 * @protected
 */


_ol_renderer_Map_.prototype.calculateMatrices2D = function (frameState) {
  var viewState = frameState.viewState;
  var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
  var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

  _transform2.default.compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);

  _transform2.default.invert(_transform2.default.setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));
};
/**
 * Removes all layer renderers.
 */


_ol_renderer_Map_.prototype.removeLayerRenderers = function () {
  for (var key in this.layerRenderers_) {
    this.removeLayerRendererByKey_(key).dispose();
  }
};
/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_Map_.expireIconCache_ = function (map, frameState) {
  var cache = _style2.default.iconImageCache;
  cache.expire();
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @param {ol.layer.Layer} layer Layer.
   * @return {?} Callback result.
   */

  function forEachFeatureAtCoordinate(feature, layer) {
    var key = _index2.default.getUid(feature).toString();

    var managed = frameState.layerStates[_index2.default.getUid(layer)].managed;

    if (!(key in frameState.skippedFeatureUids && !managed)) {
      return callback.call(thisArg, feature, managed ? layer : null);
    }
  }

  var projection = viewState.projection;
  var translatedCoordinate = coordinate;

  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();

    var worldWidth = _extent2.default.getWidth(projectionExtent);

    var x = coordinate[0];

    if (x < projectionExtent[0] || x > projectionExtent[2]) {
      var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
      translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
    }
  }

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer2.default.visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);

      if (layer.getSource()) {
        result = layerRenderer.forEachFeatureAtCoordinate(layer.getSource().getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);
      }

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};
/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
 * @return {boolean} Is there a feature at the given coordinate?
 * @template U
 */


_ol_renderer_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, _functions2.default.TRUE, this, layerFilter, thisArg);
  return hasFeature !== undefined;
};
/**
 * @param {ol.layer.Layer} layer Layer.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */


_ol_renderer_Map_.prototype.getLayerRenderer = function (layer) {
  var layerKey = _index2.default.getUid(layer).toString();

  if (layerKey in this.layerRenderers_) {
    return this.layerRenderers_[layerKey];
  } else {
    var layerRendererPlugins = _plugins2.default.getLayerRendererPlugins();

    var renderer;
    var type = this.getType();

    for (var i = 0, ii = layerRendererPlugins.length; i < ii; ++i) {
      var plugin = layerRendererPlugins[i];

      if (plugin['handles'](type, layer)) {
        renderer = plugin['create'](this, layer);
        break;
      }
    }

    if (renderer) {
      this.layerRenderers_[layerKey] = renderer;
      this.layerRendererListeners_[layerKey] = _events2.default.listen(renderer, _eventtype2.default.CHANGE, this.handleLayerRendererChange_, this);
    } else {
      throw new Error('Unable to create renderer for layer: ' + layer.getType());
    }

    return renderer;
  }
};
/**
 * @param {string} layerKey Layer key.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */


_ol_renderer_Map_.prototype.getLayerRendererByKey = function (layerKey) {
  return this.layerRenderers_[layerKey];
};
/**
 * @protected
 * @return {Object.<string, ol.renderer.Layer>} Layer renderers.
 */


_ol_renderer_Map_.prototype.getLayerRenderers = function () {
  return this.layerRenderers_;
};
/**
 * @return {ol.PluggableMap} Map.
 */


_ol_renderer_Map_.prototype.getMap = function () {
  return this.map_;
};
/**
 * @abstract
 * @return {ol.renderer.Type} Type
 */


_ol_renderer_Map_.prototype.getType = function () {};
/**
 * Handle changes in a layer renderer.
 * @private
 */


_ol_renderer_Map_.prototype.handleLayerRendererChange_ = function () {
  this.map_.render();
};
/**
 * @param {string} layerKey Layer key.
 * @return {ol.renderer.Layer} Layer renderer.
 * @private
 */


_ol_renderer_Map_.prototype.removeLayerRendererByKey_ = function (layerKey) {
  var layerRenderer = this.layerRenderers_[layerKey];
  delete this.layerRenderers_[layerKey];

  _events2.default.unlistenByKey(this.layerRendererListeners_[layerKey]);

  delete this.layerRendererListeners_[layerKey];
  return layerRenderer;
};
/**
 * Render.
 * @param {?olx.FrameState} frameState Frame state.
 */


_ol_renderer_Map_.prototype.renderFrame = _index2.default.nullFunction;
/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */

_ol_renderer_Map_.prototype.removeUnusedLayerRenderers_ = function (map, frameState) {
  var layerKey;

  for (layerKey in this.layerRenderers_) {
    if (!frameState || !(layerKey in frameState.layerStates)) {
      this.removeLayerRendererByKey_(layerKey).dispose();
    }
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 */


_ol_renderer_Map_.prototype.scheduleExpireIconCache = function (frameState) {
  frameState.postRenderFunctions.push(
  /** @type {ol.PostRenderFunction} */
  _ol_renderer_Map_.expireIconCache_);
};
/**
 * @param {!olx.FrameState} frameState Frame state.
 * @protected
 */


_ol_renderer_Map_.prototype.scheduleRemoveUnusedLayerRenderers = function (frameState) {
  var layerKey;

  for (layerKey in this.layerRenderers_) {
    if (!(layerKey in frameState.layerStates)) {
      frameState.postRenderFunctions.push(
      /** @type {ol.PostRenderFunction} */
      this.removeUnusedLayerRenderers_.bind(this));
      return;
    }
  }
};
/**
 * @param {ol.LayerState} state1 First layer state.
 * @param {ol.LayerState} state2 Second layer state.
 * @return {number} The zIndex difference.
 */


_ol_renderer_Map_.sortByZIndex = function (state1, state2) {
  return state1.zIndex - state2.zIndex;
};

exports.default = _ol_renderer_Map_;

},{"../disposable.js":46,"../events.js":49,"../events/eventtype.js":53,"../extent.js":55,"../functions.js":61,"../index.js":90,"../layer/layer.js":109,"../plugins.js":132,"../style.js":222,"../transform.js":244}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Available renderers: `'canvas'` or `'webgl'`.
 * @enum {string}
 */
var _ol_renderer_Type_ = {
  CANVAS: 'canvas',
  WEBGL: 'webgl'
};
exports.default = _ol_renderer_Type_;

},{}],194:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _geometrytype = require("../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _replaytype = require("../render/replaytype.js");

var _replaytype2 = _interopRequireDefault(_replaytype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_renderer_vector_ = {};
/**
 * @param {ol.Feature|ol.render.Feature} feature1 Feature 1.
 * @param {ol.Feature|ol.render.Feature} feature2 Feature 2.
 * @return {number} Order.
 */

_ol_renderer_vector_.defaultOrder = function (feature1, feature2) {
  return _index2.default.getUid(feature1) - _index2.default.getUid(feature2);
};
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */


_ol_renderer_vector_.getSquaredTolerance = function (resolution, pixelRatio) {
  var tolerance = _ol_renderer_vector_.getTolerance(resolution, pixelRatio);

  return tolerance * tolerance;
};
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */


_ol_renderer_vector_.getTolerance = function (resolution, pixelRatio) {
  return _index2.default.SIMPLIFY_TOLERANCE * resolution / pixelRatio;
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Circle} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderCircleGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */


_ol_renderer_vector_.renderFeature = function (replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle, imageState;
  imageStyle = style.getImage();

  if (imageStyle) {
    imageState = imageStyle.getImageState();

    if (imageState == _imagestate2.default.LOADED || imageState == _imagestate2.default.ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == _imagestate2.default.IDLE) {
        imageStyle.load();
      }

      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }

  _ol_renderer_vector_.renderFeature_(replayGroup, feature, style, squaredTolerance);

  return loading;
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @private
 */


_ol_renderer_vector_.renderFeature_ = function (replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry) {
    return;
  }

  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var renderer = style.getRenderer();

  if (renderer) {
    _ol_renderer_vector_.renderGeometry_(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[simplifiedGeometry.getType()];

    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderGeometry_ = function (replayGroup, geometry, style, feature) {
  if (geometry.getType() == _geometrytype2.default.GEOMETRY_COLLECTION) {
    var geometries =
    /** @type {ol.geom.GeometryCollection} */
    geometry.getGeometries();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      _ol_renderer_vector_.renderGeometry_(replayGroup, geometries[i], style, feature);
    }

    return;
  }

  var replay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.DEFAULT);
  replay.drawCustom(
  /** @type {ol.geom.SimpleGeometry} */
  geometry, feature, style.getRenderer());
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderGeometryCollectionGeometry_ = function (replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[geometries[i].getType()];

    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.LineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderMultiLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderMultiPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Point|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();

  if (imageStyle) {
    if (imageStyle.getImageState() != _imagestate2.default.LOADED) {
      return;
    }

    var imageReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderMultiPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();

  if (imageStyle) {
    if (imageStyle.getImageState() != _imagestate2.default.LOADED) {
      return;
    }

    var imageReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */


_ol_renderer_vector_.renderPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
/**
 * @const
 * @private
 * @type {Object.<ol.geom.GeometryType,
 *                function(ol.render.ReplayGroup, ol.geom.Geometry,
 *                         ol.style.Style, Object)>}
 */


_ol_renderer_vector_.GEOMETRY_RENDERERS_ = {
  'Point': _ol_renderer_vector_.renderPointGeometry_,
  'LineString': _ol_renderer_vector_.renderLineStringGeometry_,
  'Polygon': _ol_renderer_vector_.renderPolygonGeometry_,
  'MultiPoint': _ol_renderer_vector_.renderMultiPointGeometry_,
  'MultiLineString': _ol_renderer_vector_.renderMultiLineStringGeometry_,
  'MultiPolygon': _ol_renderer_vector_.renderMultiPolygonGeometry_,
  'GeometryCollection': _ol_renderer_vector_.renderGeometryCollectionGeometry_,
  'Circle': _ol_renderer_vector_.renderCircleGeometry_
};
exports.default = _ol_renderer_vector_;

},{"../geom/geometrytype.js":80,"../imagestate.js":89,"../index.js":90,"../render/replaytype.js":164}],195:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _fragment = require("../../webgl/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require("../../webgl/vertex.js");

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit
var _ol_renderer_webgl_defaultmapshader_ = {};
_ol_renderer_webgl_defaultmapshader_.fragment = new _fragment2.default(_index2.default.DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_texture, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  gl_FragColor.a = texColor.a * u_opacity;\n}\n' : 'precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}');
_ol_renderer_webgl_defaultmapshader_.vertex = new _vertex2.default(_index2.default.DEBUG_WEBGL ? 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_texCoordMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\n}\n\n\n' : 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}');
exports.default = _ol_renderer_webgl_defaultmapshader_;

},{"../../index.js":90,"../../webgl/fragment.js":253,"../../webgl/vertex.js":255}],196:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var _ol_renderer_webgl_defaultmapshader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_texCoordMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_texCoordMatrix' : 'd');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'e');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'f');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_texture = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_texture' : 'g');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'b');
  /**
   * @type {number}
   */

  this.a_texCoord = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_texCoord' : 'c');
};

exports.default = _ol_renderer_webgl_defaultmapshader_Locations_;

},{"../../../index.js":90}],197:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _viewhint = require("../../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _functions = require("../../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _layer = require("../webgl/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _webgl = require("../../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _context = require("../../webgl/context.js");

var _context2 = _interopRequireDefault(_context);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Image} imageLayer Tile layer.
 * @api
 */
var _ol_renderer_webgl_ImageLayer_ = function (mapRenderer, imageLayer) {
  _layer2.default.call(this, mapRenderer, imageLayer);
  /**
   * The last rendered image.
   * @private
   * @type {?ol.ImageBase}
   */


  this.image_ = null;
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.hitCanvasContext_ = null;
  /**
   * @private
   * @type {?ol.Transform}
   */

  this.hitTransformationMatrix_ = null;
};

_index2.default.inherits(_ol_renderer_webgl_ImageLayer_, _layer2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_ImageLayer_['handles'] = function (type, layer) {
  return type === _type2.default.WEBGL && layer.getType() === _layertype2.default.IMAGE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.ImageLayer} The layer renderer.
 */


_ol_renderer_webgl_ImageLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_webgl_ImageLayer_(
  /** @type {ol.renderer.webgl.Map} */
  mapRenderer,
  /** @type {ol.layer.Image} */
  layer);
};
/**
 * @param {ol.ImageBase} image Image.
 * @private
 * @return {WebGLTexture} Texture.
 */


_ol_renderer_webgl_ImageLayer_.prototype.createTexture_ = function (image) {
  // We meet the conditions to work with non-power of two textures.
  // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
  // http://learningwebgl.com/blog/?p=2101
  var imageElement = image.getImage();
  var gl = this.mapRenderer.getGL();
  return _context2.default.createTexture(gl, imageElement, _webgl2.default.CLAMP_TO_EDGE, _webgl2.default.CLAMP_TO_EDGE);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    return callback.call(thisArg, feature, layer);
  });
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.prepareFrame = function (frameState, layerState, context) {
  var gl = this.mapRenderer.getGL();
  var pixelRatio = frameState.pixelRatio;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;
  var viewRotation = viewState.rotation;
  var image = this.image_;
  var texture = this.texture;
  var imageLayer =
  /** @type {ol.layer.Image} */
  this.getLayer();
  var imageSource = imageLayer.getSource();
  var hints = frameState.viewHints;
  var renderedExtent = frameState.extent;

  if (layerState.extent !== undefined) {
    renderedExtent = _extent2.default.getIntersection(renderedExtent, layerState.extent);
  }

  if (!hints[_viewhint2.default.ANIMATING] && !hints[_viewhint2.default.INTERACTING] && !_extent2.default.isEmpty(renderedExtent)) {
    var projection = viewState.projection;

    if (!_index2.default.ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();

      if (sourceProjection) {
        projection = sourceProjection;
      }
    }

    var image_ = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);

    if (image_) {
      var loaded = this.loadImage(image_);

      if (loaded) {
        image = image_;
        texture = this.createTexture_(image_);

        if (this.texture) {
          /**
           * @param {WebGLRenderingContext} gl GL.
           * @param {WebGLTexture} texture Texture.
           */
          var postRenderFunction = function (gl, texture) {
            if (!gl.isContextLost()) {
              gl.deleteTexture(texture);
            }
          }.bind(null, gl, this.texture);

          frameState.postRenderFunctions.push(
          /** @type {ol.PostRenderFunction} */
          postRenderFunction);
        }
      }
    }
  }

  if (image) {
    var canvas = this.mapRenderer.getContext().getCanvas();
    this.updateProjectionMatrix_(canvas.width, canvas.height, pixelRatio, viewCenter, viewResolution, viewRotation, image.getExtent());
    this.hitTransformationMatrix_ = null; // Translate and scale to flip the Y coord.

    var texCoordMatrix = this.texCoordMatrix;

    _transform2.default.reset(texCoordMatrix);

    _transform2.default.scale(texCoordMatrix, 1, -1);

    _transform2.default.translate(texCoordMatrix, 0, -1);

    this.image_ = image;
    this.texture = texture;
    this.updateLogos(frameState, imageSource);
  }

  return !!image;
};
/**
 * @param {number} canvasWidth Canvas width.
 * @param {number} canvasHeight Canvas height.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Coordinate} viewCenter View center.
 * @param {number} viewResolution View resolution.
 * @param {number} viewRotation View rotation.
 * @param {ol.Extent} imageExtent Image extent.
 * @private
 */


_ol_renderer_webgl_ImageLayer_.prototype.updateProjectionMatrix_ = function (canvasWidth, canvasHeight, pixelRatio, viewCenter, viewResolution, viewRotation, imageExtent) {
  var canvasExtentWidth = canvasWidth * viewResolution;
  var canvasExtentHeight = canvasHeight * viewResolution;
  var projectionMatrix = this.projectionMatrix;

  _transform2.default.reset(projectionMatrix);

  _transform2.default.scale(projectionMatrix, pixelRatio * 2 / canvasExtentWidth, pixelRatio * 2 / canvasExtentHeight);

  _transform2.default.rotate(projectionMatrix, -viewRotation);

  _transform2.default.translate(projectionMatrix, imageExtent[0] - viewCenter[0], imageExtent[1] - viewCenter[1]);

  _transform2.default.scale(projectionMatrix, (imageExtent[2] - imageExtent[0]) / 2, (imageExtent[3] - imageExtent[1]) / 2);

  _transform2.default.translate(projectionMatrix, 1, 1);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _functions2.default.TRUE, this);
  return hasFeature !== undefined;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_ImageLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  if (!this.image_ || !this.image_.getImage()) {
    return undefined;
  }

  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _index2.default.nullFunction) {
    // for ImageCanvas sources use the original hit-detection logic,
    // so that for example also transparent polygons are detected
    var coordinate = _transform2.default.apply(frameState.pixelToCoordinateTransform, pixel.slice());

    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _functions2.default.TRUE, this);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  } else {
    var imageSize = [this.image_.getImage().width, this.image_.getImage().height];

    if (!this.hitTransformationMatrix_) {
      this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(frameState.size, imageSize);
    }

    var pixelOnFrameBuffer = _transform2.default.apply(this.hitTransformationMatrix_, pixel.slice());

    if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] || pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {
      // outside the image, no need to check
      return undefined;
    }

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = _dom2.default.createCanvasContext2D(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.image_.getImage(), pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);
    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;

    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};
/**
 * The transformation matrix to get the pixel on the image for a
 * pixel on the map.
 * @param {ol.Size} mapSize The map size.
 * @param {ol.Size} imageSize The image size.
 * @return {ol.Transform} The transformation matrix.
 * @private
 */


_ol_renderer_webgl_ImageLayer_.prototype.getHitTransformationMatrix_ = function (mapSize, imageSize) {
  // the first matrix takes a map pixel, flips the y-axis and scales to
  // a range between -1 ... 1
  var mapCoordTransform = _transform2.default.create();

  _transform2.default.translate(mapCoordTransform, -1, -1);

  _transform2.default.scale(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);

  _transform2.default.translate(mapCoordTransform, 0, mapSize[1]);

  _transform2.default.scale(mapCoordTransform, 1, -1); // the second matrix is the inverse of the projection matrix used in the
  // shader for drawing


  var projectionMatrixInv = _transform2.default.invert(this.projectionMatrix.slice()); // the third matrix scales to the image dimensions and flips the y-axis again


  var transform = _transform2.default.create();

  _transform2.default.translate(transform, 0, imageSize[1]);

  _transform2.default.scale(transform, 1, -1);

  _transform2.default.scale(transform, imageSize[0] / 2, imageSize[1] / 2);

  _transform2.default.translate(transform, 1, 1);

  _transform2.default.multiply(transform, projectionMatrixInv);

  _transform2.default.multiply(transform, mapCoordTransform);

  return transform;
};

exports.default = _ol_renderer_webgl_ImageLayer_;

},{"../../dom.js":47,"../../extent.js":55,"../../functions.js":61,"../../index.js":90,"../../layertype.js":114,"../../transform.js":244,"../../viewhint.js":247,"../../webgl.js":249,"../../webgl/context.js":251,"../type.js":193,"../webgl/layer.js":198}],198:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _event = require("../../render/event.js");

var _event2 = _interopRequireDefault(_event);

var _eventtype = require("../../render/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _immediate = require("../../render/webgl/immediate.js");

var _immediate2 = _interopRequireDefault(_immediate);

var _layer = require("../layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _defaultmapshader = require("../webgl/defaultmapshader.js");

var _defaultmapshader2 = _interopRequireDefault(_defaultmapshader);

var _locations = require("../webgl/defaultmapshader/locations.js");

var _locations2 = _interopRequireDefault(_locations);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _mat = require("../../vec/mat4.js");

var _mat2 = _interopRequireDefault(_mat);

var _webgl = require("../../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _buffer = require("../../webgl/buffer.js");

var _buffer2 = _interopRequireDefault(_buffer);

var _context = require("../../webgl/context.js");

var _context2 = _interopRequireDefault(_context);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Layer} layer Layer.
 */
var _ol_renderer_webgl_Layer_ = function (mapRenderer, layer) {
  _layer2.default.call(this, layer);
  /**
   * @protected
   * @type {ol.renderer.webgl.Map}
   */


  this.mapRenderer = mapRenderer;
  /**
   * @private
   * @type {ol.webgl.Buffer}
   */

  this.arrayBuffer_ = new _buffer2.default([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]);
  /**
   * @protected
   * @type {WebGLTexture}
   */

  this.texture = null;
  /**
   * @protected
   * @type {WebGLFramebuffer}
   */

  this.framebuffer = null;
  /**
   * @protected
   * @type {number|undefined}
   */

  this.framebufferDimension = undefined;
  /**
   * @protected
   * @type {ol.Transform}
   */

  this.texCoordMatrix = _transform2.default.create();
  /**
   * @protected
   * @type {ol.Transform}
   */

  this.projectionMatrix = _transform2.default.create();
  /**
   * @type {Array.<number>}
   * @private
   */

  this.tmpMat4_ = _mat2.default.create();
  /**
   * @private
   * @type {ol.renderer.webgl.defaultmapshader.Locations}
   */

  this.defaultLocations_ = null;
};

_index2.default.inherits(_ol_renderer_webgl_Layer_, _layer2.default);
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} framebufferDimension Framebuffer dimension.
 * @protected
 */


_ol_renderer_webgl_Layer_.prototype.bindFramebuffer = function (frameState, framebufferDimension) {
  var gl = this.mapRenderer.getGL();

  if (this.framebufferDimension === undefined || this.framebufferDimension != framebufferDimension) {
    /**
     * @param {WebGLRenderingContext} gl GL.
     * @param {WebGLFramebuffer} framebuffer Framebuffer.
     * @param {WebGLTexture} texture Texture.
     */
    var postRenderFunction = function (gl, framebuffer, texture) {
      if (!gl.isContextLost()) {
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(texture);
      }
    }.bind(null, gl, this.framebuffer, this.texture);

    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */
    postRenderFunction);

    var texture = _context2.default.createEmptyTexture(gl, framebufferDimension, framebufferDimension);

    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(_webgl2.default.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(_webgl2.default.FRAMEBUFFER, _webgl2.default.COLOR_ATTACHMENT0, _webgl2.default.TEXTURE_2D, texture, 0);
    this.texture = texture;
    this.framebuffer = framebuffer;
    this.framebufferDimension = framebufferDimension;
  } else {
    gl.bindFramebuffer(_webgl2.default.FRAMEBUFFER, this.framebuffer);
  }
};
/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.webgl.Context} context Context.
 */


_ol_renderer_webgl_Layer_.prototype.composeFrame = function (frameState, layerState, context) {
  this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, context, frameState);
  context.bindBuffer(_webgl2.default.ARRAY_BUFFER, this.arrayBuffer_);
  var gl = context.getGL();
  var fragmentShader = _defaultmapshader2.default.fragment;
  var vertexShader = _defaultmapshader2.default.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);
  var locations;

  if (!this.defaultLocations_) {
    locations = new _locations2.default(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  if (context.useProgram(program)) {
    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, _webgl2.default.FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(locations.a_texCoord);
    gl.vertexAttribPointer(locations.a_texCoord, 2, _webgl2.default.FLOAT, false, 16, 8);
    gl.uniform1i(locations.u_texture, 0);
  }

  gl.uniformMatrix4fv(locations.u_texCoordMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, this.getTexCoordMatrix()));
  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, this.getProjectionMatrix()));
  gl.uniform1f(locations.u_opacity, layerState.opacity);
  gl.bindTexture(_webgl2.default.TEXTURE_2D, this.getTexture());
  gl.drawArrays(_webgl2.default.TRIANGLE_STRIP, 0, 4);
  this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, context, frameState);
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {ol.webgl.Context} context WebGL context.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_webgl_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState) {
  var layer = this.getLayer();

  if (layer.hasListener(type)) {
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var extent = frameState.extent;
    var center = viewState.center;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var render = new _immediate2.default(context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new _event2.default(type, render, frameState, null, context);
    layer.dispatchEvent(composeEvent);
  }
};
/**
 * @return {!ol.Transform} Matrix.
 */


_ol_renderer_webgl_Layer_.prototype.getTexCoordMatrix = function () {
  return this.texCoordMatrix;
};
/**
 * @return {WebGLTexture} Texture.
 */


_ol_renderer_webgl_Layer_.prototype.getTexture = function () {
  return this.texture;
};
/**
 * @return {!ol.Transform} Matrix.
 */


_ol_renderer_webgl_Layer_.prototype.getProjectionMatrix = function () {
  return this.projectionMatrix;
};
/**
 * Handle webglcontextlost.
 */


_ol_renderer_webgl_Layer_.prototype.handleWebGLContextLost = function () {
  this.texture = null;
  this.framebuffer = null;
  this.framebufferDimension = undefined;
};
/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.webgl.Context} context Context.
 * @return {boolean} whether composeFrame should be called.
 */


_ol_renderer_webgl_Layer_.prototype.prepareFrame = function (frameState, layerState, context) {};
/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */


_ol_renderer_webgl_Layer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {};

exports.default = _ol_renderer_webgl_Layer_;

},{"../../index.js":90,"../../render/event.js":160,"../../render/eventtype.js":161,"../../render/webgl/immediate.js":171,"../../transform.js":244,"../../vec/mat4.js":245,"../../webgl.js":249,"../../webgl/buffer.js":250,"../../webgl/context.js":251,"../layer.js":191,"../webgl/defaultmapshader.js":195,"../webgl/defaultmapshader/locations.js":196}],199:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _css = require("../../css.js");

var _css2 = _interopRequireDefault(_css);

var _dom = require("../../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("../../events.js");

var _events2 = _interopRequireDefault(_events);

var _has = require("../../has.js");

var _has2 = _interopRequireDefault(_has);

var _layer = require("../../layer/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _event = require("../../render/event.js");

var _event2 = _interopRequireDefault(_event);

var _eventtype = require("../../render/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _immediate = require("../../render/webgl/immediate.js");

var _immediate2 = _interopRequireDefault(_immediate);

var _map = require("../map.js");

var _map2 = _interopRequireDefault(_map);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _state = require("../../source/state.js");

var _state2 = _interopRequireDefault(_state);

var _lrucache = require("../../structs/lrucache.js");

var _lrucache2 = _interopRequireDefault(_lrucache);

var _priorityqueue = require("../../structs/priorityqueue.js");

var _priorityqueue2 = _interopRequireDefault(_priorityqueue);

var _webgl = require("../../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _context = require("../../webgl/context.js");

var _context2 = _interopRequireDefault(_context);

var _contexteventtype = require("../../webgl/contexteventtype.js");

var _contexteventtype2 = _interopRequireDefault(_contexteventtype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME check against gl.getParameter(webgl.MAX_TEXTURE_SIZE)

/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @api
 */
var _ol_renderer_webgl_Map_ = function (container, map) {
  _map2.default.call(this, container, map);
  /**
   * @private
   * @type {HTMLCanvasElement}
   */


  this.canvas_ =
  /** @type {HTMLCanvasElement} */
  document.createElement('CANVAS');
  this.canvas_.style.width = '100%';
  this.canvas_.style.height = '100%';
  this.canvas_.style.display = 'block';
  this.canvas_.className = _css2.default.CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);
  /**
   * @private
   * @type {number}
   */

  this.clipTileCanvasWidth_ = 0;
  /**
   * @private
   * @type {number}
   */

  this.clipTileCanvasHeight_ = 0;
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.clipTileContext_ = _dom2.default.createCanvasContext2D();
  /**
   * @private
   * @type {boolean}
   */

  this.renderedVisible_ = true;
  /**
   * @private
   * @type {WebGLRenderingContext}
   */

  this.gl_ = _webgl2.default.getContext(this.canvas_, {
    antialias: true,
    depth: true,
    failIfMajorPerformanceCaveat: true,
    preserveDrawingBuffer: false,
    stencil: true
  });
  /**
   * @private
   * @type {ol.webgl.Context}
   */

  this.context_ = new _context2.default(this.canvas_, this.gl_);

  _events2.default.listen(this.canvas_, _contexteventtype2.default.LOST, this.handleWebGLContextLost, this);

  _events2.default.listen(this.canvas_, _contexteventtype2.default.RESTORED, this.handleWebGLContextRestored, this);
  /**
   * @private
   * @type {ol.structs.LRUCache.<ol.WebglTextureCacheEntry|null>}
   */


  this.textureCache_ = new _lrucache2.default();
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.focus_ = null;
  /**
   * @private
   * @type {ol.structs.PriorityQueue.<Array>}
   */

  this.tileTextureQueue_ = new _priorityqueue2.default(
  /**
   * @param {Array.<*>} element Element.
   * @return {number} Priority.
   * @this {ol.renderer.webgl.Map}
   */
  function (element) {
    var tileCenter =
    /** @type {ol.Coordinate} */
    element[1];
    var tileResolution =
    /** @type {number} */
    element[2];
    var deltaX = tileCenter[0] - this.focus_[0];
    var deltaY = tileCenter[1] - this.focus_[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  }.bind(this),
  /**
   * @param {Array.<*>} element Element.
   * @return {string} Key.
   */
  function (element) {
    return (
      /** @type {ol.Tile} */
      element[0].getKey()
    );
  });
  /**
   * @param {ol.PluggableMap} map Map.
   * @param {?olx.FrameState} frameState Frame state.
   * @return {boolean} false.
   * @this {ol.renderer.webgl.Map}
   */

  this.loadNextTileTexture_ = function (map, frameState) {
    if (!this.tileTextureQueue_.isEmpty()) {
      this.tileTextureQueue_.reprioritize();
      var element = this.tileTextureQueue_.dequeue();
      var tile =
      /** @type {ol.Tile} */
      element[0];
      var tileSize =
      /** @type {ol.Size} */
      element[3];
      var tileGutter =
      /** @type {number} */
      element[4];
      this.bindTileTexture(tile, tileSize, tileGutter, _webgl2.default.LINEAR, _webgl2.default.LINEAR);
    }

    return false;
  }.bind(this);
  /**
   * @private
   * @type {number}
   */


  this.textureCacheFrameMarkerCount_ = 0;
  this.initializeGL_();
};

_index2.default.inherits(_ol_renderer_webgl_Map_, _map2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_Map_['handles'] = function (type) {
  return _has2.default.WEBGL && type === _type2.default.WEBGL;
};
/**
 * Create the map renderer.
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @return {ol.renderer.webgl.Map} The map renderer.
 */


_ol_renderer_webgl_Map_['create'] = function (container, map) {
  return new _ol_renderer_webgl_Map_(container, map);
};
/**
 * @param {ol.Tile} tile Tile.
 * @param {ol.Size} tileSize Tile size.
 * @param {number} tileGutter Tile gutter.
 * @param {number} magFilter Mag filter.
 * @param {number} minFilter Min filter.
 */


_ol_renderer_webgl_Map_.prototype.bindTileTexture = function (tile, tileSize, tileGutter, magFilter, minFilter) {
  var gl = this.getGL();
  var tileKey = tile.getKey();

  if (this.textureCache_.containsKey(tileKey)) {
    var textureCacheEntry = this.textureCache_.get(tileKey);
    gl.bindTexture(_webgl2.default.TEXTURE_2D, textureCacheEntry.texture);

    if (textureCacheEntry.magFilter != magFilter) {
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MAG_FILTER, magFilter);
      textureCacheEntry.magFilter = magFilter;
    }

    if (textureCacheEntry.minFilter != minFilter) {
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MIN_FILTER, minFilter);
      textureCacheEntry.minFilter = minFilter;
    }
  } else {
    var texture = gl.createTexture();
    gl.bindTexture(_webgl2.default.TEXTURE_2D, texture);

    if (tileGutter > 0) {
      var clipTileCanvas = this.clipTileContext_.canvas;
      var clipTileContext = this.clipTileContext_;

      if (this.clipTileCanvasWidth_ !== tileSize[0] || this.clipTileCanvasHeight_ !== tileSize[1]) {
        clipTileCanvas.width = tileSize[0];
        clipTileCanvas.height = tileSize[1];
        this.clipTileCanvasWidth_ = tileSize[0];
        this.clipTileCanvasHeight_ = tileSize[1];
      } else {
        clipTileContext.clearRect(0, 0, tileSize[0], tileSize[1]);
      }

      clipTileContext.drawImage(tile.getImage(), tileGutter, tileGutter, tileSize[0], tileSize[1], 0, 0, tileSize[0], tileSize[1]);
      gl.texImage2D(_webgl2.default.TEXTURE_2D, 0, _webgl2.default.RGBA, _webgl2.default.RGBA, _webgl2.default.UNSIGNED_BYTE, clipTileCanvas);
    } else {
      gl.texImage2D(_webgl2.default.TEXTURE_2D, 0, _webgl2.default.RGBA, _webgl2.default.RGBA, _webgl2.default.UNSIGNED_BYTE, tile.getImage());
    }

    gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MAG_FILTER, magFilter);
    gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MIN_FILTER, minFilter);
    gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_S, _webgl2.default.CLAMP_TO_EDGE);
    gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_T, _webgl2.default.CLAMP_TO_EDGE);
    this.textureCache_.set(tileKey, {
      texture: texture,
      magFilter: magFilter,
      minFilter: minFilter
    });
  }
};
/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_webgl_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
  var map = this.getMap();

  if (map.hasListener(type)) {
    var context = this.context_;
    var extent = frameState.extent;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var resolution = viewState.resolution;
    var center = viewState.center;
    var rotation = viewState.rotation;
    var vectorContext = new _immediate2.default(context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new _event2.default(type, vectorContext, frameState, null, context);
    map.dispatchEvent(composeEvent);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.disposeInternal = function () {
  var gl = this.getGL();

  if (!gl.isContextLost()) {
    this.textureCache_.forEach(
    /**
     * @param {?ol.WebglTextureCacheEntry} textureCacheEntry
     *     Texture cache entry.
     */
    function (textureCacheEntry) {
      if (textureCacheEntry) {
        gl.deleteTexture(textureCacheEntry.texture);
      }
    });
  }

  this.context_.dispose();

  _map2.default.prototype.disposeInternal.call(this);
};
/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */


_ol_renderer_webgl_Map_.prototype.expireCache_ = function (map, frameState) {
  var gl = this.getGL();
  var textureCacheEntry;

  while (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > _index2.default.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    textureCacheEntry = this.textureCache_.peekLast();

    if (!textureCacheEntry) {
      if (+this.textureCache_.peekLastKey() == frameState.index) {
        break;
      } else {
        --this.textureCacheFrameMarkerCount_;
      }
    } else {
      gl.deleteTexture(textureCacheEntry.texture);
    }

    this.textureCache_.pop();
  }
};
/**
 * @return {ol.webgl.Context} The context.
 */


_ol_renderer_webgl_Map_.prototype.getContext = function () {
  return this.context_;
};
/**
 * @return {WebGLRenderingContext} GL.
 */


_ol_renderer_webgl_Map_.prototype.getGL = function () {
  return this.gl_;
};
/**
 * @return {ol.structs.PriorityQueue.<Array>} Tile texture queue.
 */


_ol_renderer_webgl_Map_.prototype.getTileTextureQueue = function () {
  return this.tileTextureQueue_;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.getType = function () {
  return _type2.default.WEBGL;
};
/**
 * @param {ol.events.Event} event Event.
 * @protected
 */


_ol_renderer_webgl_Map_.prototype.handleWebGLContextLost = function (event) {
  event.preventDefault();
  this.textureCache_.clear();
  this.textureCacheFrameMarkerCount_ = 0;
  var renderers = this.getLayerRenderers();

  for (var id in renderers) {
    var renderer =
    /** @type {ol.renderer.webgl.Layer} */
    renderers[id];
    renderer.handleWebGLContextLost();
  }
};
/**
 * @protected
 */


_ol_renderer_webgl_Map_.prototype.handleWebGLContextRestored = function () {
  this.initializeGL_();
  this.getMap().render();
};
/**
 * @private
 */


_ol_renderer_webgl_Map_.prototype.initializeGL_ = function () {
  var gl = this.gl_;
  gl.activeTexture(_webgl2.default.TEXTURE0);
  gl.blendFuncSeparate(_webgl2.default.SRC_ALPHA, _webgl2.default.ONE_MINUS_SRC_ALPHA, _webgl2.default.ONE, _webgl2.default.ONE_MINUS_SRC_ALPHA);
  gl.disable(_webgl2.default.CULL_FACE);
  gl.disable(_webgl2.default.DEPTH_TEST);
  gl.disable(_webgl2.default.SCISSOR_TEST);
  gl.disable(_webgl2.default.STENCIL_TEST);
};
/**
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Is tile texture loaded.
 */


_ol_renderer_webgl_Map_.prototype.isTileTextureLoaded = function (tile) {
  return this.textureCache_.containsKey(tile.getKey());
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.renderFrame = function (frameState) {
  var context = this.getContext();
  var gl = this.getGL();

  if (gl.isContextLost()) {
    return false;
  }

  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = 'none';
      this.renderedVisible_ = false;
    }

    return false;
  }

  this.focus_ = frameState.focus;
  this.textureCache_.set((-frameState.index).toString(), null);
  ++this.textureCacheFrameMarkerCount_;
  this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, frameState);
  /** @type {Array.<ol.LayerState>} */

  var layerStatesToDraw = [];
  var layerStatesArray = frameState.layerStatesArray;

  _array2.default.stableSort(layerStatesArray, _map2.default.sortByZIndex);

  var viewResolution = frameState.viewState.resolution;
  var i, ii, layerRenderer, layerState;

  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];

    if (_layer2.default.visibleAtResolution(layerState, viewResolution) && layerState.sourceState == _state2.default.READY) {
      layerRenderer =
      /** @type {ol.renderer.webgl.Layer} */
      this.getLayerRenderer(layerState.layer);

      if (layerRenderer.prepareFrame(frameState, layerState, context)) {
        layerStatesToDraw.push(layerState);
      }
    }
  }

  var width = frameState.size[0] * frameState.pixelRatio;
  var height = frameState.size[1] * frameState.pixelRatio;

  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  }

  gl.bindFramebuffer(_webgl2.default.FRAMEBUFFER, null);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(_webgl2.default.COLOR_BUFFER_BIT);
  gl.enable(_webgl2.default.BLEND);
  gl.viewport(0, 0, this.canvas_.width, this.canvas_.height);

  for (i = 0, ii = layerStatesToDraw.length; i < ii; ++i) {
    layerState = layerStatesToDraw[i];
    layerRenderer =
    /** @type {ol.renderer.webgl.Layer} */
    this.getLayerRenderer(layerState.layer);
    layerRenderer.composeFrame(frameState, layerState, context);
  }

  if (!this.renderedVisible_) {
    this.canvas_.style.display = '';
    this.renderedVisible_ = true;
  }

  this.calculateMatrices2D(frameState);

  if (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > _index2.default.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */
    this.expireCache_.bind(this));
  }

  if (!this.tileTextureQueue_.isEmpty()) {
    frameState.postRenderFunctions.push(this.loadNextTileTexture_);
    frameState.animate = true;
  }

  this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, frameState);
  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;

  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer2.default.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      result = layerRenderer.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = false;

  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer2.default.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      hasFeature = layerRenderer.hasFeatureAtCoordinate(coordinate, frameState);

      if (hasFeature) {
        return true;
      }
    }
  }

  return hasFeature;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;
  var result;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;

  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;

    if (_layer2.default.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer =
      /** @type {ol.renderer.webgl.Layer} */
      this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtPixel(pixel, frameState, callback, thisArg);

      if (result) {
        return result;
      }
    }
  }

  return undefined;
};

exports.default = _ol_renderer_webgl_Map_;

},{"../../array.js":30,"../../css.js":45,"../../dom.js":47,"../../events.js":49,"../../has.js":85,"../../index.js":90,"../../layer/layer.js":109,"../../render/event.js":160,"../../render/eventtype.js":161,"../../render/webgl/immediate.js":171,"../../source/state.js":213,"../../structs/lrucache.js":219,"../../structs/priorityqueue.js":220,"../../webgl.js":249,"../../webgl/context.js":251,"../../webgl/contexteventtype.js":252,"../map.js":192,"../type.js":193}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _tilerange = require("../../tilerange.js");

var _tilerange2 = _interopRequireDefault(_tilerange);

var _tilestate = require("../../tilestate.js");

var _tilestate2 = _interopRequireDefault(_tilestate);

var _array = require("../../array.js");

var _array2 = _interopRequireDefault(_array);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _math = require("../../math.js");

var _math2 = _interopRequireDefault(_math);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _layer = require("../webgl/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _tilelayershader = require("../webgl/tilelayershader.js");

var _tilelayershader2 = _interopRequireDefault(_tilelayershader);

var _locations = require("../webgl/tilelayershader/locations.js");

var _locations2 = _interopRequireDefault(_locations);

var _size = require("../../size.js");

var _size2 = _interopRequireDefault(_size);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

var _webgl = require("../../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _buffer = require("../../webgl/buffer.js");

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME large resolutions lead to too large framebuffers :-(
// FIXME animated shaders! check in redraw

/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Tile} tileLayer Tile layer.
 * @api
 */
var _ol_renderer_webgl_TileLayer_ = function (mapRenderer, tileLayer) {
  _layer2.default.call(this, mapRenderer, tileLayer);
  /**
   * @private
   * @type {ol.webgl.Fragment}
   */


  this.fragmentShader_ = _tilelayershader2.default.fragment;
  /**
   * @private
   * @type {ol.webgl.Vertex}
   */

  this.vertexShader_ = _tilelayershader2.default.vertex;
  /**
   * @private
   * @type {ol.renderer.webgl.tilelayershader.Locations}
   */

  this.locations_ = null;
  /**
   * @private
   * @type {ol.webgl.Buffer}
   */

  this.renderArrayBuffer_ = new _buffer2.default([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]);
  /**
   * @private
   * @type {ol.TileRange}
   */

  this.renderedTileRange_ = null;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedFramebufferExtent_ = null;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = -1;
  /**
   * @private
   * @type {ol.Size}
   */

  this.tmpSize_ = [0, 0];
};

_index2.default.inherits(_ol_renderer_webgl_TileLayer_, _layer2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_TileLayer_['handles'] = function (type, layer) {
  return type === _type2.default.WEBGL && layer.getType() === _layertype2.default.TILE;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.TileLayer} The layer renderer.
 */


_ol_renderer_webgl_TileLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_webgl_TileLayer_(
  /** @type {ol.renderer.webgl.Map} */
  mapRenderer,
  /** @type {ol.layer.Tile} */
  layer);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.disposeInternal = function () {
  var context = this.mapRenderer.getContext();
  context.deleteBuffer(this.renderArrayBuffer_);

  _layer2.default.prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
  var mapRenderer = this.mapRenderer;
  return (
    /**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */
    function (zoom, tileRange) {
      function callback(tile) {
        var loaded = mapRenderer.isTileTextureLoaded(tile);

        if (loaded) {
          if (!tiles[zoom]) {
            tiles[zoom] = {};
          }

          tiles[zoom][tile.tileCoord.toString()] = tile;
        }

        return loaded;
      }

      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }
  );
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.handleWebGLContextLost = function () {
  _layer2.default.prototype.handleWebGLContextLost.call(this);

  this.locations_ = null;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.prepareFrame = function (frameState, layerState, context) {
  var mapRenderer = this.mapRenderer;
  var gl = context.getGL();
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var tileLayer =
  /** @type {ol.layer.Tile} */
  this.getLayer();
  var tileSource = tileLayer.getSource();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewState.resolution);
  var tileResolution = tileGrid.getResolution(z);
  var tilePixelSize = tileSource.getTilePixelSize(z, frameState.pixelRatio, projection);

  var pixelRatio = tilePixelSize[0] / _size2.default.toSize(tileGrid.getTileSize(z), this.tmpSize_)[0];

  var tilePixelResolution = tileResolution / pixelRatio;
  var tileGutter = tileSource.getTilePixelRatio(pixelRatio) * tileSource.getGutter(projection);
  var center = viewState.center;
  var extent = frameState.extent;
  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  var framebufferExtent;

  if (this.renderedTileRange_ && this.renderedTileRange_.equals(tileRange) && this.renderedRevision_ == tileSource.getRevision()) {
    framebufferExtent = this.renderedFramebufferExtent_;
  } else {
    var tileRangeSize = tileRange.getSize();
    var maxDimension = Math.max(tileRangeSize[0] * tilePixelSize[0], tileRangeSize[1] * tilePixelSize[1]);

    var framebufferDimension = _math2.default.roundUpToPowerOfTwo(maxDimension);

    var framebufferExtentDimension = tilePixelResolution * framebufferDimension;
    var origin = tileGrid.getOrigin(z);
    var minX = origin[0] + tileRange.minX * tilePixelSize[0] * tilePixelResolution;
    var minY = origin[1] + tileRange.minY * tilePixelSize[1] * tilePixelResolution;
    framebufferExtent = [minX, minY, minX + framebufferExtentDimension, minY + framebufferExtentDimension];
    this.bindFramebuffer(frameState, framebufferDimension);
    gl.viewport(0, 0, framebufferDimension, framebufferDimension);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(_webgl2.default.COLOR_BUFFER_BIT);
    gl.disable(_webgl2.default.BLEND);
    var program = context.getProgram(this.fragmentShader_, this.vertexShader_);
    context.useProgram(program);

    if (!this.locations_) {
      this.locations_ = new _locations2.default(gl, program);
    }

    context.bindBuffer(_webgl2.default.ARRAY_BUFFER, this.renderArrayBuffer_);
    gl.enableVertexAttribArray(this.locations_.a_position);
    gl.vertexAttribPointer(this.locations_.a_position, 2, _webgl2.default.FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(this.locations_.a_texCoord);
    gl.vertexAttribPointer(this.locations_.a_texCoord, 2, _webgl2.default.FLOAT, false, 16, 8);
    gl.uniform1i(this.locations_.u_texture, 0);
    /**
     * @type {Object.<number, Object.<string, ol.Tile>>}
     */

    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    var allTilesLoaded = true;

    var tmpExtent = _extent2.default.createEmpty();

    var tmpTileRange = new _tilerange2.default(0, 0, 0, 0);
    var childTileRange, drawable, fullyLoaded, tile, tileState;
    var x, y, tileExtent;

    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tile = tileSource.getTile(z, x, y, pixelRatio, projection);

        if (layerState.extent !== undefined) {
          // ignore tiles outside layer extent
          tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);

          if (!_extent2.default.intersects(tileExtent, layerState.extent)) {
            continue;
          }
        }

        tileState = tile.getState();
        drawable = tileState == _tilestate2.default.LOADED || tileState == _tilestate2.default.EMPTY || tileState == _tilestate2.default.ERROR && !useInterimTilesOnError;

        if (!drawable) {
          tile = tile.getInterimTile();
        }

        tileState = tile.getState();

        if (tileState == _tilestate2.default.LOADED) {
          if (mapRenderer.isTileTextureLoaded(tile)) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            continue;
          }
        } else if (tileState == _tilestate2.default.EMPTY || tileState == _tilestate2.default.ERROR && !useInterimTilesOnError) {
          continue;
        }

        allTilesLoaded = false;
        fullyLoaded = tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);

        if (!fullyLoaded) {
          childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);

          if (childTileRange) {
            findLoadedTiles(z + 1, childTileRange);
          }
        }
      }
    }
    /** @type {Array.<number>} */


    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array2.default.numberSafeCompareFunction);
    var u_tileOffset = new Float32Array(4);
    var i, ii, tileKey, tilesToDraw;

    for (i = 0, ii = zs.length; i < ii; ++i) {
      tilesToDraw = tilesToDrawByZ[zs[i]];

      for (tileKey in tilesToDraw) {
        tile = tilesToDraw[tileKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
        u_tileOffset[0] = 2 * (tileExtent[2] - tileExtent[0]) / framebufferExtentDimension;
        u_tileOffset[1] = 2 * (tileExtent[3] - tileExtent[1]) / framebufferExtentDimension;
        u_tileOffset[2] = 2 * (tileExtent[0] - framebufferExtent[0]) / framebufferExtentDimension - 1;
        u_tileOffset[3] = 2 * (tileExtent[1] - framebufferExtent[1]) / framebufferExtentDimension - 1;
        gl.uniform4fv(this.locations_.u_tileOffset, u_tileOffset);
        mapRenderer.bindTileTexture(tile, tilePixelSize, tileGutter * pixelRatio, _webgl2.default.LINEAR, _webgl2.default.LINEAR);
        gl.drawArrays(_webgl2.default.TRIANGLE_STRIP, 0, 4);
      }
    }

    if (allTilesLoaded) {
      this.renderedTileRange_ = tileRange;
      this.renderedFramebufferExtent_ = framebufferExtent;
      this.renderedRevision_ = tileSource.getRevision();
    } else {
      this.renderedTileRange_ = null;
      this.renderedFramebufferExtent_ = null;
      this.renderedRevision_ = -1;
      frameState.animate = true;
    }
  }

  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  var tileTextureQueue = mapRenderer.getTileTextureQueue();
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload(),
  /**
   * @param {ol.Tile} tile Tile.
   */
  function (tile) {
    if (tile.getState() == _tilestate2.default.LOADED && !mapRenderer.isTileTextureLoaded(tile) && !tileTextureQueue.isKeyQueued(tile.getKey())) {
      tileTextureQueue.enqueue([tile, tileGrid.getTileCoordCenter(tile.tileCoord), tileGrid.getResolution(tile.tileCoord[0]), tilePixelSize, tileGutter * pixelRatio]);
    }
  }, this);
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);
  var texCoordMatrix = this.texCoordMatrix;

  _transform2.default.reset(texCoordMatrix);

  _transform2.default.translate(texCoordMatrix, (Math.round(center[0] / tileResolution) * tileResolution - framebufferExtent[0]) / (framebufferExtent[2] - framebufferExtent[0]), (Math.round(center[1] / tileResolution) * tileResolution - framebufferExtent[1]) / (framebufferExtent[3] - framebufferExtent[1]));

  if (viewState.rotation !== 0) {
    _transform2.default.rotate(texCoordMatrix, viewState.rotation);
  }

  _transform2.default.scale(texCoordMatrix, frameState.size[0] * viewState.resolution / (framebufferExtent[2] - framebufferExtent[0]), frameState.size[1] * viewState.resolution / (framebufferExtent[3] - framebufferExtent[1]));

  _transform2.default.translate(texCoordMatrix, -0.5, -0.5);

  return true;
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_TileLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  if (!this.framebuffer) {
    return undefined;
  }

  var pixelOnMapScaled = [pixel[0] / frameState.size[0], (frameState.size[1] - pixel[1]) / frameState.size[1]];

  var pixelOnFrameBufferScaled = _transform2.default.apply(this.texCoordMatrix, pixelOnMapScaled.slice());

  var pixelOnFrameBuffer = [pixelOnFrameBufferScaled[0] * this.framebufferDimension, pixelOnFrameBufferScaled[1] * this.framebufferDimension];
  var gl = this.mapRenderer.getContext().getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  var imageData = new Uint8Array(4);
  gl.readPixels(pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

  if (imageData[3] > 0) {
    return callback.call(thisArg, this.getLayer(), imageData);
  } else {
    return undefined;
  }
};

exports.default = _ol_renderer_webgl_TileLayer_;

},{"../../array.js":30,"../../extent.js":55,"../../index.js":90,"../../layertype.js":114,"../../math.js":124,"../../size.js":209,"../../tilerange.js":242,"../../tilestate.js":243,"../../transform.js":244,"../../webgl.js":249,"../../webgl/buffer.js":250,"../type.js":193,"../webgl/layer.js":198,"../webgl/tilelayershader.js":201,"../webgl/tilelayershader/locations.js":202}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _fragment = require("../../webgl/fragment.js");

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require("../../webgl/vertex.js");

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit
var _ol_renderer_webgl_tilelayershader_ = {};
_ol_renderer_webgl_tilelayershader_.fragment = new _fragment2.default(_index2.default.DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n' : 'precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}');
_ol_renderer_webgl_tilelayershader_.vertex = new _vertex2.default(_index2.default.DEBUG_WEBGL ? 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 u_tileOffset;\n\nvoid main(void) {\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\n  v_texCoord = a_texCoord;\n}\n\n\n' : 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}');
exports.default = _ol_renderer_webgl_tilelayershader_;

},{"../../index.js":90,"../../webgl/fragment.js":253,"../../webgl/vertex.js":255}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../../index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This file is automatically generated, do not edit

/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var _ol_renderer_webgl_tilelayershader_Locations_ = function (gl, program) {
  /**
   * @type {WebGLUniformLocation}
   */
  this.u_tileOffset = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_tileOffset' : 'd');
  /**
   * @type {WebGLUniformLocation}
   */

  this.u_texture = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_texture' : 'e');
  /**
   * @type {number}
   */

  this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'b');
  /**
   * @type {number}
   */

  this.a_texCoord = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_texCoord' : 'c');
};

exports.default = _ol_renderer_webgl_tilelayershader_Locations_;

},{"../../../index.js":90}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../../index.js");

var _index2 = _interopRequireDefault(_index);

var _layertype = require("../../layertype.js");

var _layertype2 = _interopRequireDefault(_layertype);

var _viewhint = require("../../viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _extent = require("../../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _replaygroup = require("../../render/webgl/replaygroup.js");

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _type = require("../type.js");

var _type2 = _interopRequireDefault(_type);

var _vector = require("../vector.js");

var _vector2 = _interopRequireDefault(_vector);

var _layer = require("../webgl/layer.js");

var _layer2 = _interopRequireDefault(_layer);

var _transform = require("../../transform.js");

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 * @api
 */
var _ol_renderer_webgl_VectorLayer_ = function (mapRenderer, vectorLayer) {
  _layer2.default.call(this, mapRenderer, vectorLayer);
  /**
   * @private
   * @type {boolean}
   */


  this.dirty_ = false;
  /**
   * @private
   * @type {number}
   */

  this.renderedRevision_ = -1;
  /**
   * @private
   * @type {number}
   */

  this.renderedResolution_ = NaN;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.renderedExtent_ = _extent2.default.createEmpty();
  /**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */

  this.renderedRenderOrder_ = null;
  /**
   * @private
   * @type {ol.render.webgl.ReplayGroup}
   */

  this.replayGroup_ = null;
  /**
   * The last layer state.
   * @private
   * @type {?ol.LayerState}
   */

  this.layerState_ = null;
};

_index2.default.inherits(_ol_renderer_webgl_VectorLayer_, _layer2.default);
/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */


_ol_renderer_webgl_VectorLayer_['handles'] = function (type, layer) {
  return type === _type2.default.WEBGL && layer.getType() === _layertype2.default.VECTOR;
};
/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.VectorLayer} The layer renderer.
 */


_ol_renderer_webgl_VectorLayer_['create'] = function (mapRenderer, layer) {
  return new _ol_renderer_webgl_VectorLayer_(
  /** @type {ol.renderer.webgl.Map} */
  mapRenderer,
  /** @type {ol.layer.Vector} */
  layer);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {
  this.layerState_ = layerState;
  var viewState = frameState.viewState;
  var replayGroup = this.replayGroup_;
  var size = frameState.size;
  var pixelRatio = frameState.pixelRatio;
  var gl = this.mapRenderer.getGL();

  if (replayGroup && !replayGroup.isEmpty()) {
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(0, 0, size[0] * pixelRatio, size[1] * pixelRatio);
    replayGroup.replay(context, viewState.center, viewState.resolution, viewState.rotation, size, pixelRatio, layerState.opacity, layerState.managed ? frameState.skippedFeatureUids : {});
    gl.disable(gl.SCISSOR_TEST);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.disposeInternal = function () {
  var replayGroup = this.replayGroup_;

  if (replayGroup) {
    var context = this.mapRenderer.getContext();
    replayGroup.getDeleteResourcesFunction(context)();
    this.replayGroup_ = null;
  }

  _layer2.default.prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_ || !this.layerState_) {
    return undefined;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layer = this.getLayer();
    var layerState = this.layerState_;
    /** @type {Object.<string, boolean>} */

    var features = {};
    return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = _index2.default.getUid(feature).toString();

      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    });
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {
  if (!this.replayGroup_ || !this.layerState_) {
    return false;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layerState = this.layerState_;
    return this.replayGroup_.hasFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, frameState.skippedFeatureUids);
  }
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  var coordinate = _transform2.default.apply(frameState.pixelToCoordinateTransform, pixel.slice());

  var hasFeature = this.hasFeatureAtCoordinate(coordinate, frameState);

  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};
/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */


_ol_renderer_webgl_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};
/**
 * @inheritDoc
 */


_ol_renderer_webgl_VectorLayer_.prototype.prepareFrame = function (frameState, layerState, context) {
  var vectorLayer =
  /** @type {ol.layer.Vector} */
  this.getLayer();
  var vectorSource = vectorLayer.getSource();
  this.updateLogos(frameState, vectorSource);
  var animating = frameState.viewHints[_viewhint2.default.ANIMATING];
  var interacting = frameState.viewHints[_viewhint2.default.INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

  if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
    return true;
  }

  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = _vector2.default.defaultOrder;
  }

  var extent = _extent2.default.buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);

  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && _extent2.default.containsExtent(this.renderedExtent_, extent)) {
    return true;
  }

  if (this.replayGroup_) {
    frameState.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(context));
  }

  this.dirty_ = false;
  var replayGroup = new _replaygroup2.default(_vector2.default.getTolerance(resolution, pixelRatio), extent, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  /**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.webgl.VectorLayer}
   */

  var renderFeature = function (feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();

    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }

    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  };

  if (vectorLayerRenderOrder) {
    /** @type {Array.<ol.Feature>} */
    var features = [];
    vectorSource.forEachFeatureInExtent(extent,
    /**
     * @param {ol.Feature} feature Feature.
     */
    function (feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);
    features.forEach(renderFeature, this);
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }

  replayGroup.finish(context);
  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;
  return true;
};
/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */


_ol_renderer_webgl_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }

  var loading = false;

  if (Array.isArray(styles)) {
    for (var i = styles.length - 1, ii = 0; i >= ii; --i) {
      loading = _vector2.default.renderFeature(replayGroup, feature, styles[i], _vector2.default.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = _vector2.default.renderFeature(replayGroup, feature, styles, _vector2.default.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
  }

  return loading;
};

exports.default = _ol_renderer_webgl_VectorLayer_;

},{"../../extent.js":55,"../../index.js":90,"../../layertype.js":114,"../../render/webgl/replaygroup.js":179,"../../transform.js":244,"../../viewhint.js":247,"../type.js":193,"../vector.js":194,"../webgl/layer.js":198}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require("./dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

var _proj = require("./proj.js");

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_reproj_ = {};
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */

_ol_reproj_.calculateSourceResolution = function (sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = _proj2.default.transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data


  var sourceResolution = _proj2.default.getPointResolution(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();

  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }

  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();

  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  } // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.


  var sourceExtent = sourceProj.getExtent();

  if (!sourceExtent || _extent2.default.containsCoordinate(sourceExtent, sourceCenter)) {
    var compensationFactor = _proj2.default.getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
};
/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {ol.Coordinate} New point 1 px farther from the centroid.
 * @private
 */


_ol_reproj_.enlargeClipPoint_ = function (centroidX, centroidY, x, y) {
  var dX = x - centroidX,
      dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
};
/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {ol.Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {ol.Extent} targetExtent Target extent.
 * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.
 * @param {Array.<{extent: ol.Extent,
 *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources
 *             Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */


_ol_reproj_.render = function (width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {
  var context = _dom2.default.createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = _extent2.default.createEmpty();

  sources.forEach(function (src, i, arr) {
    _extent2.default.extend(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = _extent2.default.getWidth(sourceDataExtent);

  var canvasHeightInUnits = _extent2.default.getHeight(sourceDataExtent);

  var stitchContext = _dom2.default.createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);

    var srcWidth = _extent2.default.getWidth(src.extent);

    var srcHeight = _extent2.default.getHeight(src.extent);

    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = _extent2.default.getTopLeft(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source,
        target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1],
        x1 = source[1][0],
        y1 = source[1][1],
        x2 = source[2][0],
        y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
        v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
        v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
        v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.

    var sourceNumericalShiftX = x0,
        sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];

    var affineCoefs = _math2.default.solveLinearSystem(augmentedMatrix);

    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3,
        centroidY = (v0 + v1 + v2) / 3;

    var p0 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u0, v0);

    var p1 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u1, v1);

    var p2 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();
    context.strokeStyle = 'black';
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
          v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
          v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
          v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }

  return context.canvas;
};

exports.default = _ol_reproj_;

},{"./dom.js":47,"./extent.js":55,"./math.js":124,"./proj.js":142}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _imagebase = require("../imagebase.js");

var _imagebase2 = _interopRequireDefault(_imagebase);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _reproj = require("../reproj.js");

var _reproj2 = _interopRequireDefault(_reproj);

var _triangulation = require("../reproj/triangulation.js");

var _triangulation2 = _interopRequireDefault(_triangulation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link ol.source.Image}.
 *
 * @constructor
 * @extends {ol.ImageBase}
 * @param {ol.proj.Projection} sourceProj Source projection (of the data).
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Extent} targetExtent Target extent.
 * @param {number} targetResolution Target resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.ReprojImageFunctionType} getImageFunction
 *     Function returning source images (extent, resolution, pixelRatio).
 */
var _ol_reproj_Image_ = function (sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {
  /**
   * @private
   * @type {ol.proj.Projection}
   */
  this.targetProj_ = targetProj;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.maxSourceExtent_ = sourceProj.getExtent();
  var maxTargetExtent = targetProj.getExtent();
  var limitedTargetExtent = maxTargetExtent ? _extent2.default.getIntersection(targetExtent, maxTargetExtent) : targetExtent;

  var targetCenter = _extent2.default.getCenter(limitedTargetExtent);

  var sourceResolution = _reproj2.default.calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  var errorThresholdInPixels = _index2.default.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;
  /**
   * @private
   * @type {!ol.reproj.Triangulation}
   */

  this.triangulation_ = new _triangulation2.default(sourceProj, targetProj, limitedTargetExtent, this.maxSourceExtent_, sourceResolution * errorThresholdInPixels);
  /**
   * @private
   * @type {number}
   */

  this.targetResolution_ = targetResolution;
  /**
   * @private
   * @type {ol.Extent}
   */

  this.targetExtent_ = targetExtent;
  var sourceExtent = this.triangulation_.calculateSourceExtent();
  /**
   * @private
   * @type {ol.ImageBase}
   */

  this.sourceImage_ = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
  /**
   * @private
   * @type {number}
   */

  this.sourcePixelRatio_ = this.sourceImage_ ? this.sourceImage_.getPixelRatio() : 1;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = null;
  /**
   * @private
   * @type {?ol.EventsKey}
   */

  this.sourceListenerKey_ = null;
  var state = _imagestate2.default.LOADED;

  if (this.sourceImage_) {
    state = _imagestate2.default.IDLE;
  }

  _imagebase2.default.call(this, targetExtent, targetResolution, this.sourcePixelRatio_, state);
};

_index2.default.inherits(_ol_reproj_Image_, _imagebase2.default);
/**
 * @inheritDoc
 */


_ol_reproj_Image_.prototype.disposeInternal = function () {
  if (this.state == _imagestate2.default.LOADING) {
    this.unlistenSource_();
  }

  _imagebase2.default.prototype.disposeInternal.call(this);
};
/**
 * @inheritDoc
 */


_ol_reproj_Image_.prototype.getImage = function () {
  return this.canvas_;
};
/**
 * @return {ol.proj.Projection} Projection.
 */


_ol_reproj_Image_.prototype.getProjection = function () {
  return this.targetProj_;
};
/**
 * @private
 */


_ol_reproj_Image_.prototype.reproject_ = function () {
  var sourceState = this.sourceImage_.getState();

  if (sourceState == _imagestate2.default.LOADED) {
    var width = _extent2.default.getWidth(this.targetExtent_) / this.targetResolution_;
    var height = _extent2.default.getHeight(this.targetExtent_) / this.targetResolution_;
    this.canvas_ = _reproj2.default.render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{
      extent: this.sourceImage_.getExtent(),
      image: this.sourceImage_.getImage()
    }], 0);
  }

  this.state = sourceState;
  this.changed();
};
/**
 * @inheritDoc
 */


_ol_reproj_Image_.prototype.load = function () {
  if (this.state == _imagestate2.default.IDLE) {
    this.state = _imagestate2.default.LOADING;
    this.changed();
    var sourceState = this.sourceImage_.getState();

    if (sourceState == _imagestate2.default.LOADED || sourceState == _imagestate2.default.ERROR) {
      this.reproject_();
    } else {
      this.sourceListenerKey_ = _events2.default.listen(this.sourceImage_, _eventtype2.default.CHANGE, function (e) {
        var sourceState = this.sourceImage_.getState();

        if (sourceState == _imagestate2.default.LOADED || sourceState == _imagestate2.default.ERROR) {
          this.unlistenSource_();
          this.reproject_();
        }
      }, this);
      this.sourceImage_.load();
    }
  }
};
/**
 * @private
 */


_ol_reproj_Image_.prototype.unlistenSource_ = function () {
  _events2.default.unlistenByKey(
  /** @type {!ol.EventsKey} */
  this.sourceListenerKey_);

  this.sourceListenerKey_ = null;
};

exports.default = _ol_reproj_Image_;

},{"../events.js":49,"../events/eventtype.js":53,"../extent.js":55,"../imagebase.js":87,"../imagestate.js":89,"../index.js":90,"../reproj.js":204,"../reproj/triangulation.js":206}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

var _proj = require("../proj.js");

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Extent} targetExtent Target extent to triangulate.
 * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.
 * @param {number} errorThreshold Acceptable error (in source units).
 * @constructor
 */
var _ol_reproj_Triangulation_ = function (sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {
  /**
   * @type {ol.proj.Projection}
   * @private
   */
  this.sourceProj_ = sourceProj;
  /**
   * @type {ol.proj.Projection}
   * @private
   */

  this.targetProj_ = targetProj;
  /** @type {!Object.<string, ol.Coordinate>} */

  var transformInvCache = {};

  var transformInv = _proj2.default.getTransform(this.targetProj_, this.sourceProj_);
  /**
   * @param {ol.Coordinate} c A coordinate.
   * @return {ol.Coordinate} Transformed coordinate.
   * @private
   */


  this.transformInv_ = function (c) {
    var key = c[0] + '/' + c[1];

    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }

    return transformInvCache[key];
  };
  /**
   * @type {ol.Extent}
   * @private
   */


  this.maxSourceExtent_ = maxSourceExtent;
  /**
   * @type {number}
   * @private
   */

  this.errorThresholdSquared_ = errorThreshold * errorThreshold;
  /**
   * @type {Array.<ol.ReprojTriangle>}
   * @private
   */

  this.triangles_ = [];
  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */

  this.wrapsXInSource_ = false;
  /**
   * @type {boolean}
   * @private
   */

  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && _extent2.default.getWidth(maxSourceExtent) == _extent2.default.getWidth(this.sourceProj_.getExtent());
  /**
   * @type {?number}
   * @private
   */

  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? _extent2.default.getWidth(this.sourceProj_.getExtent()) : null;
  /**
   * @type {?number}
   * @private
   */

  this.targetWorldWidth_ = this.targetProj_.getExtent() ? _extent2.default.getWidth(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = _extent2.default.getTopLeft(targetExtent);

  var destinationTopRight = _extent2.default.getTopRight(targetExtent);

  var destinationBottomRight = _extent2.default.getBottomRight(targetExtent);

  var destinationBottomLeft = _extent2.default.getBottomLeft(targetExtent);

  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, _index2.default.RASTER_REPROJECTION_MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function (triangle, i, arr) {
      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    }); // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.

    this.triangles_.forEach(function (triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];

        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }

        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }

        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        } // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.


        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);

        if (maxX - minX < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }, this);
  }

  transformInvCache = {};
};
/**
 * Adds triangle to the triangulation.
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @private
 */


_ol_reproj_Triangulation_.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};
/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} d The target d coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @param {ol.Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */


_ol_reproj_Triangulation_.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
  var sourceQuadExtent = _extent2.default.boundingExtent([aSrc, bSrc, cSrc, dSrc]);

  var sourceCoverageX = this.sourceWorldWidth_ ? _extent2.default.getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth =
  /** @type {number} */
  this.sourceWorldWidth_; // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully

  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = _extent2.default.boundingExtent([a, b, c, d]);

      var targetCoverageX = _extent2.default.getWidth(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |= targetCoverageX > _index2.default.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }

    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |= sourceCoverageX > _index2.default.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!_extent2.default.intersects(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);
      var dx;

      if (wrapsX) {
        var centerSrcEstimX = (_math2.default.modulo(aSrc[0], sourceWorldWidth) + _math2.default.modulo(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX - _math2.default.modulo(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }

      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }

    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);
        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);
        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }

      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }

    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};
/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {ol.Extent} Calculated extent.
 */


_ol_reproj_Triangulation_.prototype.calculateSourceExtent = function () {
  var extent = _extent2.default.createEmpty();

  this.triangles_.forEach(function (triangle, i, arr) {
    var src = triangle.source;

    _extent2.default.extendCoordinate(extent, src[0]);

    _extent2.default.extendCoordinate(extent, src[1]);

    _extent2.default.extendCoordinate(extent, src[2]);
  });
  return extent;
};
/**
 * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.
 */


_ol_reproj_Triangulation_.prototype.getTriangles = function () {
  return this.triangles_;
};

exports.default = _ol_reproj_Triangulation_;

},{"../extent.js":55,"../index.js":90,"../math.js":124,"../proj.js":142}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _array = require("./array.js");

var _array2 = _interopRequireDefault(_array);

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_ResolutionConstraint_ = {};
/**
 * @param {Array.<number>} resolutions Resolutions.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */

_ol_ResolutionConstraint_.createSnapToResolutions = function (resolutions) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var z = _array2.default.linearFindNearest(resolutions, resolution, direction);

        z = _math2.default.clamp(z + delta, 0, resolutions.length - 1);
        var index = Math.floor(z);

        if (z != index && index < resolutions.length - 1) {
          var power = resolutions[index] / resolutions[index + 1];
          return resolutions[index] / Math.pow(power, z - index);
        } else {
          return resolutions[index];
        }
      } else {
        return undefined;
      }
    }
  );
};
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */


_ol_ResolutionConstraint_.createSnapToPower = function (power, maxResolution, opt_maxLevel) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var offset = -direction / 2 + 0.5;
        var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);
        var newLevel = Math.max(oldLevel + delta, 0);

        if (opt_maxLevel !== undefined) {
          newLevel = Math.min(newLevel, opt_maxLevel);
        }

        return maxResolution / Math.pow(power, newLevel);
      } else {
        return undefined;
      }
    }
  );
};

exports.default = _ol_ResolutionConstraint_;

},{"./array.js":30,"./math.js":124}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_RotationConstraint_ = {};
/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */

_ol_RotationConstraint_.disable = function (rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
};
/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */


_ol_RotationConstraint_.none = function (rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
};
/**
 * @param {number} n N.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */


_ol_RotationConstraint_.createSnapToN = function (n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
};
/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */


_ol_RotationConstraint_.createSnapToZero = function (opt_tolerance) {
  var tolerance = opt_tolerance || _math2.default.toRadians(5);

  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        if (Math.abs(rotation + delta) <= tolerance) {
          return 0;
        } else {
          return rotation + delta;
        }
      } else {
        return undefined;
      }
    }
  );
};

exports.default = _ol_RotationConstraint_;

},{"./math.js":124}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_size_ = {};
/**
 * Returns a buffered size.
 * @param {ol.Size} size Size.
 * @param {number} buffer Buffer.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The buffered size.
 */

_ol_size_.buffer = function (size, buffer, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] + 2 * buffer;
  opt_size[1] = size[1] + 2 * buffer;
  return opt_size;
};
/**
 * Determines if a size has a positive area.
 * @param {ol.Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */


_ol_size_.hasArea = function (size) {
  return size[0] > 0 && size[1] > 0;
};
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {ol.Size} size Size.
 * @param {number} ratio Ratio.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The scaled size.
 */


_ol_size_.scale = function (size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
};
/**
 * Returns an `ol.Size` array for the passed in number (meaning: square) or
 * `ol.Size` array.
 * (meaning: non-square),
 * @param {number|ol.Size} size Width and height.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} Size.
 * @api
 */


_ol_size_.toSize = function (size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] =
      /** @type {number} */
      size;
    }

    return opt_size;
  }
};

exports.default = _ol_size_;

},{}],210:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _array = require("../array.js");

var _array2 = _interopRequireDefault(_array);

var _event = require("../events/event.js");

var _event2 = _interopRequireDefault(_event);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _proj = require("../proj.js");

var _proj2 = _interopRequireDefault(_proj);

var _image = require("../reproj/image.js");

var _image2 = _interopRequireDefault(_image);

var _source = require("../source/source.js");

var _source2 = _interopRequireDefault(_source);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 *
 * @constructor
 * @abstract
 * @extends {ol.source.Source}
 * @param {ol.SourceImageOptions} options Single image source options.
 * @api
 */
var _ol_source_Image_ = function (options) {
  _source2.default.call(this, {
    attributions: options.attributions,
    extent: options.extent,
    logo: options.logo,
    projection: options.projection,
    state: options.state
  });
  /**
   * @private
   * @type {Array.<number>}
   */


  this.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;
  /**
   * @private
   * @type {ol.reproj.Image}
   */

  this.reprojectedImage_ = null;
  /**
   * @private
   * @type {number}
   */

  this.reprojectedRevision_ = 0;
};

_index2.default.inherits(_ol_source_Image_, _source2.default);
/**
 * @return {Array.<number>} Resolutions.
 * @override
 */


_ol_source_Image_.prototype.getResolutions = function () {
  return this.resolutions_;
};
/**
 * @protected
 * @param {number} resolution Resolution.
 * @return {number} Resolution.
 */


_ol_source_Image_.prototype.findNearestResolution = function (resolution) {
  if (this.resolutions_) {
    var idx = _array2.default.linearFindNearest(this.resolutions_, resolution, 0);

    resolution = this.resolutions_[idx];
  }

  return resolution;
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.ImageBase} Single image.
 */


_ol_source_Image_.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
  var sourceProjection = this.getProjection();

  if (!_index2.default.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || _proj2.default.equivalent(sourceProjection, projection)) {
    if (sourceProjection) {
      projection = sourceProjection;
    }

    return this.getImageInternal(extent, resolution, pixelRatio, projection);
  } else {
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && _proj2.default.equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && _extent2.default.equals(this.reprojectedImage_.getExtent(), extent)) {
        return this.reprojectedImage_;
      }

      this.reprojectedImage_.dispose();
      this.reprojectedImage_ = null;
    }

    this.reprojectedImage_ = new _image2.default(sourceProjection, projection, extent, resolution, pixelRatio, function (extent, resolution, pixelRatio) {
      return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
    }.bind(this));
    this.reprojectedRevision_ = this.getRevision();
    return this.reprojectedImage_;
  }
};
/**
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.ImageBase} Single image.
 * @protected
 */


_ol_source_Image_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {};
/**
 * Handle image change events.
 * @param {ol.events.Event} event Event.
 * @protected
 */


_ol_source_Image_.prototype.handleImageChange = function (event) {
  var image =
  /** @type {ol.Image} */
  event.target;

  switch (image.getState()) {
    case _imagestate2.default.LOADING:
      this.dispatchEvent(new _ol_source_Image_.Event(_ol_source_Image_.EventType_.IMAGELOADSTART, image));
      break;

    case _imagestate2.default.LOADED:
      this.dispatchEvent(new _ol_source_Image_.Event(_ol_source_Image_.EventType_.IMAGELOADEND, image));
      break;

    case _imagestate2.default.ERROR:
      this.dispatchEvent(new _ol_source_Image_.Event(_ol_source_Image_.EventType_.IMAGELOADERROR, image));
      break;

    default: // pass

  }
};
/**
 * Default image load function for image sources that use ol.Image image
 * instances.
 * @param {ol.Image} image Image.
 * @param {string} src Source.
 */


_ol_source_Image_.defaultImageLoadFunction = function (image, src) {
  image.getImage().src = src;
};
/**
 * @classdesc
 * Events emitted by {@link ol.source.Image} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.ImageEvent}
 * @param {string} type Type.
 * @param {ol.Image} image The image.
 */


_ol_source_Image_.Event = function (type, image) {
  _event2.default.call(this, type);
  /**
   * The image related to the event.
   * @type {ol.Image}
   * @api
   */


  this.image = image;
};

_index2.default.inherits(_ol_source_Image_.Event, _event2.default);
/**
 * @enum {string}
 * @private
 */


_ol_source_Image_.EventType_ = {
  /**
   * Triggered when an image starts loading.
   * @event ol.source.Image.Event#imageloadstart
   * @api
   */
  IMAGELOADSTART: 'imageloadstart',

  /**
   * Triggered when an image finishes loading.
   * @event ol.source.Image.Event#imageloadend
   * @api
   */
  IMAGELOADEND: 'imageloadend',

  /**
   * Triggered if image loading results in an error.
   * @event ol.source.Image.Event#imageloaderror
   * @api
   */
  IMAGELOADERROR: 'imageloaderror'
};
exports.default = _ol_source_Image_;

},{"../array.js":30,"../events/event.js":51,"../extent.js":55,"../imagestate.js":89,"../index.js":90,"../proj.js":142,"../reproj/image.js":205,"../source/source.js":212}],211:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _image = require("../image.js");

var _image2 = _interopRequireDefault(_image);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _dom = require("../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _proj = require("../proj.js");

var _proj2 = _interopRequireDefault(_proj);

var _image3 = require("../source/image.js");

var _image4 = _interopRequireDefault(_image3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A layer source for displaying a single, static image.
 *
 * @constructor
 * @extends {ol.source.Image}
 * @param {olx.source.ImageStaticOptions} options Options.
 * @api
 */
var _ol_source_ImageStatic_ = function (options) {
  var imageExtent = options.imageExtent;
  var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
  var
  /** @type {ol.ImageLoadFunctionType} */
  imageLoadFunction = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _image4.default.defaultImageLoadFunction;

  _image4.default.call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: _proj2.default.get(options.projection)
  });
  /**
   * @private
   * @type {ol.Image}
   */


  this.image_ = new _image2.default(imageExtent, undefined, 1, options.url, crossOrigin, imageLoadFunction);
  /**
   * @private
   * @type {ol.Size}
   */

  this.imageSize_ = options.imageSize ? options.imageSize : null;

  _events2.default.listen(this.image_, _eventtype2.default.CHANGE, this.handleImageChange, this);
};

_index2.default.inherits(_ol_source_ImageStatic_, _image4.default);
/**
 * @inheritDoc
 */


_ol_source_ImageStatic_.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
  if (_extent2.default.intersects(extent, this.image_.getExtent())) {
    return this.image_;
  }

  return null;
};
/**
 * @inheritDoc
 */


_ol_source_ImageStatic_.prototype.handleImageChange = function (evt) {
  if (this.image_.getState() == _imagestate2.default.LOADED) {
    var imageExtent = this.image_.getExtent();
    var image = this.image_.getImage();
    var imageWidth, imageHeight;

    if (this.imageSize_) {
      imageWidth = this.imageSize_[0];
      imageHeight = this.imageSize_[1];
    } else {
      imageWidth = image.width;
      imageHeight = image.height;
    }

    var resolution = _extent2.default.getHeight(imageExtent) / imageHeight;
    var targetWidth = Math.ceil(_extent2.default.getWidth(imageExtent) / resolution);

    if (targetWidth != imageWidth) {
      var context = _dom2.default.createCanvasContext2D(targetWidth, imageHeight);

      var canvas = context.canvas;
      context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
      this.image_.setImage(canvas);
    }
  }

  _image4.default.prototype.handleImageChange.call(this, evt);
};

exports.default = _ol_source_ImageStatic_;

},{"../dom.js":47,"../events.js":49,"../events/eventtype.js":53,"../extent.js":55,"../image.js":86,"../imagestate.js":89,"../index.js":90,"../proj.js":142,"../source/image.js":210}],212:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _attribution = require("../attribution.js");

var _attribution2 = _interopRequireDefault(_attribution);

var _object = require("../object.js");

var _object2 = _interopRequireDefault(_object);

var _proj = require("../proj.js");

var _proj2 = _interopRequireDefault(_proj);

var _state = require("../source/state.js");

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link ol.layer.Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {ol.SourceSourceOptions} options Source options.
 * @api
 */
var _ol_source_Source_ = function (options) {
  _object2.default.call(this);
  /**
   * @private
   * @type {ol.proj.Projection}
   */


  this.projection_ = _proj2.default.get(options.projection);
  /**
   * @private
   * @type {Array.<ol.Attribution>}
   */

  this.attributions_ = null;
  /**
   * @private
   * @type {?ol.Attribution2}
   */

  this.attributions2_ = this.adaptAttributions_(options.attributions);
  /**
   * @private
   * @type {string|olx.LogoOptions|undefined}
   */

  this.logo_ = options.logo;
  /**
   * @private
   * @type {ol.source.State}
   */

  this.state_ = options.state !== undefined ? options.state : _state2.default.READY;
  /**
   * @private
   * @type {boolean}
   */

  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
};

_index2.default.inherits(_ol_source_Source_, _object2.default);
/**
 * Turns the attributions option into an attributions function.
 * @suppress {deprecated}
 * @param {ol.AttributionLike|undefined} attributionLike The attribution option.
 * @return {?ol.Attribution2} An attribution function (or null).
 */


_ol_source_Source_.prototype.adaptAttributions_ = function (attributionLike) {
  if (!attributionLike) {
    return null;
  }

  if (attributionLike instanceof _attribution2.default) {
    // TODO: remove attributions_ in next major release
    this.attributions_ = [attributionLike];
    return function (frameState) {
      return [attributionLike.getHTML()];
    };
  }

  if (Array.isArray(attributionLike)) {
    if (attributionLike[0] instanceof _attribution2.default) {
      // TODO: remove attributions_ in next major release
      this.attributions_ = attributionLike;
      var attributions = attributionLike.map(function (attribution) {
        return attribution.getHTML();
      });
      return function (frameState) {
        return attributions;
      };
    } // TODO: remove attributions_ in next major release


    this.attributions_ = attributionLike.map(function (attribution) {
      return new _attribution2.default({
        html: attribution
      });
    });
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  } // TODO: remove attributions_ in next major release


  this.attributions_ = [new _attribution2.default({
    html: attributionLike
  })];
  return function (frameState) {
    return [attributionLike];
  };
};
/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @return {T|undefined} Callback result.
 * @template T
 */


_ol_source_Source_.prototype.forEachFeatureAtCoordinate = _index2.default.nullFunction;
/**
 * Get the attributions of the source.
 * @return {Array.<ol.Attribution>} Attributions.
 * @api
 */

_ol_source_Source_.prototype.getAttributions = function () {
  return this.attributions_;
};
/**
 * Get the attribution function for the source.
 * @return {?ol.Attribution2} Attribution function.
 */


_ol_source_Source_.prototype.getAttributions2 = function () {
  return this.attributions2_;
};
/**
 * Get the logo of the source.
 * @return {string|olx.LogoOptions|undefined} Logo.
 * @api
 */


_ol_source_Source_.prototype.getLogo = function () {
  return this.logo_;
};
/**
 * Get the projection of the source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */


_ol_source_Source_.prototype.getProjection = function () {
  return this.projection_;
};
/**
 * @abstract
 * @return {Array.<number>|undefined} Resolutions.
 */


_ol_source_Source_.prototype.getResolutions = function () {};
/**
 * Get the state of the source, see {@link ol.source.State} for possible states.
 * @return {ol.source.State} State.
 * @api
 */


_ol_source_Source_.prototype.getState = function () {
  return this.state_;
};
/**
 * @return {boolean|undefined} Wrap X.
 */


_ol_source_Source_.prototype.getWrapX = function () {
  return this.wrapX_;
};
/**
 * Refreshes the source and finally dispatches a 'change' event.
 * @api
 */


_ol_source_Source_.prototype.refresh = function () {
  this.changed();
};
/**
 * Set the attributions of the source.
 * @param {ol.AttributionLike|undefined} attributions Attributions.
 *     Can be passed as `string`, `Array<string>`, `{@link ol.Attribution2}`,
 *     or `undefined`.
 * @api
 */


_ol_source_Source_.prototype.setAttributions = function (attributions) {
  this.attributions2_ = this.adaptAttributions_(attributions);
  this.changed();
};
/**
 * Set the logo of the source.
 * @param {string|olx.LogoOptions|undefined} logo Logo.
 */


_ol_source_Source_.prototype.setLogo = function (logo) {
  this.logo_ = logo;
};
/**
 * Set the state of the source.
 * @param {ol.source.State} state State.
 * @protected
 */


_ol_source_Source_.prototype.setState = function (state) {
  this.state_ = state;
  this.changed();
};

exports.default = _ol_source_Source_;

},{"../attribution.js":33,"../index.js":90,"../object.js":126,"../proj.js":142,"../source/state.js":213}],213:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */
var _ol_source_State_ = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};
exports.default = _ol_source_State_;

},{}],214:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _collection = require("../collection.js");

var _collection2 = _interopRequireDefault(_collection);

var _collectioneventtype = require("../collectioneventtype.js");

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _objecteventtype = require("../objecteventtype.js");

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _array = require("../array.js");

var _array2 = _interopRequireDefault(_array);

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _event = require("../events/event.js");

var _event2 = _interopRequireDefault(_event);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _featureloader = require("../featureloader.js");

var _featureloader2 = _interopRequireDefault(_featureloader);

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

var _loadingstrategy = require("../loadingstrategy.js");

var _loadingstrategy2 = _interopRequireDefault(_loadingstrategy);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _source = require("../source/source.js");

var _source2 = _interopRequireDefault(_source);

var _state = require("../source/state.js");

var _state2 = _interopRequireDefault(_state);

var _vectoreventtype = require("../source/vectoreventtype.js");

var _vectoreventtype2 = _interopRequireDefault(_vectoreventtype);

var _rbush = require("../structs/rbush.js");

var _rbush2 = _interopRequireDefault(_rbush);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// FIXME bulk feature upload - suppress events
// FIXME make change-detection more refined (notably, geometry hint)

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link ol.source.VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @constructor
 * @extends {ol.source.Source}
 * @fires ol.source.Vector.Event
 * @param {olx.source.VectorOptions=} opt_options Vector source options.
 * @api
 */
var _ol_source_Vector_ = function (opt_options) {
  var options = opt_options || {};

  _source2.default.call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: undefined,
    state: _state2.default.READY,
    wrapX: options.wrapX !== undefined ? options.wrapX : true
  });
  /**
   * @private
   * @type {ol.FeatureLoader}
   */


  this.loader_ = _index2.default.nullFunction;
  /**
   * @private
   * @type {ol.format.Feature|undefined}
   */

  this.format_ = options.format;
  /**
   * @private
   * @type {boolean}
   */

  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
  /**
   * @private
   * @type {string|ol.FeatureUrlFunction|undefined}
   */

  this.url_ = options.url;

  if (options.loader !== undefined) {
    this.loader_ = options.loader;
  } else if (this.url_ !== undefined) {
    _asserts2.default.assert(this.format_, 7); // `format` must be set when `url` is set
    // create a XHR feature loader for "url" and "format"


    this.loader_ = _featureloader2.default.xhr(this.url_,
    /** @type {ol.format.Feature} */
    this.format_);
  }
  /**
   * @private
   * @type {ol.LoadingStrategy}
   */


  this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy2.default.all;
  var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
  /**
   * @private
   * @type {ol.structs.RBush.<ol.Feature>}
   */

  this.featuresRtree_ = useSpatialIndex ? new _rbush2.default() : null;
  /**
   * @private
   * @type {ol.structs.RBush.<{extent: ol.Extent}>}
   */

  this.loadedExtentsRtree_ = new _rbush2.default();
  /**
   * @private
   * @type {Object.<string, ol.Feature>}
   */

  this.nullGeometryFeatures_ = {};
  /**
   * A lookup of features by id (the return from feature.getId()).
   * @private
   * @type {Object.<string, ol.Feature>}
   */

  this.idIndex_ = {};
  /**
   * A lookup of features without id (keyed by ol.getUid(feature)).
   * @private
   * @type {Object.<string, ol.Feature>}
   */

  this.undefIdIndex_ = {};
  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */

  this.featureChangeKeys_ = {};
  /**
   * @private
   * @type {ol.Collection.<ol.Feature>}
   */

  this.featuresCollection_ = null;
  var collection, features;

  if (options.features instanceof _collection2.default) {
    collection = options.features;
    features = collection.getArray();
  } else if (Array.isArray(options.features)) {
    features = options.features;
  }

  if (!useSpatialIndex && collection === undefined) {
    collection = new _collection2.default(features);
  }

  if (features !== undefined) {
    this.addFeaturesInternal(features);
  }

  if (collection !== undefined) {
    this.bindFeaturesCollection_(collection);
  }
};

_index2.default.inherits(_ol_source_Vector_, _source2.default);
/**
 * Add a single feature to the source.  If you want to add a batch of features
 * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}
 * instead. A feature will not be added to the source if feature with
 * the same id is already there. The reason for this behavior is to avoid
 * feature duplication when using bbox or tile loading strategies.
 * @param {ol.Feature} feature Feature to add.
 * @api
 */


_ol_source_Vector_.prototype.addFeature = function (feature) {
  this.addFeatureInternal(feature);
  this.changed();
};
/**
 * Add a feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */


_ol_source_Vector_.prototype.addFeatureInternal = function (feature) {
  var featureKey = _index2.default.getUid(feature).toString();

  if (!this.addToIndex_(featureKey, feature)) {
    return;
  }

  this.setupChangeEvents_(featureKey, feature);
  var geometry = feature.getGeometry();

  if (geometry) {
    var extent = geometry.getExtent();

    if (this.featuresRtree_) {
      this.featuresRtree_.insert(extent, feature);
    }
  } else {
    this.nullGeometryFeatures_[featureKey] = feature;
  }

  this.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.ADDFEATURE, feature));
};
/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @private
 */


_ol_source_Vector_.prototype.setupChangeEvents_ = function (featureKey, feature) {
  this.featureChangeKeys_[featureKey] = [_events2.default.listen(feature, _eventtype2.default.CHANGE, this.handleFeatureChange_, this), _events2.default.listen(feature, _objecteventtype2.default.PROPERTYCHANGE, this.handleFeatureChange_, this)];
};
/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} The feature is "valid", in the sense that it is also a
 *     candidate for insertion into the Rtree.
 * @private
 */


_ol_source_Vector_.prototype.addToIndex_ = function (featureKey, feature) {
  var valid = true;
  var id = feature.getId();

  if (id !== undefined) {
    if (!(id.toString() in this.idIndex_)) {
      this.idIndex_[id.toString()] = feature;
    } else {
      valid = false;
    }
  } else {
    _asserts2.default.assert(!(featureKey in this.undefIdIndex_), 30); // The passed `feature` was already added to the source


    this.undefIdIndex_[featureKey] = feature;
  }

  return valid;
};
/**
 * Add a batch of features to the source.
 * @param {Array.<ol.Feature>} features Features to add.
 * @api
 */


_ol_source_Vector_.prototype.addFeatures = function (features) {
  this.addFeaturesInternal(features);
  this.changed();
};
/**
 * Add features without firing a `change` event.
 * @param {Array.<ol.Feature>} features Features.
 * @protected
 */


_ol_source_Vector_.prototype.addFeaturesInternal = function (features) {
  var featureKey, i, length, feature;
  var extents = [];
  var newFeatures = [];
  var geometryFeatures = [];

  for (i = 0, length = features.length; i < length; i++) {
    feature = features[i];
    featureKey = _index2.default.getUid(feature).toString();

    if (this.addToIndex_(featureKey, feature)) {
      newFeatures.push(feature);
    }
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    feature = newFeatures[i];
    featureKey = _index2.default.getUid(feature).toString();
    this.setupChangeEvents_(featureKey, feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var extent = geometry.getExtent();
      extents.push(extent);
      geometryFeatures.push(feature);
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  }

  if (this.featuresRtree_) {
    this.featuresRtree_.load(extents, geometryFeatures);
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    this.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.ADDFEATURE, newFeatures[i]));
  }
};
/**
 * @param {!ol.Collection.<ol.Feature>} collection Collection.
 * @private
 */


_ol_source_Vector_.prototype.bindFeaturesCollection_ = function (collection) {
  var modifyingCollection = false;

  _events2.default.listen(this, _vectoreventtype2.default.ADDFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.push(evt.feature);
      modifyingCollection = false;
    }
  });

  _events2.default.listen(this, _vectoreventtype2.default.REMOVEFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.remove(evt.feature);
      modifyingCollection = false;
    }
  });

  _events2.default.listen(collection, _collectioneventtype2.default.ADD, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.addFeature(
      /** @type {ol.Feature} */
      evt.element);
      modifyingCollection = false;
    }
  }, this);

  _events2.default.listen(collection, _collectioneventtype2.default.REMOVE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.removeFeature(
      /** @type {ol.Feature} */
      evt.element);
      modifyingCollection = false;
    }
  }, this);

  this.featuresCollection_ = collection;
};
/**
 * Remove all features from the source.
 * @param {boolean=} opt_fast Skip dispatching of {@link removefeature} events.
 * @api
 */


_ol_source_Vector_.prototype.clear = function (opt_fast) {
  if (opt_fast) {
    for (var featureId in this.featureChangeKeys_) {
      var keys = this.featureChangeKeys_[featureId];
      keys.forEach(_events2.default.unlistenByKey);
    }

    if (!this.featuresCollection_) {
      this.featureChangeKeys_ = {};
      this.idIndex_ = {};
      this.undefIdIndex_ = {};
    }
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.forEach(this.removeFeatureInternal, this);

      for (var id in this.nullGeometryFeatures_) {
        this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
      }
    }
  }

  if (this.featuresCollection_) {
    this.featuresCollection_.clear();
  }

  if (this.featuresRtree_) {
    this.featuresRtree_.clear();
  }

  this.loadedExtentsRtree_.clear();
  this.nullGeometryFeatures_ = {};
  var clearEvent = new _ol_source_Vector_.Event(_vectoreventtype2.default.CLEAR);
  this.dispatchEvent(clearEvent);
  this.changed();
};
/**
 * Iterate through all features on the source, calling the provided callback
 * with each one.  If the callback returns any "truthy" value, iteration will
 * stop and the function will return the same value.
 *
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     on the source.  Return a truthy value to stop iteration.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */


_ol_source_Vector_.prototype.forEachFeature = function (callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEach(callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};
/**
 * Iterate through all features whose geometries contain the provided
 * coordinate, calling the callback with each feature.  If the callback returns
 * a "truthy" value, iteration will stop and the function will return the same
 * value.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose goemetry contains the provided coordinate.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 */


_ol_source_Vector_.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback, opt_this) {
  var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
  return this.forEachFeatureInExtent(extent, function (feature) {
    var geometry = feature.getGeometry();

    if (geometry.intersectsCoordinate(coordinate)) {
      return callback.call(opt_this, feature);
    } else {
      return undefined;
    }
  });
};
/**
 * Iterate through all features whose bounding box intersects the provided
 * extent (note that the feature's geometry may not intersect the extent),
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you are interested in features whose geometry intersects an extent, call
 * the {@link ol.source.Vector#forEachFeatureIntersectingExtent
 * source.forEachFeatureIntersectingExtent()} method instead.
 *
 * When `useSpatialIndex` is set to false, this method will loop through all
 * features, equivalent to {@link ol.source.Vector#forEachFeature}.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose bounding box intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */


_ol_source_Vector_.prototype.forEachFeatureInExtent = function (extent, callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEachInExtent(extent, callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};
/**
 * Iterate through all features whose geometry intersects the provided extent,
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you only want to test for bounding box intersection, call the
 * {@link ol.source.Vector#forEachFeatureInExtent
 * source.forEachFeatureInExtent()} method instead.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose geometry intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */


_ol_source_Vector_.prototype.forEachFeatureIntersectingExtent = function (extent, callback, opt_this) {
  return this.forEachFeatureInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   * @return {S|undefined} The return value from the last call to the callback.
   * @template S
   */
  function (feature) {
    var geometry = feature.getGeometry();

    if (geometry.intersectsExtent(extent)) {
      var result = callback.call(opt_this, feature);

      if (result) {
        return result;
      }
    }
  });
};
/**
 * Get the features collection associated with this source. Will be `null`
 * unless the source was configured with `useSpatialIndex` set to `false`, or
 * with an {@link ol.Collection} as `features`.
 * @return {ol.Collection.<ol.Feature>} The collection of features.
 * @api
 */


_ol_source_Vector_.prototype.getFeaturesCollection = function () {
  return this.featuresCollection_;
};
/**
 * Get all features on the source in random order.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_source_Vector_.prototype.getFeatures = function () {
  var features;

  if (this.featuresCollection_) {
    features = this.featuresCollection_.getArray();
  } else if (this.featuresRtree_) {
    features = this.featuresRtree_.getAll();

    if (!_obj2.default.isEmpty(this.nullGeometryFeatures_)) {
      _array2.default.extend(features, _obj2.default.getValues(this.nullGeometryFeatures_));
    }
  }

  return (
    /** @type {Array.<ol.Feature>} */
    features
  );
};
/**
 * Get all features whose geometry intersects the provided coordinate.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_source_Vector_.prototype.getFeaturesAtCoordinate = function (coordinate) {
  var features = [];
  this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
    features.push(feature);
  });
  return features;
};
/**
 * Get all features in the provided extent.  Note that this returns an array of
 * all features intersecting the given extent in random order (so it may include
 * features whose geometries do not intersect the extent).
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */


_ol_source_Vector_.prototype.getFeaturesInExtent = function (extent) {
  return this.featuresRtree_.getInExtent(extent);
};
/**
 * Get the closest feature to the provided coordinate.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(ol.Feature):boolean=} opt_filter Feature filter function.
 *     The filter function will receive one argument, the {@link ol.Feature feature}
 *     and it should return a boolean value. By default, no filtering is made.
 * @return {ol.Feature} Closest feature.
 * @api
 */


_ol_source_Vector_.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
  // Find the closest feature using branch and bound.  We start searching an
  // infinite extent, and find the distance from the first feature found.  This
  // becomes the closest feature.  We then compute a smaller extent which any
  // closer feature must intersect.  We continue searching with this smaller
  // extent, trying to find a closer feature.  Every time we find a closer
  // feature, we update the extent being searched so that any even closer
  // feature must intersect it.  We continue until we run out of features.
  var x = coordinate[0];
  var y = coordinate[1];
  var closestFeature = null;
  var closestPoint = [NaN, NaN];
  var minSquaredDistance = Infinity;
  var extent = [-Infinity, -Infinity, Infinity, Infinity];
  var filter = opt_filter ? opt_filter : _functions2.default.TRUE;
  this.featuresRtree_.forEachInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   */
  function (feature) {
    if (filter(feature)) {
      var geometry = feature.getGeometry();
      var previousMinSquaredDistance = minSquaredDistance;
      minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);

      if (minSquaredDistance < previousMinSquaredDistance) {
        closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being
        // searched while the R-Tree traversal using this same extent object
        // is still in progress.  This is safe because the new extent is
        // strictly contained by the old extent.

        var minDistance = Math.sqrt(minSquaredDistance);
        extent[0] = x - minDistance;
        extent[1] = y - minDistance;
        extent[2] = x + minDistance;
        extent[3] = y + minDistance;
      }
    }
  });
  return closestFeature;
};
/**
 * Get the extent of the features currently in the source.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent=} opt_extent Destination extent. If provided, no new extent
 *     will be created. Instead, that extent's coordinates will be overwritten.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_source_Vector_.prototype.getExtent = function (opt_extent) {
  return this.featuresRtree_.getExtent(opt_extent);
};
/**
 * Get a feature by its identifier (the value returned by feature.getId()).
 * Note that the index treats string and numeric identifiers as the same.  So
 * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
 *
 * @param {string|number} id Feature identifier.
 * @return {ol.Feature} The feature (or `null` if not found).
 * @api
 */


_ol_source_Vector_.prototype.getFeatureById = function (id) {
  var feature = this.idIndex_[id.toString()];
  return feature !== undefined ? feature : null;
};
/**
 * Get the format associated with this source.
 *
 * @return {ol.format.Feature|undefined} The feature format.
 * @api
 */


_ol_source_Vector_.prototype.getFormat = function () {
  return this.format_;
};
/**
 * @return {boolean} The source can have overlapping geometries.
 */


_ol_source_Vector_.prototype.getOverlaps = function () {
  return this.overlaps_;
};
/**
 * @override
 */


_ol_source_Vector_.prototype.getResolutions = function () {};
/**
 * Get the url associated with this source.
 *
 * @return {string|ol.FeatureUrlFunction|undefined} The url.
 * @api
 */


_ol_source_Vector_.prototype.getUrl = function () {
  return this.url_;
};
/**
 * @param {ol.events.Event} event Event.
 * @private
 */


_ol_source_Vector_.prototype.handleFeatureChange_ = function (event) {
  var feature =
  /** @type {ol.Feature} */
  event.target;

  var featureKey = _index2.default.getUid(feature).toString();

  var geometry = feature.getGeometry();

  if (!geometry) {
    if (!(featureKey in this.nullGeometryFeatures_)) {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }

      this.nullGeometryFeatures_[featureKey] = feature;
    }
  } else {
    var extent = geometry.getExtent();

    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];

      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.update(extent, feature);
      }
    }
  }

  var id = feature.getId();

  if (id !== undefined) {
    var sid = id.toString();

    if (featureKey in this.undefIdIndex_) {
      delete this.undefIdIndex_[featureKey];
      this.idIndex_[sid] = feature;
    } else {
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    }
  } else {
    if (!(featureKey in this.undefIdIndex_)) {
      this.removeFromIdIndex_(feature);
      this.undefIdIndex_[featureKey] = feature;
    }
  }

  this.changed();
  this.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.CHANGEFEATURE, feature));
};
/**
 * @return {boolean} Is empty.
 */


_ol_source_Vector_.prototype.isEmpty = function () {
  return this.featuresRtree_.isEmpty() && _obj2.default.isEmpty(this.nullGeometryFeatures_);
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 */


_ol_source_Vector_.prototype.loadFeatures = function (extent, resolution, projection) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var extentsToLoad = this.strategy_(extent, resolution);
  var i, ii;

  for (i = 0, ii = extentsToLoad.length; i < ii; ++i) {
    var extentToLoad = extentsToLoad[i];
    var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
    /**
     * @param {{extent: ol.Extent}} object Object.
     * @return {boolean} Contains.
     */
    function (object) {
      return _extent2.default.containsExtent(object.extent, extentToLoad);
    });

    if (!alreadyLoaded) {
      this.loader_.call(this, extentToLoad, resolution, projection);
      loadedExtentsRtree.insert(extentToLoad, {
        extent: extentToLoad.slice()
      });
    }
  }
};
/**
 * Remove an extent from the list of loaded extents.
 * @param {ol.Extent} extent Extent.
 * @api
 */


_ol_source_Vector_.prototype.removeLoadedExtent = function (extent) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var obj;
  loadedExtentsRtree.forEachInExtent(extent, function (object) {
    if (_extent2.default.equals(object.extent, extent)) {
      obj = object;
      return true;
    }
  });

  if (obj) {
    loadedExtentsRtree.remove(obj);
  }
};
/**
 * Remove a single feature from the source.  If you want to remove all features
 * at once, use the {@link ol.source.Vector#clear source.clear()} method
 * instead.
 * @param {ol.Feature} feature Feature to remove.
 * @api
 */


_ol_source_Vector_.prototype.removeFeature = function (feature) {
  var featureKey = _index2.default.getUid(feature).toString();

  if (featureKey in this.nullGeometryFeatures_) {
    delete this.nullGeometryFeatures_[featureKey];
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.remove(feature);
    }
  }

  this.removeFeatureInternal(feature);
  this.changed();
};
/**
 * Remove feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */


_ol_source_Vector_.prototype.removeFeatureInternal = function (feature) {
  var featureKey = _index2.default.getUid(feature).toString();

  this.featureChangeKeys_[featureKey].forEach(_events2.default.unlistenByKey);
  delete this.featureChangeKeys_[featureKey];
  var id = feature.getId();

  if (id !== undefined) {
    delete this.idIndex_[id.toString()];
  } else {
    delete this.undefIdIndex_[featureKey];
  }

  this.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.REMOVEFEATURE, feature));
};
/**
 * Remove a feature from the id index.  Called internally when the feature id
 * may have changed.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} Removed the feature from the index.
 * @private
 */


_ol_source_Vector_.prototype.removeFromIdIndex_ = function (feature) {
  var removed = false;

  for (var id in this.idIndex_) {
    if (this.idIndex_[id] === feature) {
      delete this.idIndex_[id];
      removed = true;
      break;
    }
  }

  return removed;
};
/**
 * Set the new loader of the source. The next loadFeatures call will use the
 * new loader.
 * @param {ol.FeatureLoader} loader The loader to set.
 * @api
 */


_ol_source_Vector_.prototype.setLoader = function (loader) {
  this.loader_ = loader;
};
/**
 * @classdesc
 * Events emitted by {@link ol.source.Vector} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Vector.Event}
 * @param {string} type Type.
 * @param {ol.Feature=} opt_feature Feature.
 */


_ol_source_Vector_.Event = function (type, opt_feature) {
  _event2.default.call(this, type);
  /**
   * The feature being added or removed.
   * @type {ol.Feature|undefined}
   * @api
   */


  this.feature = opt_feature;
};

_index2.default.inherits(_ol_source_Vector_.Event, _event2.default);

exports.default = _ol_source_Vector_;

},{"../array.js":30,"../asserts.js":32,"../collection.js":35,"../collectioneventtype.js":36,"../events.js":49,"../events/event.js":51,"../events/eventtype.js":53,"../extent.js":55,"../featureloader.js":59,"../functions.js":61,"../index.js":90,"../loadingstrategy.js":115,"../obj.js":125,"../objecteventtype.js":127,"../source/source.js":212,"../source/state.js":213,"../source/vectoreventtype.js":215,"../structs/rbush.js":221}],215:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_source_VectorEventType_ = {
  /**
   * Triggered when a feature is added to the source.
   * @event ol.source.Vector.Event#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol.source.Vector.Event#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol.source.Vector.Event#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link ol.source.Vector#clear source.clear()} for exceptions.
   * @event ol.source.Vector.Event#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
};
exports.default = _ol_source_VectorEventType_;

},{}],216:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

var _geometrytype = require("./geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

/**
 * @classdesc
 * Class to create objects that can be used with {@link
 * ol.geom.Polygon.circular}.
 *
 * For example to create a sphere whose radius is equal to the semi-major
 * axis of the WGS84 ellipsoid:
 *
 * ```js
 * var wgs84Sphere= new ol.Sphere(6378137);
 * ```
 *
 * @constructor
 * @param {number} radius Radius.
 * @api
 */
var _ol_Sphere_ = function (radius) {
  /**
   * @type {number}
   */
  this.radius = radius;
};
/**
 * Returns the geodesic area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @return {number} Area.
 * @api
 */


_ol_Sphere_.prototype.geodesicArea = function (coordinates) {
  return _ol_Sphere_.getArea_(coordinates, this.radius);
};
/**
 * Returns the distance from c1 to c2 using the haversine formula.
 *
 * @param {ol.Coordinate} c1 Coordinate 1.
 * @param {ol.Coordinate} c2 Coordinate 2.
 * @return {number} Haversine distance.
 * @api
 */


_ol_Sphere_.prototype.haversineDistance = function (c1, c2) {
  return _ol_Sphere_.getDistance_(c1, c2, this.radius);
};
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @return {ol.Coordinate} The target point.
 */


_ol_Sphere_.prototype.offset = function (c1, distance, bearing) {
  var lat1 = _math2.default.toRadians(c1[1]);

  var lon1 = _math2.default.toRadians(c1[0]);

  var dByR = distance / this.radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [_math2.default.toDegrees(lon), _math2.default.toDegrees(lat)];
};
/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */


_ol_Sphere_.DEFAULT_RADIUS = 6371008.8;
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the length
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */

_ol_Sphere_.getLength = function (geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  geometry = geometry.clone().transform(projection, 'EPSG:4326');
  var type = geometry.getType();
  var length = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _geometrytype2.default.POINT:
    case _geometrytype2.default.MULTI_POINT:
      {
        break;
      }

    case _geometrytype2.default.LINE_STRING:
    case _geometrytype2.default.LINEAR_RING:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();
        length = _ol_Sphere_.getLength_(coordinates, radius);
        break;
      }

    case _geometrytype2.default.MULTI_LINE_STRING:
    case _geometrytype2.default.POLYGON:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += _ol_Sphere_.getLength_(coordinates[i], radius);
        }

        break;
      }

    case _geometrytype2.default.MULTI_POLYGON:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];

          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += _ol_Sphere_.getLength_(coords[j], radius);
          }
        }

        break;
      }

    case _geometrytype2.default.GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {ol.geom.GeometryCollection} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += _ol_Sphere_.getLength(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return length;
};
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */


_ol_Sphere_.getLength_ = function (coordinates, radius) {
  var length = 0;

  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += _ol_Sphere_.getDistance_(coordinates[i], coordinates[i + 1], radius);
  }

  return length;
};
/**
 * Get the great circle distance between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} radius The sphere radius to use.
 * @return {number} The great circle distance between the points (in meters).
 */


_ol_Sphere_.getDistance_ = function (c1, c2, radius) {
  var lat1 = _math2.default.toRadians(c1[1]);

  var lat2 = _math2.default.toRadians(c2[1]);

  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = _math2.default.toRadians(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
};
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */


_ol_Sphere_.getArea = function (geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  geometry = geometry.clone().transform(projection, 'EPSG:4326');
  var type = geometry.getType();
  var area = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _geometrytype2.default.POINT:
    case _geometrytype2.default.MULTI_POINT:
    case _geometrytype2.default.LINE_STRING:
    case _geometrytype2.default.MULTI_LINE_STRING:
    case _geometrytype2.default.LINEAR_RING:
      {
        break;
      }

    case _geometrytype2.default.POLYGON:
      {
        coordinates =
        /** @type {ol.geom.Polygon} */
        geometry.getCoordinates();
        area = Math.abs(_ol_Sphere_.getArea_(coordinates[0], radius));

        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(_ol_Sphere_.getArea_(coordinates[i], radius));
        }

        break;
      }

    case _geometrytype2.default.MULTI_POLYGON:
      {
        coordinates =
        /** @type {ol.geom.SimpleGeometry} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(_ol_Sphere_.getArea_(coords[0], radius));

          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(_ol_Sphere_.getArea_(coords[j], radius));
          }
        }

        break;
      }

    case _geometrytype2.default.GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {ol.geom.GeometryCollection} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += _ol_Sphere_.getArea(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return area;
};
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */


_ol_Sphere_.getArea_ = function (coordinates, radius) {
  var area = 0,
      len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];

  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0],
        y2 = coordinates[i][1];
    area += _math2.default.toRadians(x2 - x1) * (2 + Math.sin(_math2.default.toRadians(y1)) + Math.sin(_math2.default.toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }

  return area * radius * radius / 2.0;
};

exports.default = _ol_Sphere_;

},{"./geom/geometrytype.js":80,"./math.js":124}],217:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_string_ = {};
/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
*/

_ol_string_.padNumber = function (number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
};
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */


_ol_string_.compareVersions = function (v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }

    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
};

exports.default = _ol_string_;

},{}],218:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Creates an empty linked list structure.
 *
 * @constructor
 * @struct
 * @param {boolean=} opt_circular The last item is connected to the first one,
 * and the first item to the last one. Default is true.
 */
var _ol_structs_LinkedList_ = function (opt_circular) {
  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.first_ = undefined;
  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */

  this.last_ = undefined;
  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */

  this.head_ = undefined;
  /**
   * @private
   * @type {boolean}
   */

  this.circular_ = opt_circular === undefined ? true : opt_circular;
  /**
   * @private
   * @type {number}
   */

  this.length_ = 0;
};
/**
 * Inserts an item into the linked list right after the current one.
 *
 * @param {?} data Item data.
 */


_ol_structs_LinkedList_.prototype.insertItem = function (data) {
  /** @type {ol.LinkedListItem} */
  var item = {
    prev: undefined,
    next: undefined,
    data: data
  };
  var head = this.head_; //Initialize the list.

  if (!head) {
    this.first_ = item;
    this.last_ = item;

    if (this.circular_) {
      item.next = item;
      item.prev = item;
    }
  } else {
    //Link the new item to the adjacent ones.
    var next = head.next;
    item.prev = head;
    item.next = next;
    head.next = item;

    if (next) {
      next.prev = item;
    }

    if (head === this.last_) {
      this.last_ = item;
    }
  }

  this.head_ = item;
  this.length_++;
};
/**
 * Removes the current item from the list. Sets the cursor to the next item,
 * if possible.
 */


_ol_structs_LinkedList_.prototype.removeItem = function () {
  var head = this.head_;

  if (head) {
    var next = head.next;
    var prev = head.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    this.head_ = next || prev;

    if (this.first_ === this.last_) {
      this.head_ = undefined;
      this.first_ = undefined;
      this.last_ = undefined;
    } else if (this.first_ === head) {
      this.first_ = this.head_;
    } else if (this.last_ === head) {
      this.last_ = prev ? this.head_.prev : this.head_;
    }

    this.length_--;
  }
};
/**
 * Sets the cursor to the first item, and returns the associated data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.firstItem = function () {
  this.head_ = this.first_;

  if (this.head_) {
    return this.head_.data;
  }

  return undefined;
};
/**
* Sets the cursor to the last item, and returns the associated data.
*
* @return {?} Item data.
*/


_ol_structs_LinkedList_.prototype.lastItem = function () {
  this.head_ = this.last_;

  if (this.head_) {
    return this.head_.data;
  }

  return undefined;
};
/**
 * Sets the cursor to the next item, and returns the associated data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.nextItem = function () {
  if (this.head_ && this.head_.next) {
    this.head_ = this.head_.next;
    return this.head_.data;
  }

  return undefined;
};
/**
 * Returns the next item's data without moving the cursor.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.getNextItem = function () {
  if (this.head_ && this.head_.next) {
    return this.head_.next.data;
  }

  return undefined;
};
/**
 * Sets the cursor to the previous item, and returns the associated data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.prevItem = function () {
  if (this.head_ && this.head_.prev) {
    this.head_ = this.head_.prev;
    return this.head_.data;
  }

  return undefined;
};
/**
 * Returns the previous item's data without moving the cursor.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.getPrevItem = function () {
  if (this.head_ && this.head_.prev) {
    return this.head_.prev.data;
  }

  return undefined;
};
/**
 * Returns the current item's data.
 *
 * @return {?} Item data.
 */


_ol_structs_LinkedList_.prototype.getCurrItem = function () {
  if (this.head_) {
    return this.head_.data;
  }

  return undefined;
};
/**
 * Sets the first item of the list. This only works for circular lists, and sets
 * the last item accordingly.
 */


_ol_structs_LinkedList_.prototype.setFirstItem = function () {
  if (this.circular_ && this.head_) {
    this.first_ = this.head_;
    this.last_ = this.head_.prev;
  }
};
/**
 * Concatenates two lists.
 * @param {ol.structs.LinkedList} list List to merge into the current list.
 */


_ol_structs_LinkedList_.prototype.concat = function (list) {
  if (list.head_) {
    if (this.head_) {
      var end = this.head_.next;
      this.head_.next = list.first_;
      list.first_.prev = this.head_;
      end.prev = list.last_;
      list.last_.next = end;
      this.length_ += list.length_;
    } else {
      this.head_ = list.head_;
      this.first_ = list.first_;
      this.last_ = list.last_;
      this.length_ = list.length_;
    }

    list.head_ = undefined;
    list.first_ = undefined;
    list.last_ = undefined;
    list.length_ = 0;
  }
};
/**
 * Returns the current length of the list.
 *
 * @return {number} Length.
 */


_ol_structs_LinkedList_.prototype.getLength = function () {
  return this.length_;
};

exports.default = _ol_structs_LinkedList_;

},{}],219:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _eventtarget = require("../events/eventtarget.js");

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @template T
 * @param {number=} opt_highWaterMark High water mark.
 */
var _ol_structs_LRUCache_ = function (opt_highWaterMark) {
  _eventtarget2.default.call(this);
  /**
   * @type {number}
   */


  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
  /**
   * @private
   * @type {number}
   */

  this.count_ = 0;
  /**
   * @private
   * @type {!Object.<string, ol.LRUCacheEntry>}
   */

  this.entries_ = {};
  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */

  this.oldest_ = null;
  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */

  this.newest_ = null;
};

_index2.default.inherits(_ol_structs_LRUCache_, _eventtarget2.default);
/**
 * @return {boolean} Can expire cache.
 */


_ol_structs_LRUCache_.prototype.canExpireCache = function () {
  return this.getCount() > this.highWaterMark;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_structs_LRUCache_.prototype.clear = function () {
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
  this.dispatchEvent(_eventtype2.default.CLEAR);
};
/**
 * @param {string} key Key.
 * @return {boolean} Contains key.
 */


_ol_structs_LRUCache_.prototype.containsKey = function (key) {
  return this.entries_.hasOwnProperty(key);
};
/**
 * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function
 *     to call for every entry from the oldest to the newer. This function takes
 *     3 arguments (the entry value, the entry key and the LRUCache object).
 *     The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 */


_ol_structs_LRUCache_.prototype.forEach = function (f, opt_this) {
  var entry = this.oldest_;

  while (entry) {
    f.call(opt_this, entry.value_, entry.key_, this);
    entry = entry.newer;
  }
};
/**
 * @param {string} key Key.
 * @return {T} Value.
 */


_ol_structs_LRUCache_.prototype.get = function (key) {
  var entry = this.entries_[key];

  _asserts2.default.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache


  if (entry === this.newest_) {
    return entry.value_;
  } else if (entry === this.oldest_) {
    this.oldest_ =
    /** @type {ol.LRUCacheEntry} */
    this.oldest_.newer;
    this.oldest_.older = null;
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }

  entry.newer = null;
  entry.older = this.newest_;
  this.newest_.newer = entry;
  this.newest_ = entry;
  return entry.value_;
};
/**
 * Remove an entry from the cache.
 * @param {string} key The entry key.
 * @return {T} The removed entry.
 */


_ol_structs_LRUCache_.prototype.remove = function (key) {
  var entry = this.entries_[key];

  _asserts2.default.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache


  if (entry === this.newest_) {
    this.newest_ =
    /** @type {ol.LRUCacheEntry} */
    entry.older;

    if (this.newest_) {
      this.newest_.newer = null;
    }
  } else if (entry === this.oldest_) {
    this.oldest_ =
    /** @type {ol.LRUCacheEntry} */
    entry.newer;

    if (this.oldest_) {
      this.oldest_.older = null;
    }
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }

  delete this.entries_[key];
  --this.count_;
  return entry.value_;
};
/**
 * @return {number} Count.
 */


_ol_structs_LRUCache_.prototype.getCount = function () {
  return this.count_;
};
/**
 * @return {Array.<string>} Keys.
 */


_ol_structs_LRUCache_.prototype.getKeys = function () {
  var keys = new Array(this.count_);
  var i = 0;
  var entry;

  for (entry = this.newest_; entry; entry = entry.older) {
    keys[i++] = entry.key_;
  }

  return keys;
};
/**
 * @return {Array.<T>} Values.
 */


_ol_structs_LRUCache_.prototype.getValues = function () {
  var values = new Array(this.count_);
  var i = 0;
  var entry;

  for (entry = this.newest_; entry; entry = entry.older) {
    values[i++] = entry.value_;
  }

  return values;
};
/**
 * @return {T} Last value.
 */


_ol_structs_LRUCache_.prototype.peekLast = function () {
  return this.oldest_.value_;
};
/**
 * @return {string} Last key.
 */


_ol_structs_LRUCache_.prototype.peekLastKey = function () {
  return this.oldest_.key_;
};
/**
 * Get the key of the newest item in the cache.  Throws if the cache is empty.
 * @return {string} The newest key.
 */


_ol_structs_LRUCache_.prototype.peekFirstKey = function () {
  return this.newest_.key_;
};
/**
 * @return {T} value Value.
 */


_ol_structs_LRUCache_.prototype.pop = function () {
  var entry = this.oldest_;
  delete this.entries_[entry.key_];

  if (entry.newer) {
    entry.newer.older = null;
  }

  this.oldest_ =
  /** @type {ol.LRUCacheEntry} */
  entry.newer;

  if (!this.oldest_) {
    this.newest_ = null;
  }

  --this.count_;
  return entry.value_;
};
/**
 * @param {string} key Key.
 * @param {T} value Value.
 */


_ol_structs_LRUCache_.prototype.replace = function (key, value) {
  this.get(key); // update `newest_`

  this.entries_[key].value_ = value;
};
/**
 * @param {string} key Key.
 * @param {T} value Value.
 */


_ol_structs_LRUCache_.prototype.set = function (key, value) {
  _asserts2.default.assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already


  var entry =
  /** @type {ol.LRUCacheEntry} */
  {
    key_: key,
    newer: null,
    older: this.newest_,
    value_: value
  };

  if (!this.newest_) {
    this.oldest_ = entry;
  } else {
    this.newest_.newer = entry;
  }

  this.newest_ = entry;
  this.entries_[key] = entry;
  ++this.count_;
};
/**
 * Prune the cache.
 */


_ol_structs_LRUCache_.prototype.prune = function () {
  while (this.canExpireCache()) {
    this.pop();
  }
};

exports.default = _ol_structs_LRUCache_;

},{"../asserts.js":32,"../events/eventtarget.js":52,"../events/eventtype.js":53,"../index.js":90}],220:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * @see http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * @see http://hg.python.org/cpython/file/2.7/Lib/heapq.py
 *
 * @constructor
 * @param {function(T): number} priorityFunction Priority function.
 * @param {function(T): string} keyFunction Key function.
 * @struct
 * @template T
 */
var _ol_structs_PriorityQueue_ = function (priorityFunction, keyFunction) {
  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;
  /**
   * @type {function(T): string}
   * @private
   */

  this.keyFunction_ = keyFunction;
  /**
   * @type {Array.<T>}
   * @private
   */

  this.elements_ = [];
  /**
   * @type {Array.<number>}
   * @private
   */

  this.priorities_ = [];
  /**
   * @type {Object.<string, boolean>}
   * @private
   */

  this.queuedElements_ = {};
};
/**
 * @const
 * @type {number}
 */


_ol_structs_PriorityQueue_.DROP = Infinity;
/**
 * FIXME empty description for jsdoc
 */

_ol_structs_PriorityQueue_.prototype.clear = function () {
  this.elements_.length = 0;
  this.priorities_.length = 0;

  _obj2.default.clear(this.queuedElements_);
};
/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */


_ol_structs_PriorityQueue_.prototype.dequeue = function () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];

  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }

  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};
/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */


_ol_structs_PriorityQueue_.prototype.enqueue = function (element) {
  _asserts2.default.assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue


  var priority = this.priorityFunction_(element);

  if (priority != _ol_structs_PriorityQueue_.DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }

  return false;
};
/**
 * @return {number} Count.
 */


_ol_structs_PriorityQueue_.prototype.getCount = function () {
  return this.elements_.length;
};
/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.getLeftChildIndex_ = function (index) {
  return index * 2 + 1;
};
/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.getRightChildIndex_ = function (index) {
  return index * 2 + 2;
};
/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.getParentIndex_ = function (index) {
  return index - 1 >> 1;
};
/**
 * Make this a heap. O(N).
 * @private
 */


_ol_structs_PriorityQueue_.prototype.heapify_ = function () {
  var i;

  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this.siftUp_(i);
  }
};
/**
 * @return {boolean} Is empty.
 */


_ol_structs_PriorityQueue_.prototype.isEmpty = function () {
  return this.elements_.length === 0;
};
/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */


_ol_structs_PriorityQueue_.prototype.isKeyQueued = function (key) {
  return key in this.queuedElements_;
};
/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */


_ol_structs_PriorityQueue_.prototype.isQueued = function (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};
/**
 * @param {number} index The index of the node to move down.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.siftUp_ = function (index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < count >> 1) {
    var lIndex = this.getLeftChildIndex_(index);
    var rIndex = this.getRightChildIndex_(index);
    var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};
/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */


_ol_structs_PriorityQueue_.prototype.siftDown_ = function (startIndex, index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this.getParentIndex_(index);

    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }

  elements[index] = element;
  priorities[index] = priority;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_structs_PriorityQueue_.prototype.reprioritize = function () {
  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;

  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);

    if (priority == _ol_structs_PriorityQueue_.DROP) {
      delete this.queuedElements_[this.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }

  elements.length = index;
  priorities.length = index;
  this.heapify_();
};

exports.default = _ol_structs_PriorityQueue_;

},{"../asserts.js":32,"../obj.js":125}],221:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _rbush = require("rbush");

var _rbush2 = _interopRequireDefault(_rbush);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Wrapper around the RBush by Vladimir Agafonkin.
 *
 * @constructor
 * @param {number=} opt_maxEntries Max entries.
 * @see https://github.com/mourner/rbush
 * @struct
 * @template T
 */
var _ol_structs_RBush_ = function (opt_maxEntries) {
  /**
   * @private
   */
  this.rbush_ = (0, _rbush2.default)(opt_maxEntries);
  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object.<number, ol.RBushEntry>}
   */

  this.items_ = {};
};
/**
 * Insert a value into the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */


_ol_structs_RBush_.prototype.insert = function (extent, value) {
  /** @type {ol.RBushEntry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };
  this.rbush_.insert(item);
  this.items_[_index2.default.getUid(value)] = item;
};
/**
 * Bulk-insert values into the RBush.
 * @param {Array.<ol.Extent>} extents Extents.
 * @param {Array.<T>} values Values.
 */


_ol_structs_RBush_.prototype.load = function (extents, values) {
  var items = new Array(values.length);

  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];
    /** @type {ol.RBushEntry} */

    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this.items_[_index2.default.getUid(value)] = item;
  }

  this.rbush_.load(items);
};
/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */


_ol_structs_RBush_.prototype.remove = function (value) {
  var uid = _index2.default.getUid(value); // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.


  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};
/**
 * Update the extent of a value in the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */


_ol_structs_RBush_.prototype.update = function (extent, value) {
  var item = this.items_[_index2.default.getUid(value)];

  var bbox = [item.minX, item.minY, item.maxX, item.maxY];

  if (!_extent2.default.equals(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};
/**
 * Return all values in the RBush.
 * @return {Array.<T>} All.
 */


_ol_structs_RBush_.prototype.getAll = function () {
  var items = this.rbush_.all();
  return items.map(function (item) {
    return item.value;
  });
};
/**
 * Return all values in the given extent.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<T>} All in extent.
 */


_ol_structs_RBush_.prototype.getInExtent = function (extent) {
  /** @type {ol.RBushEntry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function (item) {
    return item.value;
  });
};
/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */


_ol_structs_RBush_.prototype.forEach = function (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};
/**
 * Calls a callback function with each value in the provided extent.
 * @param {ol.Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */


_ol_structs_RBush_.prototype.forEachInExtent = function (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};
/**
 * @param {Array.<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */


_ol_structs_RBush_.prototype.forEach_ = function (values, callback, opt_this) {
  var result;

  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);

    if (result) {
      return result;
    }
  }

  return result;
};
/**
 * @return {boolean} Is empty.
 */


_ol_structs_RBush_.prototype.isEmpty = function () {
  return _obj2.default.isEmpty(this.items_);
};
/**
 * Remove all values from the RBush.
 */


_ol_structs_RBush_.prototype.clear = function () {
  this.rbush_.clear();
  this.items_ = {};
};
/**
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */


_ol_structs_RBush_.prototype.getExtent = function (opt_extent) {
  // FIXME add getExtent() to rbush
  var data = this.rbush_.data;
  return _extent2.default.createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};
/**
 * @param {ol.structs.RBush} rbush R-Tree.
 */


_ol_structs_RBush_.prototype.concat = function (rbush) {
  this.rbush_.load(rbush.rbush_.all());

  for (var i in rbush.items_) {
    this.items_[i | 0] = rbush.items_[i | 0];
  }
};

exports.default = _ol_structs_RBush_;

},{"../extent.js":55,"../index.js":90,"../obj.js":125,"rbush":258}],222:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _iconimagecache = require("./style/iconimagecache.js");

var _iconimagecache2 = _interopRequireDefault(_iconimagecache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_style_ = {};
/**
 * The {@link ol.style.IconImageCache} for {@link ol.style.Icon} images.
 * @api
 */

_ol_style_.iconImageCache = new _iconimagecache2.default();
exports.default = _ol_style_;

},{"./style/iconimagecache.js":230}],223:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require("../dom.js");

var _dom2 = _interopRequireDefault(_dom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This class facilitates the creation of image atlases.
 *
 * Images added to an atlas will be rendered onto a single
 * atlas canvas. The distribution of images on the canvas is
 * managed with the bin packing algorithm described in:
 * http://www.blackpawn.com/texts/lightmaps/
 *
 * @constructor
 * @struct
 * @param {number} size The size in pixels of the sprite image.
 * @param {number} space The space in pixels between images.
 *    Because texture coordinates are float values, the edges of
 *    images might not be completely correct (in a way that the
 *    edges overlap when being rendered). To avoid this we add a
 *    padding around each image.
 */
var _ol_style_Atlas_ = function (size, space) {
  /**
   * @private
   * @type {number}
   */
  this.space_ = space;
  /**
   * @private
   * @type {Array.<ol.AtlasBlock>}
   */

  this.emptyBlocks_ = [{
    x: 0,
    y: 0,
    width: size,
    height: size
  }];
  /**
   * @private
   * @type {Object.<string, ol.AtlasInfo>}
   */

  this.entries_ = {};
  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */

  this.context_ = _dom2.default.createCanvasContext2D(size, size);
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = this.context_.canvas;
};
/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The atlas info.
 */


_ol_style_Atlas_.prototype.get = function (id) {
  return this.entries_[id] || null;
};
/**
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback`.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry.
 */


_ol_style_Atlas_.prototype.add = function (id, width, height, renderCallback, opt_this) {
  var block, i, ii;

  for (i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {
    block = this.emptyBlocks_[i];

    if (block.width >= width + this.space_ && block.height >= height + this.space_) {
      // we found a block that is big enough for our entry
      var entry = {
        offsetX: block.x + this.space_,
        offsetY: block.y + this.space_,
        image: this.canvas_
      };
      this.entries_[id] = entry; // render the image on the atlas image

      renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_); // split the block after the insertion, either horizontally or vertically

      this.split_(i, block, width + this.space_, height + this.space_);
      return entry;
    }
  } // there is no space for the new entry in this atlas


  return null;
};
/**
 * @private
 * @param {number} index The index of the block.
 * @param {ol.AtlasBlock} block The block to split.
 * @param {number} width The width of the entry to insert.
 * @param {number} height The height of the entry to insert.
 */


_ol_style_Atlas_.prototype.split_ = function (index, block, width, height) {
  var deltaWidth = block.width - width;
  var deltaHeight = block.height - height;
  /** @type {ol.AtlasBlock} */

  var newBlock1;
  /** @type {ol.AtlasBlock} */

  var newBlock2;

  if (deltaWidth > deltaHeight) {
    // split vertically
    // block right of the inserted entry
    newBlock1 = {
      x: block.x + width,
      y: block.y,
      width: block.width - width,
      height: block.height
    }; // block below the inserted entry

    newBlock2 = {
      x: block.x,
      y: block.y + height,
      width: width,
      height: block.height - height
    };
    this.updateBlocks_(index, newBlock1, newBlock2);
  } else {
    // split horizontally
    // block right of the inserted entry
    newBlock1 = {
      x: block.x + width,
      y: block.y,
      width: block.width - width,
      height: height
    }; // block below the inserted entry

    newBlock2 = {
      x: block.x,
      y: block.y + height,
      width: block.width,
      height: block.height - height
    };
    this.updateBlocks_(index, newBlock1, newBlock2);
  }
};
/**
 * Remove the old block and insert new blocks at the same array position.
 * The new blocks are inserted at the same position, so that splitted
 * blocks (that are potentially smaller) are filled first.
 * @private
 * @param {number} index The index of the block to remove.
 * @param {ol.AtlasBlock} newBlock1 The 1st block to add.
 * @param {ol.AtlasBlock} newBlock2 The 2nd block to add.
 */


_ol_style_Atlas_.prototype.updateBlocks_ = function (index, newBlock1, newBlock2) {
  var args = [index, 1];

  if (newBlock1.width > 0 && newBlock1.height > 0) {
    args.push(newBlock1);
  }

  if (newBlock2.width > 0 && newBlock2.height > 0) {
    args.push(newBlock2);
  }

  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);
};

exports.default = _ol_style_Atlas_;

},{"../dom.js":47}],224:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _atlas = require("../style/atlas.js");

var _atlas2 = _interopRequireDefault(_atlas);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Manages the creation of image atlases.
 *
 * Images added to this manager will be inserted into an atlas, which
 * will be used for rendering.
 * The `size` given in the constructor is the size for the first
 * atlas. After that, when new atlases are created, they will have
 * twice the size as the latest atlas (until `maxSize` is reached).
 *
 * If an application uses many images or very large images, it is recommended
 * to set a higher `size` value to avoid the creation of too many atlases.
 *
 * @constructor
 * @struct
 * @api
 * @param {olx.style.AtlasManagerOptions=} opt_options Options.
 */
var _ol_style_AtlasManager_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * The size in pixels of the latest atlas image.
   * @private
   * @type {number}
   */

  this.currentSize_ = options.initialSize !== undefined ? options.initialSize : _index2.default.INITIAL_ATLAS_SIZE;
  /**
   * The maximum size in pixels of atlas images.
   * @private
   * @type {number}
   */

  this.maxSize_ = options.maxSize !== undefined ? options.maxSize : _index2.default.MAX_ATLAS_SIZE != -1 ? _index2.default.MAX_ATLAS_SIZE : _index2.default.WEBGL_MAX_TEXTURE_SIZE !== undefined ? _index2.default.WEBGL_MAX_TEXTURE_SIZE : 2048;
  /**
   * The size in pixels between images.
   * @private
   * @type {number}
   */

  this.space_ = options.space !== undefined ? options.space : 1;
  /**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */

  this.atlases_ = [new _atlas2.default(this.currentSize_, this.space_)];
  /**
   * The size in pixels of the latest atlas image for hit-detection images.
   * @private
   * @type {number}
   */

  this.currentHitSize_ = this.currentSize_;
  /**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */

  this.hitAtlases_ = [new _atlas2.default(this.currentHitSize_, this.space_)];
};
/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlas manager.
 */


_ol_style_AtlasManager_.prototype.getInfo = function (id) {
  /** @type {?ol.AtlasInfo} */
  var info = this.getInfo_(this.atlases_, id);

  if (!info) {
    return null;
  }

  var hitInfo =
  /** @type {ol.AtlasInfo} */
  this.getInfo_(this.hitAtlases_, id);
  return this.mergeInfos_(info, hitInfo);
};
/**
 * @private
 * @param {Array.<ol.style.Atlas>} atlases The atlases to search.
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry,
 *    or `null` if the entry is not part of the atlases.
 */


_ol_style_AtlasManager_.prototype.getInfo_ = function (atlases, id) {
  var atlas, info, i, ii;

  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.get(id);

    if (info) {
      return info;
    }
  }

  return null;
};
/**
 * @private
 * @param {ol.AtlasInfo} info The info for the real image.
 * @param {ol.AtlasInfo} hitInfo The info for the hit-detection
 *    image.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlases.
 */


_ol_style_AtlasManager_.prototype.mergeInfos_ = function (info, hitInfo) {
  return (
    /** @type {ol.AtlasManagerInfo} */
    {
      offsetX: info.offsetX,
      offsetY: info.offsetY,
      image: info.image,
      hitImage: hitInfo.image
    }
  );
};
/**
 * Add an image to the atlas manager.
 *
 * If an entry for the given id already exists, the entry will
 * be overridden (but the space on the atlas graphic will not be freed).
 *
 * If `renderHitCallback` is provided, the image (or the hit-detection version
 * of the image) will be rendered into a separate hit-detection atlas image.
 *
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {function(CanvasRenderingContext2D, number, number)=}
 *    opt_renderHitCallback Called to render a hit-detection image onto a hit
 *    detection atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasManagerInfo}  The position and atlas image for the
 *    entry, or `null` if the image is too big.
 */


_ol_style_AtlasManager_.prototype.add = function (id, width, height, renderCallback, opt_renderHitCallback, opt_this) {
  if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {
    return null;
  }
  /** @type {?ol.AtlasInfo} */


  var info = this.add_(false, id, width, height, renderCallback, opt_this);

  if (!info) {
    return null;
  } // even if no hit-detection entry is requested, we insert a fake entry into
  // the hit-detection atlas, to make sure that the offset is the same for
  // the original image and the hit-detection image.


  var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : _index2.default.nullFunction;
  var hitInfo =
  /** @type {ol.AtlasInfo} */
  this.add_(true, id, width, height, renderHitCallback, opt_this);
  return this.mergeInfos_(info, hitInfo);
};
/**
 * @private
 * @param {boolean} isHitAtlas If the hit-detection atlases are used.
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasInfo}  The position and atlas image for the entry,
 *    or `null` if the image is too big.
 */


_ol_style_AtlasManager_.prototype.add_ = function (isHitAtlas, id, width, height, renderCallback, opt_this) {
  var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;
  var atlas, info, i, ii;

  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.add(id, width, height, renderCallback, opt_this);

    if (info) {
      return info;
    } else if (!info && i === ii - 1) {
      // the entry could not be added to one of the existing atlases,
      // create a new atlas that is twice as big and try to add to this one.
      var size;

      if (isHitAtlas) {
        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);
        this.currentHitSize_ = size;
      } else {
        size = Math.min(this.currentSize_ * 2, this.maxSize_);
        this.currentSize_ = size;
      }

      atlas = new _atlas2.default(size, this.space_);
      atlases.push(atlas); // run the loop another time

      ++ii;
    }
  }

  return null;
};

exports.default = _ol_style_AtlasManager_;

},{"../index.js":90,"../style/atlas.js":223}],225:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _regularshape = require("../style/regularshape.js");

var _regularshape2 = _interopRequireDefault(_regularshape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @param {olx.style.CircleOptions=} opt_options Options.
 * @extends {ol.style.RegularShape}
 * @api
 */
var _ol_style_Circle_ = function (opt_options) {
  var options = opt_options || {};

  _regularshape2.default.call(this, {
    points: Infinity,
    fill: options.fill,
    radius: options.radius,
    snapToPixel: options.snapToPixel,
    stroke: options.stroke,
    atlasManager: options.atlasManager
  });
};

_index2.default.inherits(_ol_style_Circle_, _regularshape2.default);
/**
 * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.Circle} The cloned style.
 * @override
 * @api
 */


_ol_style_Circle_.prototype.clone = function () {
  var style = new _ol_style_Circle_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    radius: this.getRadius(),
    snapToPixel: this.getSnapToPixel(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};
/**
 * Set the circle radius.
 *
 * @param {number} radius Circle radius.
 * @api
 */


_ol_style_Circle_.prototype.setRadius = function (radius) {
  this.radius_ = radius;
  this.render_(this.atlasManager_);
};

exports.default = _ol_style_Circle_;

},{"../index.js":90,"../style/regularshape.js":233}],226:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _color = require("../color.js");

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Set fill style for vector features.
 *
 * @constructor
 * @param {olx.style.FillOptions=} opt_options Options.
 * @api
 */
var _ol_style_Fill_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */

  this.color_ = options.color !== undefined ? options.color : null;
  /**
   * @private
   * @type {string|undefined}
   */

  this.checksum_ = undefined;
};
/**
 * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.
 * @return {ol.style.Fill} The cloned style.
 * @api
 */


_ol_style_Fill_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Fill_({
    color: color && color.slice ? color.slice() : color || undefined
  });
};
/**
 * Get the fill color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */


_ol_style_Fill_.prototype.getColor = function () {
  return this.color_;
};
/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */


_ol_style_Fill_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};
/**
 * @return {string} The checksum.
 */


_ol_style_Fill_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    if (this.color_ instanceof CanvasPattern || this.color_ instanceof CanvasGradient) {
      this.checksum_ = _index2.default.getUid(this.color_).toString();
    } else {
      this.checksum_ = 'f' + (this.color_ ? _color2.default.asString(this.color_) : '-');
    }
  }

  return this.checksum_;
};

exports.default = _ol_style_Fill_;

},{"../color.js":37,"../index.js":90}],227:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _color = require("../color.js");

var _color2 = _interopRequireDefault(_color);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _iconanchorunits = require("../style/iconanchorunits.js");

var _iconanchorunits2 = _interopRequireDefault(_iconanchorunits);

var _iconimage = require("../style/iconimage.js");

var _iconimage2 = _interopRequireDefault(_iconimage);

var _iconorigin = require("../style/iconorigin.js");

var _iconorigin2 = _interopRequireDefault(_iconorigin);

var _image = require("../style/image.js");

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Set icon style for vector features.
 *
 * @constructor
 * @param {olx.style.IconOptions=} opt_options Options.
 * @extends {ol.style.Image}
 * @api
 */
var _ol_style_Icon_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {Array.<number>}
   */

  this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
  /**
   * @private
   * @type {Array.<number>}
   */

  this.normalizedAnchor_ = null;
  /**
   * @private
   * @type {ol.style.IconOrigin}
   */

  this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : _iconorigin2.default.TOP_LEFT;
  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */

  this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : _iconanchorunits2.default.FRACTION;
  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */

  this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : _iconanchorunits2.default.FRACTION;
  /**
   * @private
   * @type {?string}
   */

  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  /**
   * @type {Image|HTMLCanvasElement}
   */

  var image = options.img !== undefined ? options.img : null;
  /**
   * @type {ol.Size}
   */

  var imgSize = options.imgSize !== undefined ? options.imgSize : null;
  /**
   * @type {string|undefined}
   */

  var src = options.src;

  _asserts2.default.assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time


  _asserts2.default.assert(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided


  if ((src === undefined || src.length === 0) && image) {
    src = image.src || _index2.default.getUid(image).toString();
  }

  _asserts2.default.assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

  /**
   * @type {ol.ImageState}
   */


  var imageState = options.src !== undefined ? _imagestate2.default.IDLE : _imagestate2.default.LOADED;
  /**
   * @private
   * @type {ol.Color}
   */

  this.color_ = options.color !== undefined ? _color2.default.asArray(options.color) : null;
  /**
   * @private
   * @type {ol.style.IconImage}
   */

  this.iconImage_ = _iconimage2.default.get(image,
  /** @type {string} */
  src, imgSize, this.crossOrigin_, imageState, this.color_);
  /**
   * @private
   * @type {Array.<number>}
   */

  this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
  /**
   * @private
   * @type {ol.style.IconOrigin}
   */

  this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : _iconorigin2.default.TOP_LEFT;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.origin_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.size_ = options.size !== undefined ? options.size : null;
  /**
   * @type {number}
   */

  var opacity = options.opacity !== undefined ? options.opacity : 1;
  /**
   * @type {boolean}
   */

  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
  /**
   * @type {number}
   */

  var rotation = options.rotation !== undefined ? options.rotation : 0;
  /**
   * @type {number}
   */

  var scale = options.scale !== undefined ? options.scale : 1;
  /**
   * @type {boolean}
   */

  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;

  _image2.default.call(this, {
    opacity: opacity,
    rotation: rotation,
    scale: scale,
    snapToPixel: snapToPixel,
    rotateWithView: rotateWithView
  });
};

_index2.default.inherits(_ol_style_Icon_, _image2.default);
/**
 * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
 * @return {ol.style.Icon} The cloned style.
 * @api
 */


_ol_style_Icon_.prototype.clone = function () {
  return new _ol_style_Icon_({
    anchor: this.anchor_.slice(),
    anchorOrigin: this.anchorOrigin_,
    anchorXUnits: this.anchorXUnits_,
    anchorYUnits: this.anchorYUnits_,
    crossOrigin: this.crossOrigin_,
    color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
    src: this.getSrc(),
    offset: this.offset_.slice(),
    offsetOrigin: this.offsetOrigin_,
    size: this.size_ !== null ? this.size_.slice() : undefined,
    opacity: this.getOpacity(),
    scale: this.getScale(),
    snapToPixel: this.getSnapToPixel(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView()
  });
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_Icon_.prototype.getAnchor = function () {
  if (this.normalizedAnchor_) {
    return this.normalizedAnchor_;
  }

  var anchor = this.anchor_;
  var size = this.getSize();

  if (this.anchorXUnits_ == _iconanchorunits2.default.FRACTION || this.anchorYUnits_ == _iconanchorunits2.default.FRACTION) {
    if (!size) {
      return null;
    }

    anchor = this.anchor_.slice();

    if (this.anchorXUnits_ == _iconanchorunits2.default.FRACTION) {
      anchor[0] *= size[0];
    }

    if (this.anchorYUnits_ == _iconanchorunits2.default.FRACTION) {
      anchor[1] *= size[1];
    }
  }

  if (this.anchorOrigin_ != _iconorigin2.default.TOP_LEFT) {
    if (!size) {
      return null;
    }

    if (anchor === this.anchor_) {
      anchor = this.anchor_.slice();
    }

    if (this.anchorOrigin_ == _iconorigin2.default.TOP_RIGHT || this.anchorOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      anchor[0] = -anchor[0] + size[0];
    }

    if (this.anchorOrigin_ == _iconorigin2.default.BOTTOM_LEFT || this.anchorOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      anchor[1] = -anchor[1] + size[1];
    }
  }

  this.normalizedAnchor_ = anchor;
  return this.normalizedAnchor_;
};
/**
 * Get the icon color.
 * @return {ol.Color} Color.
 * @api
 */


_ol_style_Icon_.prototype.getColor = function () {
  return this.color_;
};
/**
 * Get the image icon.
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 * @override
 * @api
 */


_ol_style_Icon_.prototype.getImage = function (pixelRatio) {
  return this.iconImage_.getImage(pixelRatio);
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getImageSize = function () {
  return this.iconImage_.getSize();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getHitDetectionImageSize = function () {
  return this.getImageSize();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getImageState = function () {
  return this.iconImage_.getImageState();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.iconImage_.getHitDetectionImage(pixelRatio);
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_Icon_.prototype.getOrigin = function () {
  if (this.origin_) {
    return this.origin_;
  }

  var offset = this.offset_;

  if (this.offsetOrigin_ != _iconorigin2.default.TOP_LEFT) {
    var size = this.getSize();
    var iconImageSize = this.iconImage_.getSize();

    if (!size || !iconImageSize) {
      return null;
    }

    offset = offset.slice();

    if (this.offsetOrigin_ == _iconorigin2.default.TOP_RIGHT || this.offsetOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      offset[0] = iconImageSize[0] - size[0] - offset[0];
    }

    if (this.offsetOrigin_ == _iconorigin2.default.BOTTOM_LEFT || this.offsetOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      offset[1] = iconImageSize[1] - size[1] - offset[1];
    }
  }

  this.origin_ = offset;
  return this.origin_;
};
/**
 * Get the image URL.
 * @return {string|undefined} Image src.
 * @api
 */


_ol_style_Icon_.prototype.getSrc = function () {
  return this.iconImage_.getSrc();
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_Icon_.prototype.getSize = function () {
  return !this.size_ ? this.iconImage_.getSize() : this.size_;
};
/**
 * @override
 */


_ol_style_Icon_.prototype.listenImageChange = function (listener, thisArg) {
  return _events2.default.listen(this.iconImage_, _eventtype2.default.CHANGE, listener, thisArg);
};
/**
 * Load not yet loaded URI.
 * When rendering a feature with an icon style, the vector renderer will
 * automatically call this method. However, you might want to call this
 * method yourself for preloading or other purposes.
 * @override
 * @api
 */


_ol_style_Icon_.prototype.load = function () {
  this.iconImage_.load();
};
/**
 * @override
 */


_ol_style_Icon_.prototype.unlistenImageChange = function (listener, thisArg) {
  _events2.default.unlisten(this.iconImage_, _eventtype2.default.CHANGE, listener, thisArg);
};

exports.default = _ol_style_Icon_;

},{"../asserts.js":32,"../color.js":37,"../events.js":49,"../events/eventtype.js":53,"../imagestate.js":89,"../index.js":90,"../style/iconanchorunits.js":228,"../style/iconimage.js":229,"../style/iconorigin.js":231,"../style/image.js":232}],228:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
var _ol_style_IconAnchorUnits_ = {
  FRACTION: 'fraction',
  PIXELS: 'pixels'
};
exports.default = _ol_style_IconAnchorUnits_;

},{}],229:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _dom = require("../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require("../events/eventtarget.js");

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require("../events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _style = require("../style.js");

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string|undefined} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @extends {ol.events.EventTarget}
 */
var _ol_style_IconImage_ = function (image, src, size, crossOrigin, imageState, color) {
  _eventtarget2.default.call(this);
  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */


  this.hitDetectionImage_ = null;
  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */

  this.image_ = !image ? new Image() : image;

  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  /**
   * @private
   * @type {HTMLCanvasElement}
   */


  this.canvas_ = color ?
  /** @type {HTMLCanvasElement} */
  document.createElement('CANVAS') : null;
  /**
   * @private
   * @type {ol.Color}
   */

  this.color_ = color;
  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */

  this.imageListenerKeys_ = null;
  /**
   * @private
   * @type {ol.ImageState}
   */

  this.imageState_ = imageState;
  /**
   * @private
   * @type {ol.Size}
   */

  this.size_ = size;
  /**
   * @private
   * @type {string|undefined}
   */

  this.src_ = src;
  /**
   * @private
   * @type {boolean}
   */

  this.tainting_ = false;

  if (this.imageState_ == _imagestate2.default.LOADED) {
    this.determineTainting_();
  }
};

_index2.default.inherits(_ol_style_IconImage_, _eventtarget2.default);
/**
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */


_ol_style_IconImage_.get = function (image, src, size, crossOrigin, imageState, color) {
  var iconImageCache = _style2.default.iconImageCache;
  var iconImage = iconImageCache.get(src, crossOrigin, color);

  if (!iconImage) {
    iconImage = new _ol_style_IconImage_(image, src, size, crossOrigin, imageState, color);
    iconImageCache.set(src, crossOrigin, color, iconImage);
  }

  return iconImage;
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.determineTainting_ = function () {
  var context = _dom2.default.createCanvasContext2D(1, 1);

  try {
    context.drawImage(this.image_, 0, 0);
    context.getImageData(0, 0, 1, 1);
  } catch (e) {
    this.tainting_ = true;
  }
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.dispatchChangeEvent_ = function () {
  this.dispatchEvent(_eventtype2.default.CHANGE);
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.handleImageError_ = function () {
  this.imageState_ = _imagestate2.default.ERROR;
  this.unlistenImage_();
  this.dispatchChangeEvent_();
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.handleImageLoad_ = function () {
  this.imageState_ = _imagestate2.default.LOADED;

  if (this.size_) {
    this.image_.width = this.size_[0];
    this.image_.height = this.size_[1];
  }

  this.size_ = [this.image_.width, this.image_.height];
  this.unlistenImage_();
  this.determineTainting_();
  this.replaceColor_();
  this.dispatchChangeEvent_();
};
/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 */


_ol_style_IconImage_.prototype.getImage = function (pixelRatio) {
  return this.canvas_ ? this.canvas_ : this.image_;
};
/**
 * @return {ol.ImageState} Image state.
 */


_ol_style_IconImage_.prototype.getImageState = function () {
  return this.imageState_;
};
/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image element.
 */


_ol_style_IconImage_.prototype.getHitDetectionImage = function (pixelRatio) {
  if (!this.hitDetectionImage_) {
    if (this.tainting_) {
      var width = this.size_[0];
      var height = this.size_[1];

      var context = _dom2.default.createCanvasContext2D(width, height);

      context.fillRect(0, 0, width, height);
      this.hitDetectionImage_ = context.canvas;
    } else {
      this.hitDetectionImage_ = this.image_;
    }
  }

  return this.hitDetectionImage_;
};
/**
 * @return {ol.Size} Image size.
 */


_ol_style_IconImage_.prototype.getSize = function () {
  return this.size_;
};
/**
 * @return {string|undefined} Image src.
 */


_ol_style_IconImage_.prototype.getSrc = function () {
  return this.src_;
};
/**
 * Load not yet loaded URI.
 */


_ol_style_IconImage_.prototype.load = function () {
  if (this.imageState_ == _imagestate2.default.IDLE) {
    this.imageState_ = _imagestate2.default.LOADING;
    this.imageListenerKeys_ = [_events2.default.listenOnce(this.image_, _eventtype2.default.ERROR, this.handleImageError_, this), _events2.default.listenOnce(this.image_, _eventtype2.default.LOAD, this.handleImageLoad_, this)];

    try {
      this.image_.src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
  }
};
/**
 * @private
 */


_ol_style_IconImage_.prototype.replaceColor_ = function () {
  if (this.tainting_ || this.color_ === null) {
    return;
  }

  this.canvas_.width = this.image_.width;
  this.canvas_.height = this.image_.height;
  var ctx = this.canvas_.getContext('2d');
  ctx.drawImage(this.image_, 0, 0);
  var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);
  var data = imgData.data;
  var r = this.color_[0] / 255.0;
  var g = this.color_[1] / 255.0;
  var b = this.color_[2] / 255.0;

  for (var i = 0, ii = data.length; i < ii; i += 4) {
    data[i] *= r;
    data[i + 1] *= g;
    data[i + 2] *= b;
  }

  ctx.putImageData(imgData, 0, 0);
};
/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */


_ol_style_IconImage_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.imageListenerKeys_ = null;
};

exports.default = _ol_style_IconImage_;

},{"../dom.js":47,"../events.js":49,"../events/eventtarget.js":52,"../events/eventtype.js":53,"../imagestate.js":89,"../index.js":90,"../style.js":222}],230:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color = require("../color.js");

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Singleton class. Available through {@link ol.style.iconImageCache}.
 * @constructor
 */
var _ol_style_IconImageCache_ = function () {
  /**
   * @type {Object.<string, ol.style.IconImage>}
   * @private
   */
  this.cache_ = {};
  /**
   * @type {number}
   * @private
   */

  this.cacheSize_ = 0;
  /**
   * @type {number}
   * @private
   */

  this.maxCacheSize_ = 32;
};
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {string} Cache key.
 */


_ol_style_IconImageCache_.getKey = function (src, crossOrigin, color) {
  var colorString = color ? _color2.default.asString(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_style_IconImageCache_.prototype.clear = function () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};
/**
 * FIXME empty description for jsdoc
 */


_ol_style_IconImageCache_.prototype.expire = function () {
  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    var key, iconImage;

    for (key in this.cache_) {
      iconImage = this.cache_[key];

      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this.cache_[key];
        --this.cacheSize_;
      }
    }
  }
};
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */


_ol_style_IconImageCache_.prototype.get = function (src, crossOrigin, color) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);

  return key in this.cache_ ? this.cache_[key] : null;
};
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @param {ol.style.IconImage} iconImage Icon image.
 */


_ol_style_IconImageCache_.prototype.set = function (src, crossOrigin, color, iconImage) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);

  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};
/**
 * Set the cache size of the icon cache. Default is `32`. Change this value when
 * your map uses more than 32 different icon images and you are not caching icon
 * styles on the application level.
 * @param {number} maxCacheSize Cache max size.
 * @api
 */


_ol_style_IconImageCache_.prototype.setSize = function (maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};

exports.default = _ol_style_IconImageCache_;

},{"../color.js":37}],231:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
var _ol_style_IconOrigin_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};
exports.default = _ol_style_IconOrigin_;

},{}],232:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and
 * {@link ol.style.RegularShape}.
 *
 * @constructor
 * @abstract
 * @param {ol.StyleImageOptions} options Options.
 * @api
 */
var _ol_style_Image_ = function (options) {
  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;
  /**
   * @private
   * @type {boolean}
   */

  this.rotateWithView_ = options.rotateWithView;
  /**
   * @private
   * @type {number}
   */

  this.rotation_ = options.rotation;
  /**
   * @private
   * @type {number}
   */

  this.scale_ = options.scale;
  /**
   * @private
   * @type {boolean}
   */

  this.snapToPixel_ = options.snapToPixel;
};
/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */


_ol_style_Image_.prototype.getOpacity = function () {
  return this.opacity_;
};
/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */


_ol_style_Image_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};
/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */


_ol_style_Image_.prototype.getRotation = function () {
  return this.rotation_;
};
/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */


_ol_style_Image_.prototype.getScale = function () {
  return this.scale_;
};
/**
 * Determine whether the symbolizer should be snapped to a pixel.
 * @return {boolean} The symbolizer should snap to a pixel.
 * @api
 */


_ol_style_Image_.prototype.getSnapToPixel = function () {
  return this.snapToPixel_;
};
/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array.<number>} Anchor.
 */


_ol_style_Image_.prototype.getAnchor = function () {};
/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */


_ol_style_Image_.prototype.getImage = function (pixelRatio) {};
/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */


_ol_style_Image_.prototype.getHitDetectionImage = function (pixelRatio) {};
/**
 * @abstract
 * @return {ol.ImageState} Image state.
 */


_ol_style_Image_.prototype.getImageState = function () {};
/**
 * @abstract
 * @return {ol.Size} Image size.
 */


_ol_style_Image_.prototype.getImageSize = function () {};
/**
 * @abstract
 * @return {ol.Size} Size of the hit-detection image.
 */


_ol_style_Image_.prototype.getHitDetectionImageSize = function () {};
/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array.<number>} Origin.
 */


_ol_style_Image_.prototype.getOrigin = function () {};
/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {ol.Size} Size.
 */


_ol_style_Image_.prototype.getSize = function () {};
/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */


_ol_style_Image_.prototype.setOpacity = function (opacity) {
  this.opacity_ = opacity;
};
/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 */


_ol_style_Image_.prototype.setRotateWithView = function (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};
/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */


_ol_style_Image_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};
/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */


_ol_style_Image_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};
/**
 * Set whether to snap the image to the closest pixel.
 *
 * @param {boolean} snapToPixel Snap to pixel?
 */


_ol_style_Image_.prototype.setSnapToPixel = function (snapToPixel) {
  this.snapToPixel_ = snapToPixel;
};
/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {ol.EventsKey|undefined} Listener key.
 * @template T
 */


_ol_style_Image_.prototype.listenImageChange = function (listener, thisArg) {};
/**
 * Load not yet loaded URI.
 * @abstract
 */


_ol_style_Image_.prototype.load = function () {};
/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */


_ol_style_Image_.prototype.unlistenImageChange = function (listener, thisArg) {};

exports.default = _ol_style_Image_;

},{}],233:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _colorlike = require("../colorlike.js");

var _colorlike2 = _interopRequireDefault(_colorlike);

var _dom = require("../dom.js");

var _dom2 = _interopRequireDefault(_dom);

var _has = require("../has.js");

var _has2 = _interopRequireDefault(_has);

var _imagestate = require("../imagestate.js");

var _imagestate2 = _interopRequireDefault(_imagestate);

var _canvas = require("../render/canvas.js");

var _canvas2 = _interopRequireDefault(_canvas);

var _image = require("../style/image.js");

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 *
 * @constructor
 * @param {olx.style.RegularShapeOptions} options Options.
 * @extends {ol.style.Image}
 * @api
 */
var _ol_style_RegularShape_ = function (options) {
  /**
   * @private
   * @type {Array.<string>}
   */
  this.checksums_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.canvas_ = null;
  /**
   * @private
   * @type {HTMLCanvasElement}
   */

  this.hitDetectionCanvas_ = null;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.fill_ = options.fill !== undefined ? options.fill : null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.origin_ = [0, 0];
  /**
   * @private
   * @type {number}
   */

  this.points_ = options.points;
  /**
   * @protected
   * @type {number}
   */

  this.radius_ =
  /** @type {number} */
  options.radius !== undefined ? options.radius : options.radius1;
  /**
   * @private
   * @type {number|undefined}
   */

  this.radius2_ = options.radius2;
  /**
   * @private
   * @type {number}
   */

  this.angle_ = options.angle !== undefined ? options.angle : 0;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.anchor_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.size_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.imageSize_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.hitDetectionImageSize_ = null;
  /**
   * @protected
   * @type {ol.style.AtlasManager|undefined}
   */

  this.atlasManager_ = options.atlasManager;
  this.render_(this.atlasManager_);
  /**
   * @type {boolean}
   */

  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;
  /**
   * @type {boolean}
   */

  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;

  _image2.default.call(this, {
    opacity: 1,
    rotateWithView: rotateWithView,
    rotation: options.rotation !== undefined ? options.rotation : 0,
    scale: 1,
    snapToPixel: snapToPixel
  });
};

_index2.default.inherits(_ol_style_RegularShape_, _image2.default);
/**
 * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.RegularShape} The cloned style.
 * @api
 */


_ol_style_RegularShape_.prototype.clone = function () {
  var style = new _ol_style_RegularShape_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    points: this.getPoints(),
    radius: this.getRadius(),
    radius2: this.getRadius2(),
    angle: this.getAngle(),
    snapToPixel: this.getSnapToPixel(),
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getAnchor = function () {
  return this.anchor_;
};
/**
 * Get the angle used in generating the shape.
 * @return {number} Shape's rotation in radians.
 * @api
 */


_ol_style_RegularShape_.prototype.getAngle = function () {
  return this.angle_;
};
/**
 * Get the fill style for the shape.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_RegularShape_.prototype.getFill = function () {
  return this.fill_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.hitDetectionCanvas_;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getImage = function (pixelRatio) {
  return this.canvas_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getImageSize = function () {
  return this.imageSize_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getHitDetectionImageSize = function () {
  return this.hitDetectionImageSize_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.getImageState = function () {
  return _imagestate2.default.LOADED;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getOrigin = function () {
  return this.origin_;
};
/**
 * Get the number of points for generating the shape.
 * @return {number} Number of points for stars and regular polygons.
 * @api
 */


_ol_style_RegularShape_.prototype.getPoints = function () {
  return this.points_;
};
/**
 * Get the (primary) radius for the shape.
 * @return {number} Radius.
 * @api
 */


_ol_style_RegularShape_.prototype.getRadius = function () {
  return this.radius_;
};
/**
 * Get the secondary radius for the shape.
 * @return {number|undefined} Radius2.
 * @api
 */


_ol_style_RegularShape_.prototype.getRadius2 = function () {
  return this.radius2_;
};
/**
 * @inheritDoc
 * @api
 */


_ol_style_RegularShape_.prototype.getSize = function () {
  return this.size_;
};
/**
 * Get the stroke style for the shape.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_RegularShape_.prototype.getStroke = function () {
  return this.stroke_;
};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.listenImageChange = function (listener, thisArg) {};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.load = function () {};
/**
 * @inheritDoc
 */


_ol_style_RegularShape_.prototype.unlistenImageChange = function (listener, thisArg) {};
/**
 * @protected
 * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.
 */


_ol_style_RegularShape_.prototype.render_ = function (atlasManager) {
  var imageSize;
  var lineCap = '';
  var lineJoin = '';
  var miterLimit = 0;
  var lineDash = null;
  var lineDashOffset = 0;
  var strokeStyle;
  var strokeWidth = 0;

  if (this.stroke_) {
    strokeStyle = this.stroke_.getColor();

    if (strokeStyle === null) {
      strokeStyle = _canvas2.default.defaultStrokeStyle;
    }

    strokeStyle = _colorlike2.default.asColorLike(strokeStyle);
    strokeWidth = this.stroke_.getWidth();

    if (strokeWidth === undefined) {
      strokeWidth = _canvas2.default.defaultLineWidth;
    }

    lineDash = this.stroke_.getLineDash();
    lineDashOffset = this.stroke_.getLineDashOffset();

    if (!_has2.default.CANVAS_LINE_DASH) {
      lineDash = null;
      lineDashOffset = 0;
    }

    lineJoin = this.stroke_.getLineJoin();

    if (lineJoin === undefined) {
      lineJoin = _canvas2.default.defaultLineJoin;
    }

    lineCap = this.stroke_.getLineCap();

    if (lineCap === undefined) {
      lineCap = _canvas2.default.defaultLineCap;
    }

    miterLimit = this.stroke_.getMiterLimit();

    if (miterLimit === undefined) {
      miterLimit = _canvas2.default.defaultMiterLimit;
    }
  }

  var size = 2 * (this.radius_ + strokeWidth) + 1;
  /** @type {ol.RegularShapeRenderOptions} */

  var renderOptions = {
    strokeStyle: strokeStyle,
    strokeWidth: strokeWidth,
    size: size,
    lineCap: lineCap,
    lineDash: lineDash,
    lineDashOffset: lineDashOffset,
    lineJoin: lineJoin,
    miterLimit: miterLimit
  };

  if (atlasManager === undefined) {
    // no atlas manager is used, create a new canvas
    var context = _dom2.default.createCanvasContext2D(size, size);

    this.canvas_ = context.canvas; // canvas.width and height are rounded to the closest integer

    size = this.canvas_.width;
    imageSize = size;
    this.draw_(renderOptions, context, 0, 0);
    this.createHitDetectionCanvas_(renderOptions);
  } else {
    // an atlas manager is used, add the symbol to an atlas
    size = Math.round(size);
    var hasCustomHitDetectionImage = !this.fill_;
    var renderHitDetectionCallback;

    if (hasCustomHitDetectionImage) {
      // render the hit-detection image into a separate atlas image
      renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);
    }

    var id = this.getChecksum();
    var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);
    this.canvas_ = info.image;
    this.origin_ = [info.offsetX, info.offsetY];
    imageSize = info.image.width;

    if (hasCustomHitDetectionImage) {
      this.hitDetectionCanvas_ = info.hitImage;
      this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];
    } else {
      this.hitDetectionCanvas_ = this.canvas_;
      this.hitDetectionImageSize_ = [imageSize, imageSize];
    }
  }

  this.anchor_ = [size / 2, size / 2];
  this.size_ = [size, size];
  this.imageSize_ = [imageSize, imageSize];
};
/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */


_ol_style_RegularShape_.prototype.draw_ = function (renderOptions, context, x, y) {
  var i, angle0, radiusC; // reset transform

  context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)

  context.translate(x, y);
  context.beginPath();
  var points = this.points_;

  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

    if (radius2 !== this.radius_) {
      points = 2 * points;
    }

    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  if (this.fill_) {
    var color = this.fill_.getColor();

    if (color === null) {
      color = _canvas2.default.defaultFillStyle;
    }

    context.fillStyle = _colorlike2.default.asColorLike(color);
    context.fill();
  }

  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;

    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }

    context.lineCap = renderOptions.lineCap;
    context.lineJoin = renderOptions.lineJoin;
    context.miterLimit = renderOptions.miterLimit;
    context.stroke();
  }

  context.closePath();
};
/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 */


_ol_style_RegularShape_.prototype.createHitDetectionCanvas_ = function (renderOptions) {
  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];

  if (this.fill_) {
    this.hitDetectionCanvas_ = this.canvas_;
    return;
  } // if no fill style is set, create an extra hit-detection image with a
  // default fill style


  var context = _dom2.default.createCanvasContext2D(renderOptions.size, renderOptions.size);

  this.hitDetectionCanvas_ = context.canvas;
  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
};
/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */


_ol_style_RegularShape_.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)

  context.translate(x, y);
  context.beginPath();
  var points = this.points_;

  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

    if (radius2 !== this.radius_) {
      points = 2 * points;
    }

    var i, radiusC, angle0;

    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  context.fillStyle = _canvas2.default.defaultFillStyle;
  context.fill();

  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;

    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }

    context.stroke();
  }

  context.closePath();
};
/**
 * @return {string} The checksum.
 */


_ol_style_RegularShape_.prototype.getChecksum = function () {
  var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';
  var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';
  var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];

  if (recalculate) {
    var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');
    this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];
  }

  return this.checksums_[0];
};

exports.default = _ol_style_RegularShape_;

},{"../colorlike.js":38,"../dom.js":47,"../has.js":85,"../imagestate.js":89,"../index.js":90,"../render/canvas.js":151,"../style/image.js":232}],234:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 *
 * @constructor
 * @param {olx.style.StrokeOptions=} opt_options Options.
 * @api
 */
var _ol_style_Stroke_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */

  this.color_ = options.color !== undefined ? options.color : null;
  /**
   * @private
   * @type {string|undefined}
   */

  this.lineCap_ = options.lineCap;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.lineDashOffset_ = options.lineDashOffset;
  /**
   * @private
   * @type {string|undefined}
   */

  this.lineJoin_ = options.lineJoin;
  /**
   * @private
   * @type {number|undefined}
   */

  this.miterLimit_ = options.miterLimit;
  /**
   * @private
   * @type {number|undefined}
   */

  this.width_ = options.width;
  /**
   * @private
   * @type {string|undefined}
   */

  this.checksum_ = undefined;
};
/**
 * Clones the style.
 * @return {ol.style.Stroke} The cloned style.
 * @api
 */


_ol_style_Stroke_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Stroke_({
    color: color && color.slice ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};
/**
 * Get the stroke color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */


_ol_style_Stroke_.prototype.getColor = function () {
  return this.color_;
};
/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */


_ol_style_Stroke_.prototype.getLineCap = function () {
  return this.lineCap_;
};
/**
 * Get the line dash style for the stroke.
 * @return {Array.<number>} Line dash.
 * @api
 */


_ol_style_Stroke_.prototype.getLineDash = function () {
  return this.lineDash_;
};
/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */


_ol_style_Stroke_.prototype.getLineDashOffset = function () {
  return this.lineDashOffset_;
};
/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */


_ol_style_Stroke_.prototype.getLineJoin = function () {
  return this.lineJoin_;
};
/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */


_ol_style_Stroke_.prototype.getMiterLimit = function () {
  return this.miterLimit_;
};
/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */


_ol_style_Stroke_.prototype.getWidth = function () {
  return this.width_;
};
/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */


_ol_style_Stroke_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};
/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */


_ol_style_Stroke_.prototype.setLineCap = function (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};
/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array.<number>} lineDash Line dash.
 * @api
 */


_ol_style_Stroke_.prototype.setLineDash = function (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};
/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */


_ol_style_Stroke_.prototype.setLineDashOffset = function (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};
/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */


_ol_style_Stroke_.prototype.setLineJoin = function (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};
/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */


_ol_style_Stroke_.prototype.setMiterLimit = function (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};
/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */


_ol_style_Stroke_.prototype.setWidth = function (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};
/**
 * @return {string} The checksum.
 */


_ol_style_Stroke_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';

    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += _index2.default.getUid(this.color_).toString();
      }
    } else {
      this.checksum_ += '-';
    }

    this.checksum_ += ',' + (this.lineCap_ !== undefined ? this.lineCap_.toString() : '-') + ',' + (this.lineDash_ ? this.lineDash_.toString() : '-') + ',' + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : '-') + ',' + (this.lineJoin_ !== undefined ? this.lineJoin_ : '-') + ',' + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : '-') + ',' + (this.width_ !== undefined ? this.width_.toString() : '-');
  }

  return this.checksum_;
};

exports.default = _ol_style_Stroke_;

},{"../index.js":90}],235:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _geometrytype = require("../geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _circle = require("../style/circle.js");

var _circle2 = _interopRequireDefault(_circle);

var _fill = require("../style/fill.js");

var _fill2 = _interopRequireDefault(_fill);

var _stroke = require("../style/stroke.js");

var _stroke2 = _interopRequireDefault(_stroke);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * @constructor
 * @struct
 * @param {olx.style.StyleOptions=} opt_options Style options.
 * @api
 */
var _ol_style_Style_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}
   */

  this.geometry_ = null;
  /**
   * @private
   * @type {!ol.StyleGeometryFunction}
   */

  this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }
  /**
   * @private
   * @type {ol.style.Fill}
   */


  this.fill_ = options.fill !== undefined ? options.fill : null;
  /**
   * @private
   * @type {ol.style.Image}
   */

  this.image_ = options.image !== undefined ? options.image : null;
  /**
   * @private
   * @type {ol.StyleRenderFunction|null}
   */

  this.renderer_ = options.renderer !== undefined ? options.renderer : null;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  /**
   * @private
   * @type {ol.style.Text}
   */

  this.text_ = options.text !== undefined ? options.text : null;
  /**
   * @private
   * @type {number|undefined}
   */

  this.zIndex_ = options.zIndex;
};
/**
 * Clones the style.
 * @return {ol.style.Style} The cloned style.
 * @api
 */


_ol_style_Style_.prototype.clone = function () {
  var geometry = this.getGeometry();

  if (geometry && geometry.clone) {
    geometry = geometry.clone();
  }

  return new _ol_style_Style_({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};
/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {ol.StyleRenderFunction|null} Custom renderer function.
 * @api
 */


_ol_style_Style_.prototype.getRenderer = function () {
  return this.renderer_;
};
/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {ol.StyleRenderFunction|null} renderer Custom renderer function.
 * @api
 */


_ol_style_Style_.prototype.setRenderer = function (renderer) {
  this.renderer_ = renderer;
};
/**
 * Get the geometry to be rendered.
 * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */


_ol_style_Style_.prototype.getGeometry = function () {
  return this.geometry_;
};
/**
 * Get the function used to generate a geometry for rendering.
 * @return {!ol.StyleGeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */


_ol_style_Style_.prototype.getGeometryFunction = function () {
  return this.geometryFunction_;
};
/**
 * Get the fill style.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_Style_.prototype.getFill = function () {
  return this.fill_;
};
/**
 * Set the fill style.
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */


_ol_style_Style_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};
/**
 * Get the image style.
 * @return {ol.style.Image} Image style.
 * @api
 */


_ol_style_Style_.prototype.getImage = function () {
  return this.image_;
};
/**
 * Set the image style.
 * @param {ol.style.Image} image Image style.
 * @api
 */


_ol_style_Style_.prototype.setImage = function (image) {
  this.image_ = image;
};
/**
 * Get the stroke style.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_Style_.prototype.getStroke = function () {
  return this.stroke_;
};
/**
 * Set the stroke style.
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */


_ol_style_Style_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};
/**
 * Get the text style.
 * @return {ol.style.Text} Text style.
 * @api
 */


_ol_style_Style_.prototype.getText = function () {
  return this.text_;
};
/**
 * Set the text style.
 * @param {ol.style.Text} text Text style.
 * @api
 */


_ol_style_Style_.prototype.setText = function (text) {
  this.text_ = text;
};
/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */


_ol_style_Style_.prototype.getZIndex = function () {
  return this.zIndex_;
};
/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry
 *     Feature property or geometry or function returning a geometry to render
 *     for this style.
 * @api
 */


_ol_style_Style_.prototype.setGeometry = function (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function (feature) {
      return (
        /** @type {ol.geom.Geometry} */
        feature.get(geometry)
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function () {
      return (
        /** @type {ol.geom.Geometry} */
        geometry
      );
    };
  }

  this.geometry_ = geometry;
};
/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */


_ol_style_Style_.prototype.setZIndex = function (zIndex) {
  this.zIndex_ = zIndex;
};
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a
 * new style function.
 * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {ol.StyleFunction} A style function.
 */


_ol_style_Style_.createFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;

    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      _asserts2.default.assert(obj instanceof _ol_style_Style_, 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`


      styles = [obj];
    }

    styleFunction = function () {
      return styles;
    };
  }

  return styleFunction;
};
/**
 * @type {Array.<ol.style.Style>}
 * @private
 */


_ol_style_Style_.default_ = null;
/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.style.Style>} Style.
 */

_ol_style_Style_.defaultFunction = function (feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (ol.style.Circle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!_ol_style_Style_.default_) {
    var fill = new _fill2.default({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _stroke2.default({
      color: '#3399CC',
      width: 1.25
    });
    _ol_style_Style_.default_ = [new _ol_style_Style_({
      image: new _circle2.default({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }

  return _ol_style_Style_.default_;
};
/**
 * Default styles for editing features.
 * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles
 */


_ol_style_Style_.createDefaultEditing = function () {
  /** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geometrytype2.default.POLYGON] = [new _ol_style_Style_({
    fill: new _fill2.default({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[_geometrytype2.default.MULTI_POLYGON] = styles[_geometrytype2.default.POLYGON];
  styles[_geometrytype2.default.LINE_STRING] = [new _ol_style_Style_({
    stroke: new _stroke2.default({
      color: white,
      width: width + 2
    })
  }), new _ol_style_Style_({
    stroke: new _stroke2.default({
      color: blue,
      width: width
    })
  })];
  styles[_geometrytype2.default.MULTI_LINE_STRING] = styles[_geometrytype2.default.LINE_STRING];
  styles[_geometrytype2.default.CIRCLE] = styles[_geometrytype2.default.POLYGON].concat(styles[_geometrytype2.default.LINE_STRING]);
  styles[_geometrytype2.default.POINT] = [new _ol_style_Style_({
    image: new _circle2.default({
      radius: width * 2,
      fill: new _fill2.default({
        color: blue
      }),
      stroke: new _stroke2.default({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[_geometrytype2.default.MULTI_POINT] = styles[_geometrytype2.default.POINT];
  styles[_geometrytype2.default.GEOMETRY_COLLECTION] = styles[_geometrytype2.default.POLYGON].concat(styles[_geometrytype2.default.LINE_STRING], styles[_geometrytype2.default.POINT]);
  return styles;
};
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry
 *     for.
 * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.
 */


_ol_style_Style_.defaultGeometryFunction = function (feature) {
  return feature.getGeometry();
};

exports.default = _ol_style_Style_;

},{"../asserts.js":32,"../geom/geometrytype.js":80,"../style/circle.js":225,"../style/fill.js":226,"../style/stroke.js":234}],236:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fill = require("../style/fill.js");

var _fill2 = _interopRequireDefault(_fill);

var _textplacement = require("../style/textplacement.js");

var _textplacement2 = _interopRequireDefault(_textplacement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Set text style for vector features.
 *
 * @constructor
 * @param {olx.style.TextOptions=} opt_options Options.
 * @api
 */
var _ol_style_Text_ = function (opt_options) {
  var options = opt_options || {};
  /**
   * @private
   * @type {string|undefined}
   */

  this.font_ = options.font;
  /**
   * @private
   * @type {number|undefined}
   */

  this.rotation_ = options.rotation;
  /**
   * @private
   * @type {boolean|undefined}
   */

  this.rotateWithView_ = options.rotateWithView;
  /**
   * @private
   * @type {number|undefined}
   */

  this.scale_ = options.scale;
  /**
   * @private
   * @type {string|undefined}
   */

  this.text_ = options.text;
  /**
   * @private
   * @type {string|undefined}
   */

  this.textAlign_ = options.textAlign;
  /**
   * @private
   * @type {string|undefined}
   */

  this.textBaseline_ = options.textBaseline;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.fill_ = options.fill !== undefined ? options.fill : new _fill2.default({
    color: _ol_style_Text_.DEFAULT_FILL_COLOR_
  });
  /**
   * @private
   * @type {number}
   */

  this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
  /**
   * @private
   * @type {ol.style.TextPlacement|string}
   */

  this.placement_ = options.placement !== undefined ? options.placement : _textplacement2.default.POINT; //TODO Use options.overflow directly after removing @deprecated exceedLength

  var overflow = options.overflow === undefined ? options.exceedLength : options.overflow;
  /**
   * @private
   * @type {boolean}
   */

  this.overflow_ = overflow !== undefined ? overflow : false;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  /**
   * @private
   * @type {number}
   */

  this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
  /**
   * @private
   * @type {number}
   */

  this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
  /**
   * @private
   * @type {ol.style.Fill}
   */

  this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
  /**
   * @private
   * @type {ol.style.Stroke}
   */

  this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
  /**
   * @private
   * @type {Array.<number>}
   */

  this.padding_ = options.padding === undefined ? null : options.padding;
};
/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 * @private
 */


_ol_style_Text_.DEFAULT_FILL_COLOR_ = '#333';
/**
 * Clones the style.
 * @return {ol.style.Text} The cloned style.
 * @api
 */

_ol_style_Text_.prototype.clone = function () {
  return new _ol_style_Text_({
    font: this.getFont(),
    placement: this.getPlacement(),
    maxAngle: this.getMaxAngle(),
    overflow: this.getOverflow(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    scale: this.getScale(),
    text: this.getText(),
    textAlign: this.getTextAlign(),
    textBaseline: this.getTextBaseline(),
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    offsetX: this.getOffsetX(),
    offsetY: this.getOffsetY()
  });
};
/**
 * Get the `overflow` configuration.
 * @return {boolean} Let text overflow the length of the path they follow.
 * @api
 */


_ol_style_Text_.prototype.getOverflow = function () {
  return this.overflow_;
};
/**
 * Get the font name.
 * @return {string|undefined} Font.
 * @api
 */


_ol_style_Text_.prototype.getFont = function () {
  return this.font_;
};
/**
 * Get the maximum angle between adjacent characters.
 * @return {number} Angle in radians.
 * @api
 */


_ol_style_Text_.prototype.getMaxAngle = function () {
  return this.maxAngle_;
};
/**
 * Get the label placement.
 * @return {ol.style.TextPlacement|string} Text placement.
 * @api
 */


_ol_style_Text_.prototype.getPlacement = function () {
  return this.placement_;
};
/**
 * Get the x-offset for the text.
 * @return {number} Horizontal text offset.
 * @api
 */


_ol_style_Text_.prototype.getOffsetX = function () {
  return this.offsetX_;
};
/**
 * Get the y-offset for the text.
 * @return {number} Vertical text offset.
 * @api
 */


_ol_style_Text_.prototype.getOffsetY = function () {
  return this.offsetY_;
};
/**
 * Get the fill style for the text.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_Text_.prototype.getFill = function () {
  return this.fill_;
};
/**
 * Determine whether the text rotates with the map.
 * @return {boolean|undefined} Rotate with map.
 * @api
 */


_ol_style_Text_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};
/**
 * Get the text rotation.
 * @return {number|undefined} Rotation.
 * @api
 */


_ol_style_Text_.prototype.getRotation = function () {
  return this.rotation_;
};
/**
 * Get the text scale.
 * @return {number|undefined} Scale.
 * @api
 */


_ol_style_Text_.prototype.getScale = function () {
  return this.scale_;
};
/**
 * Get the stroke style for the text.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_Text_.prototype.getStroke = function () {
  return this.stroke_;
};
/**
 * Get the text to be rendered.
 * @return {string|undefined} Text.
 * @api
 */


_ol_style_Text_.prototype.getText = function () {
  return this.text_;
};
/**
 * Get the text alignment.
 * @return {string|undefined} Text align.
 * @api
 */


_ol_style_Text_.prototype.getTextAlign = function () {
  return this.textAlign_;
};
/**
 * Get the text baseline.
 * @return {string|undefined} Text baseline.
 * @api
 */


_ol_style_Text_.prototype.getTextBaseline = function () {
  return this.textBaseline_;
};
/**
 * Get the background fill style for the text.
 * @return {ol.style.Fill} Fill style.
 * @api
 */


_ol_style_Text_.prototype.getBackgroundFill = function () {
  return this.backgroundFill_;
};
/**
 * Get the background stroke style for the text.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */


_ol_style_Text_.prototype.getBackgroundStroke = function () {
  return this.backgroundStroke_;
};
/**
 * Get the padding for the text.
 * @return {Array.<number>} Padding.
 * @api
 */


_ol_style_Text_.prototype.getPadding = function () {
  return this.padding_;
};
/**
 * Set the `overflow` property.
 *
 * @param {boolean} overflow Let text overflow the path that it follows.
 * @api
 */


_ol_style_Text_.prototype.setOverflow = function (overflow) {
  this.overflow_ = overflow;
};
/**
 * Set the font.
 *
 * @param {string|undefined} font Font.
 * @api
 */


_ol_style_Text_.prototype.setFont = function (font) {
  this.font_ = font;
};
/**
 * Set the maximum angle between adjacent characters.
 *
 * @param {number} maxAngle Angle in radians.
 * @api
 */


_ol_style_Text_.prototype.setMaxAngle = function (maxAngle) {
  this.maxAngle_ = maxAngle;
};
/**
 * Set the x offset.
 *
 * @param {number} offsetX Horizontal text offset.
 * @api
 */


_ol_style_Text_.prototype.setOffsetX = function (offsetX) {
  this.offsetX_ = offsetX;
};
/**
 * Set the y offset.
 *
 * @param {number} offsetY Vertical text offset.
 * @api
 */


_ol_style_Text_.prototype.setOffsetY = function (offsetY) {
  this.offsetY_ = offsetY;
};
/**
 * Set the text placement.
 *
 * @param {ol.style.TextPlacement|string} placement Placement.
 * @api
 */


_ol_style_Text_.prototype.setPlacement = function (placement) {
  this.placement_ = placement;
};
/**
 * Set the fill.
 *
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */


_ol_style_Text_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};
/**
 * Set the rotation.
 *
 * @param {number|undefined} rotation Rotation.
 * @api
 */


_ol_style_Text_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};
/**
 * Set the scale.
 *
 * @param {number|undefined} scale Scale.
 * @api
 */


_ol_style_Text_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};
/**
 * Set the stroke.
 *
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */


_ol_style_Text_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};
/**
 * Set the text.
 *
 * @param {string|undefined} text Text.
 * @api
 */


_ol_style_Text_.prototype.setText = function (text) {
  this.text_ = text;
};
/**
 * Set the text alignment.
 *
 * @param {string|undefined} textAlign Text align.
 * @api
 */


_ol_style_Text_.prototype.setTextAlign = function (textAlign) {
  this.textAlign_ = textAlign;
};
/**
 * Set the text baseline.
 *
 * @param {string|undefined} textBaseline Text baseline.
 * @api
 */


_ol_style_Text_.prototype.setTextBaseline = function (textBaseline) {
  this.textBaseline_ = textBaseline;
};
/**
 * Set the background fill.
 *
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */


_ol_style_Text_.prototype.setBackgroundFill = function (fill) {
  this.backgroundFill_ = fill;
};
/**
 * Set the background stroke.
 *
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */


_ol_style_Text_.prototype.setBackgroundStroke = function (stroke) {
  this.backgroundStroke_ = stroke;
};
/**
 * Set the padding (`[top, right, bottom, left]`).
 *
 * @param {!Array.<number>} padding Padding.
 * @api
 */


_ol_style_Text_.prototype.setPadding = function (padding) {
  this.padding_ = padding;
};

exports.default = _ol_style_Text_;

},{"../style/fill.js":226,"../style/textplacement.js":237}],237:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link ol.geom.LineString},
 * {@link ol.geom.Polygon}, {@link ol.geom.MultiLineString} or
 * {@link ol.geom.MultiPolygon}.
 * @enum {string}
 */
var _ol_style_TextPlacement_ = {
  POINT: 'point',
  LINE: 'line'
};
exports.default = _ol_style_TextPlacement_;

},{}],238:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_tilecoord_ = {};
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.TileCoord=} opt_tileCoord Tile coordinate.
 * @return {ol.TileCoord} Tile coordinate.
 */

_ol_tilecoord_.createOrUpdate = function (z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
};
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */


_ol_tilecoord_.getKeyZXY = function (z, x, y) {
  return z + '/' + x + '/' + y;
};
/**
 * Get the key for a tile coord.
 * @param {ol.TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */


_ol_tilecoord_.getKey = function (tileCoord) {
  return _ol_tilecoord_.getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
};
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {ol.TileCoord} The tile coord.
 */


_ol_tilecoord_.fromKey = function (key) {
  return key.split('/').map(Number);
};
/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */


_ol_tilecoord_.hash = function (tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
};
/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */


_ol_tilecoord_.quadKey = function (tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;

  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;

    if (tileCoord[1] & mask) {
      charCode += 1;
    }

    if (tileCoord[2] & mask) {
      charCode += 2;
    }

    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }

  return digits.join('');
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */


_ol_tilecoord_.withinExtentAndZ = function (tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }

  var extent = tileGrid.getExtent();
  var tileRange;

  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }

  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
};

exports.default = _ol_tilecoord_;

},{}],239:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _size = require("./size.js");

var _size2 = _interopRequireDefault(_size);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _corner = require("./extent/corner.js");

var _corner2 = _interopRequireDefault(_corner);

var _obj = require("./obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _proj = require("./proj.js");

var _proj2 = _interopRequireDefault(_proj);

var _units = require("./proj/units.js");

var _units2 = _interopRequireDefault(_units);

var _tilegrid = require("./tilegrid/tilegrid.js");

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_tilegrid_ = {};
/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Default tile grid for the passed projection.
 */

_ol_tilegrid_.getForProjection = function (projection) {
  var tileGrid = projection.getDefaultTileGrid();

  if (!tileGrid) {
    tileGrid = _ol_tilegrid_.createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }

  return tileGrid;
};
/**
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCoord} Tile coordinate.
 */


_ol_tilegrid_.wrapX = function (tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);

  var projectionExtent = _ol_tilegrid_.extentFromProjection(projection);

  if (!_extent2.default.containsCoordinate(projectionExtent, center)) {
    var worldWidth = _extent2.default.getWidth(projectionExtent);

    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
};
/**
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.TOP_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */


_ol_tilegrid_.createForExtent = function (extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _corner2.default.TOP_LEFT;

  var resolutions = _ol_tilegrid_.resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _tilegrid2.default({
    extent: extent,
    origin: _extent2.default.getCorner(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
};
/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {olx.tilegrid.XYZOptions=} opt_options Tile grid options.
 * @return {!ol.tilegrid.TileGrid} Tile grid instance.
 * @api
 */


_ol_tilegrid_.createXYZ = function (opt_options) {
  var options =
  /** @type {olx.tilegrid.TileGridOptions} */
  {};

  _obj2.default.assign(options, opt_options !== undefined ? opt_options :
  /** @type {olx.tilegrid.XYZOptions} */
  {});

  if (options.extent === undefined) {
    options.extent = _proj2.default.get('EPSG:3857').getExtent();
  }

  options.resolutions = _ol_tilegrid_.resolutionsFromExtent(options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;
  return new _tilegrid2.default(options);
};
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */


_ol_tilegrid_.resolutionsFromExtent = function (extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _index2.default.DEFAULT_MAX_ZOOM;

  var height = _extent2.default.getHeight(extent);

  var width = _extent2.default.getWidth(extent);

  var tileSize = _size2.default.toSize(opt_tileSize !== undefined ? opt_tileSize : _index2.default.DEFAULT_TILE_SIZE);

  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);

  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
};
/**
 * @param {ol.ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.BOTTOM_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */


_ol_tilegrid_.createForProjection = function (projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = _ol_tilegrid_.extentFromProjection(projection);

  return _ol_tilegrid_.createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
};
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {ol.ProjectionLike} projection Projection.
 * @return {ol.Extent} Extent.
 */


_ol_tilegrid_.extentFromProjection = function (projection) {
  projection = _proj2.default.get(projection);
  var extent = projection.getExtent();

  if (!extent) {
    var half = 180 * _proj2.default.METERS_PER_UNIT[_units2.default.DEGREES] / projection.getMetersPerUnit();
    extent = _extent2.default.createOrUpdate(-half, -half, half, half);
  }

  return extent;
};

exports.default = _ol_tilegrid_;

},{"./extent.js":55,"./extent/corner.js":56,"./index.js":90,"./obj.js":125,"./proj.js":142,"./proj/units.js":149,"./size.js":209,"./tilegrid/tilegrid.js":240}],240:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _asserts = require("../asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _tilerange = require("../tilerange.js");

var _tilerange2 = _interopRequireDefault(_tilerange);

var _array = require("../array.js");

var _array2 = _interopRequireDefault(_array);

var _extent = require("../extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _math = require("../math.js");

var _math2 = _interopRequireDefault(_math);

var _size = require("../size.js");

var _size2 = _interopRequireDefault(_size);

var _tilecoord = require("../tilecoord.js");

var _tilecoord2 = _interopRequireDefault(_tilecoord);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 *
 * @constructor
 * @param {olx.tilegrid.TileGridOptions} options Tile grid options.
 * @struct
 * @api
 */
var _ol_tilegrid_TileGrid_ = function (options) {
  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
  /**
   * @private
   * @type {!Array.<number>}
   */

  this.resolutions_ = options.resolutions;

  _asserts2.default.assert(_array2.default.isSorted(this.resolutions_, function (a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order
  // check if we've got a consistent zoom factor and origin


  var zoomFactor;

  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }
  /**
   * @private
   * @type {number|undefined}
   */


  this.zoomFactor_ = zoomFactor;
  /**
   * @protected
   * @type {number}
   */

  this.maxZoom = this.resolutions_.length - 1;
  /**
   * @private
   * @type {ol.Coordinate}
   */

  this.origin_ = options.origin !== undefined ? options.origin : null;
  /**
   * @private
   * @type {Array.<ol.Coordinate>}
   */

  this.origins_ = null;

  if (options.origins !== undefined) {
    this.origins_ = options.origins;

    _asserts2.default.assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal

  }

  var extent = options.extent;

  if (extent !== undefined && !this.origin_ && !this.origins_) {
    this.origin_ = _extent2.default.getTopLeft(extent);
  }

  _asserts2.default.assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array.<number|ol.Size>}
   */


  this.tileSizes_ = null;

  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;

    _asserts2.default.assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal

  }
  /**
   * @private
   * @type {number|ol.Size}
   */


  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _index2.default.DEFAULT_TILE_SIZE : null;

  _asserts2.default.assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {ol.Extent}
   */


  this.extent_ = extent !== undefined ? extent : null;
  /**
   * @private
   * @type {Array.<ol.TileRange>}
   */

  this.fullTileRanges_ = null;
  /**
   * @private
   * @type {ol.Size}
   */

  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function (size, z) {
      var tileRange = new _tilerange2.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }
};
/**
 * @private
 * @type {ol.TileCoord}
 */


_ol_tilegrid_TileGrid_.tmpTileCoord_ = [0, 0, 0];
/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.
 * @api
 */

_ol_tilegrid_TileGrid_.prototype.forEachTileCoord = function (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);

  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */


_ol_tilegrid_TileGrid_.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;

  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }

  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = _tilerange2.default.createOrUpdate(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }

    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }

    --z;
  }

  return false;
};
/**
 * Get the extent for this tile grid, if it was configured.
 * @return {ol.Extent} Extent.
 */


_ol_tilegrid_TileGrid_.prototype.getExtent = function () {
  return this.extent_;
};
/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getMaxZoom = function () {
  return this.maxZoom;
};
/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getMinZoom = function () {
  return this.minZoom;
};
/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {ol.Coordinate} Origin.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getOrigin = function (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};
/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getResolution = function (z) {
  return this.resolutions_[z];
};
/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getResolutions = function () {
  return this.resolutions_;
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.TileRange} Tile range.
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return _tilerange2.default.createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }

    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }

  return null;
};
/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.Extent} Extent.
 */


_ol_tilegrid_TileGrid_.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);

  var tileSize = _size2.default.toSize(this.getTileSize(z), this.tmpSize_);

  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return _extent2.default.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {ol.Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {ol.TileRange=} opt_tileRange Temporary tile range object.
 * @return {ol.TileRange} Tile range.
 */


_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
  var tileCoord = _ol_tilegrid_TileGrid_.tmpTileCoord_;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return _tilerange2.default.createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {ol.Coordinate} Tile center.
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordCenter = function (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);

  var tileSize = _size2.default.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);

  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];
};
/**
 * Get the extent of a tile coordinate.
 *
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Extent=} opt_extent Temporary extent object.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);

  var tileSize = _size2.default.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);

  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return _extent2.default.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};
/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);

  var tileSize = _size2.default.toSize(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return _tilecoord2.default.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};
/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.  This method is for integer zoom
 * levels.  The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);

  var tileSize = _size2.default.toSize(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return _tilecoord2.default.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};
/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */


_ol_tilegrid_TileGrid_.prototype.getTileCoordResolution = function (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};
/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `ol.Size`, run the result through `ol.size.toSize()`.
 * @param {number} z Z.
 * @return {number|ol.Size} Tile size.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getTileSize = function (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};
/**
 * @param {number} z Zoom level.
 * @return {ol.TileRange} Extent tile range for the specified zoom level.
 */


_ol_tilegrid_TileGrid_.prototype.getFullTileRange = function (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};
/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */


_ol_tilegrid_TileGrid_.prototype.getZForResolution = function (resolution, opt_direction) {
  var z = _array2.default.linearFindNearest(this.resolutions_, resolution, opt_direction || 0);

  return _math2.default.clamp(z, this.minZoom, this.maxZoom);
};
/**
 * @param {!ol.Extent} extent Extent for this tile grid.
 * @private
 */


_ol_tilegrid_TileGrid_.prototype.calculateTileRanges_ = function (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);

  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }

  this.fullTileRanges_ = fullTileRanges;
};

exports.default = _ol_tilegrid_TileGrid_;

},{"../array.js":30,"../asserts.js":32,"../extent.js":55,"../index.js":90,"../math.js":124,"../size.js":209,"../tilecoord.js":238,"../tilerange.js":242}],241:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _tilestate = require("./tilestate.js");

var _tilestate2 = _interopRequireDefault(_tilestate);

var _events = require("./events.js");

var _events2 = _interopRequireDefault(_events);

var _eventtype = require("./events/eventtype.js");

var _eventtype2 = _interopRequireDefault(_eventtype);

var _priorityqueue = require("./structs/priorityqueue.js");

var _priorityqueue2 = _interopRequireDefault(_priorityqueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.structs.PriorityQueue.<Array>}
 * @param {ol.TilePriorityFunction} tilePriorityFunction
 *     Tile priority function.
 * @param {function(): ?} tileChangeCallback
 *     Function called on each tile change event.
 * @struct
 */
var _ol_TileQueue_ = function (tilePriorityFunction, tileChangeCallback) {
  _priorityqueue2.default.call(this,
  /**
   * @param {Array} element Element.
   * @return {number} Priority.
   */
  function (element) {
    return tilePriorityFunction.apply(null, element);
  },
  /**
   * @param {Array} element Element.
   * @return {string} Key.
   */
  function (element) {
    return (
      /** @type {ol.Tile} */
      element[0].getKey()
    );
  });
  /**
   * @private
   * @type {function(): ?}
   */


  this.tileChangeCallback_ = tileChangeCallback;
  /**
   * @private
   * @type {number}
   */

  this.tilesLoading_ = 0;
  /**
   * @private
   * @type {!Object.<string,boolean>}
   */

  this.tilesLoadingKeys_ = {};
};

_index2.default.inherits(_ol_TileQueue_, _priorityqueue2.default);
/**
 * @inheritDoc
 */


_ol_TileQueue_.prototype.enqueue = function (element) {
  var added = _priorityqueue2.default.prototype.enqueue.call(this, element);

  if (added) {
    var tile = element[0];

    _events2.default.listen(tile, _eventtype2.default.CHANGE, this.handleTileChange, this);
  }

  return added;
};
/**
 * @return {number} Number of tiles loading.
 */


_ol_TileQueue_.prototype.getTilesLoading = function () {
  return this.tilesLoading_;
};
/**
 * @param {ol.events.Event} event Event.
 * @protected
 */


_ol_TileQueue_.prototype.handleTileChange = function (event) {
  var tile =
  /** @type {ol.Tile} */
  event.target;
  var state = tile.getState();

  if (state === _tilestate2.default.LOADED || state === _tilestate2.default.ERROR || state === _tilestate2.default.EMPTY || state === _tilestate2.default.ABORT) {
    _events2.default.unlisten(tile, _eventtype2.default.CHANGE, this.handleTileChange, this);

    var tileKey = tile.getKey();

    if (tileKey in this.tilesLoadingKeys_) {
      delete this.tilesLoadingKeys_[tileKey];
      --this.tilesLoading_;
    }

    this.tileChangeCallback_();
  }
};
/**
 * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
 * @param {number} maxNewLoads Maximum number of new tiles to load.
 */


_ol_TileQueue_.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
  var newLoads = 0;
  var abortedTiles = false;
  var state, tile, tileKey;

  while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
    tile =
    /** @type {ol.Tile} */
    this.dequeue()[0];
    tileKey = tile.getKey();
    state = tile.getState();

    if (state === _tilestate2.default.ABORT) {
      abortedTiles = true;
    } else if (state === _tilestate2.default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
      this.tilesLoadingKeys_[tileKey] = true;
      ++this.tilesLoading_;
      ++newLoads;
      tile.load();
    }
  }

  if (newLoads === 0 && abortedTiles) {
    // Do not stop the render loop when all wanted tiles were aborted due to
    // a small, saturated tile cache.
    this.tileChangeCallback_();
  }
};

exports.default = _ol_TileQueue_;

},{"./events.js":49,"./events/eventtype.js":53,"./index.js":90,"./structs/priorityqueue.js":220,"./tilestate.js":243}],242:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 *
 * @constructor
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @struct
 */
var _ol_TileRange_ = function (minX, maxX, minY, maxY) {
  /**
   * @type {number}
   */
  this.minX = minX;
  /**
   * @type {number}
   */

  this.maxX = maxX;
  /**
   * @type {number}
   */

  this.minY = minY;
  /**
   * @type {number}
   */

  this.maxY = maxY;
};
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {ol.TileRange|undefined} tileRange TileRange.
 * @return {ol.TileRange} Tile range.
 */


_ol_TileRange_.createOrUpdate = function (minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new _ol_TileRange_(minX, maxX, minY, maxY);
  }
};
/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */


_ol_TileRange_.prototype.contains = function (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */


_ol_TileRange_.prototype.containsTileRange = function (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};
/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */


_ol_TileRange_.prototype.containsXY = function (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */


_ol_TileRange_.prototype.equals = function (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 */


_ol_TileRange_.prototype.extend = function (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }

  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }

  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }

  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};
/**
 * @return {number} Height.
 */


_ol_TileRange_.prototype.getHeight = function () {
  return this.maxY - this.minY + 1;
};
/**
 * @return {ol.Size} Size.
 */


_ol_TileRange_.prototype.getSize = function () {
  return [this.getWidth(), this.getHeight()];
};
/**
 * @return {number} Width.
 */


_ol_TileRange_.prototype.getWidth = function () {
  return this.maxX - this.minX + 1;
};
/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */


_ol_TileRange_.prototype.intersects = function (tileRange) {
  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
};

exports.default = _ol_TileRange_;

},{}],243:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {number}
 */
var _ol_TileState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
};
exports.default = _ol_TileState_;

},{}],244:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require("./asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_transform_ = {};
/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3x3 martrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {ol.Transform}
 */

_ol_transform_.tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!ol.Transform} Identity transform.
 */

_ol_transform_.create = function () {
  return [1, 0, 0, 1, 0, 0];
};
/**
 * Resets the given transform to an identity transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Transform.
 */


_ol_transform_.reset = function (transform) {
  return _ol_transform_.set(transform, 1, 0, 0, 1, 0, 0);
};
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!ol.Transform} transform1 Transform parameters of matrix 1.
 * @param {!ol.Transform} transform2 Transform parameters of matrix 2.
 * @return {!ol.Transform} transform1 multiplied with transform2.
 */


_ol_transform_.multiply = function (transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
};
/**
 * Set the transform components a-f on a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!ol.Transform} Matrix with transform applied.
 */


_ol_transform_.set = function (transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
};
/**
 * Set transform on one matrix from another matrix.
 * @param {!ol.Transform} transform1 Matrix to set transform to.
 * @param {!ol.Transform} transform2 Matrix to set transform from.
 * @return {!ol.Transform} transform1 with transform from transform2 applied.
 */


_ol_transform_.setFromArray = function (transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
};
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {ol.Transform} transform The transformation.
 * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.
 * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be
 *     chained together.
 */


_ol_transform_.apply = function (transform, coordinate) {
  var x = coordinate[0],
      y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
};
/**
 * Applies rotation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!ol.Transform} The rotated transform.
 */


_ol_transform_.rotate = function (transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, cos, sin, -sin, cos, 0, 0));
};
/**
 * Applies scale to a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!ol.Transform} The scaled transform.
 */


_ol_transform_.scale = function (transform, x, y) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, x, 0, 0, y, 0, 0));
};
/**
 * Applies translation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!ol.Transform} The translated transform.
 */


_ol_transform_.translate = function (transform, dx, dy) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, 1, 0, 0, 1, dx, dy));
};
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!ol.Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!ol.Transform} The composite transform.
 */


_ol_transform_.compose = function (transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
};
/**
 * Invert the given transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Inverse of the transform.
 */


_ol_transform_.invert = function (transform) {
  var det = _ol_transform_.determinant(transform);

  _asserts2.default.assert(det !== 0, 32); // Transformation matrix cannot be inverted


  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];
  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;
  return transform;
};
/**
 * Returns the determinant of the given matrix.
 * @param {!ol.Transform} mat Matrix.
 * @return {number} Determinant.
 */


_ol_transform_.determinant = function (mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
};

exports.default = _ol_transform_;

},{"./asserts.js":32}],245:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_vec_Mat4_ = {};
/**
 * @return {Array.<number>} 4x4 matrix representing a 3D identity transform.
 */

_ol_vec_Mat4_.create = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};
/**
 * @param {Array.<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {ol.Transform} transform Transformation matrix.
 * @return {Array.<number>} 2D transformation matrix as flattened 4x4 matrix.
 */


_ol_vec_Mat4_.fromTransform = function (mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
};

exports.default = _ol_vec_Mat4_;

},{}],246:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("./index.js");

var _index2 = _interopRequireDefault(_index);

var _centerconstraint = require("./centerconstraint.js");

var _centerconstraint2 = _interopRequireDefault(_centerconstraint);

var _object = require("./object.js");

var _object2 = _interopRequireDefault(_object);

var _resolutionconstraint = require("./resolutionconstraint.js");

var _resolutionconstraint2 = _interopRequireDefault(_resolutionconstraint);

var _rotationconstraint = require("./rotationconstraint.js");

var _rotationconstraint2 = _interopRequireDefault(_rotationconstraint);

var _viewhint = require("./viewhint.js");

var _viewhint2 = _interopRequireDefault(_viewhint);

var _viewproperty = require("./viewproperty.js");

var _viewproperty2 = _interopRequireDefault(_viewproperty);

var _array = require("./array.js");

var _array2 = _interopRequireDefault(_array);

var _asserts = require("./asserts.js");

var _asserts2 = _interopRequireDefault(_asserts);

var _coordinate = require("./coordinate.js");

var _coordinate2 = _interopRequireDefault(_coordinate);

var _easing = require("./easing.js");

var _easing2 = _interopRequireDefault(_easing);

var _extent = require("./extent.js");

var _extent2 = _interopRequireDefault(_extent);

var _geometrytype = require("./geom/geometrytype.js");

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _polygon = require("./geom/polygon.js");

var _polygon2 = _interopRequireDefault(_polygon);

var _simplegeometry = require("./geom/simplegeometry.js");

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _math = require("./math.js");

var _math2 = _interopRequireDefault(_math);

var _obj = require("./obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _proj = require("./proj.js");

var _proj2 = _interopRequireDefault(_proj);

var _units = require("./proj/units.js");

var _units2 = _interopRequireDefault(_units);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * An ol.View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An `ol.View` is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An `ol.View` has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But an `ol.View` object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.ViewOptions=} opt_options View options.
 * @api
 */
var _ol_View_ = function (opt_options) {
  _object2.default.call(this);

  var options = _obj2.default.assign({}, opt_options);
  /**
   * @private
   * @type {Array.<number>}
   */


  this.hints_ = [0, 0];
  /**
   * @private
   * @type {Array.<Array.<ol.ViewAnimation>>}
   */

  this.animations_ = [];
  /**
   * @private
   * @type {number|undefined}
   */

  this.updateAnimationKey_;
  this.updateAnimations_ = this.updateAnimations_.bind(this);
  /**
   * @private
   * @const
   * @type {ol.proj.Projection}
   */

  this.projection_ = _proj2.default.createProjection(options.projection, 'EPSG:3857');
  this.applyOptions_(options);
};

_index2.default.inherits(_ol_View_, _object2.default);
/**
 * Set up the view with the given options.
 * @param {olx.ViewOptions} options View options.
 */


_ol_View_.prototype.applyOptions_ = function (options) {
  /**
   * @type {Object.<string, *>}
   */
  var properties = {};
  properties[_viewproperty2.default.CENTER] = options.center !== undefined ? options.center : null;

  var resolutionConstraintInfo = _ol_View_.createResolutionConstraint_(options);
  /**
   * @private
   * @type {number}
   */


  this.maxResolution_ = resolutionConstraintInfo.maxResolution;
  /**
   * @private
   * @type {number}
   */

  this.minResolution_ = resolutionConstraintInfo.minResolution;
  /**
   * @private
   * @type {number}
   */

  this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
  /**
   * @private
   * @type {Array.<number>|undefined}
   */

  this.resolutions_ = options.resolutions;
  /**
   * @private
   * @type {number}
   */

  this.minZoom_ = resolutionConstraintInfo.minZoom;

  var centerConstraint = _ol_View_.createCenterConstraint_(options);

  var resolutionConstraint = resolutionConstraintInfo.constraint;

  var rotationConstraint = _ol_View_.createRotationConstraint_(options);
  /**
   * @private
   * @type {ol.Constraints}
   */


  this.constraints_ = {
    center: centerConstraint,
    resolution: resolutionConstraint,
    rotation: rotationConstraint
  };

  if (options.resolution !== undefined) {
    properties[_viewproperty2.default.RESOLUTION] = options.resolution;
  } else if (options.zoom !== undefined) {
    properties[_viewproperty2.default.RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);

    if (this.resolutions_) {
      // in case map zoom is out of min/max zoom range
      properties[_viewproperty2.default.RESOLUTION] = _math2.default.clamp(Number(this.getResolution() || properties[_viewproperty2.default.RESOLUTION]), this.minResolution_, this.maxResolution_);
    }
  }

  properties[_viewproperty2.default.ROTATION] = options.rotation !== undefined ? options.rotation : 0;
  this.setProperties(properties);
  /**
   * @private
   * @type {olx.ViewOptions}
   */

  this.options_ = options;
};
/**
 * Get an updated version of the view options used to construct the view.  The
 * current resolution (or zoom), center, and rotation are applied to any stored
 * options.  The provided options can be uesd to apply new min/max zoom or
 * resolution limits.
 * @param {olx.ViewOptions} newOptions New options to be applied.
 * @return {olx.ViewOptions} New options updated with the current view state.
 */


_ol_View_.prototype.getUpdatedOptions_ = function (newOptions) {
  var options = _obj2.default.assign({}, this.options_); // preserve resolution (or zoom)


  if (options.resolution !== undefined) {
    options.resolution = this.getResolution();
  } else {
    options.zoom = this.getZoom();
  } // preserve center


  options.center = this.getCenter(); // preserve rotation

  options.rotation = this.getRotation();
  return _obj2.default.assign({}, options, newOptions);
};
/**
 * Animate the view.  The view's center, zoom (or resolution), and rotation
 * can be animated for smooth transitions between view states.  For example,
 * to animate the view to a new zoom level:
 *
 *     view.animate({zoom: view.getZoom() + 1});
 *
 * By default, the animation lasts one second and uses in-and-out easing.  You
 * can customize this behavior by including `duration` (in milliseconds) and
 * `easing` options (see {@link ol.easing}).
 *
 * To chain together multiple animations, call the method with multiple
 * animation objects.  For example, to first zoom and then pan:
 *
 *     view.animate({zoom: 10}, {center: [0, 0]});
 *
 * If you provide a function as the last argument to the animate method, it
 * will get called at the end of an animation series.  The callback will be
 * called with `true` if the animation series completed on its own or `false`
 * if it was cancelled.
 *
 * Animations are cancelled by user interactions (e.g. dragging the map) or by
 * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
 * (or another method that calls one of these).
 *
 * @param {...(olx.AnimationOptions|function(boolean))} var_args Animation
 *     options.  Multiple animations can be run in series by passing multiple
 *     options objects.  To run multiple animations in parallel, call the method
 *     multiple times.  An optional callback can be provided as a final
 *     argument.  The callback will be called with a boolean indicating whether
 *     the animation completed without being cancelled.
 * @api
 */


_ol_View_.prototype.animate = function (var_args) {
  var animationCount = arguments.length;
  var callback;

  if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
    callback = arguments[animationCount - 1];
    --animationCount;
  }

  if (!this.isDef()) {
    // if view properties are not yet set, shortcut to the final state
    var state = arguments[animationCount - 1];

    if (state.center) {
      this.setCenter(state.center);
    }

    if (state.zoom !== undefined) {
      this.setZoom(state.zoom);
    }

    if (state.rotation !== undefined) {
      this.setRotation(state.rotation);
    }

    if (callback) {
      callback(true);
    }

    return;
  }

  var start = Date.now();
  var center = this.getCenter().slice();
  var resolution = this.getResolution();
  var rotation = this.getRotation();
  var series = [];

  for (var i = 0; i < animationCount; ++i) {
    var options =
    /** @type {olx.AnimationOptions} */
    arguments[i];
    var animation =
    /** @type {ol.ViewAnimation} */
    {
      start: start,
      complete: false,
      anchor: options.anchor,
      duration: options.duration !== undefined ? options.duration : 1000,
      easing: options.easing || _easing2.default.inAndOut
    };

    if (options.center) {
      animation.sourceCenter = center;
      animation.targetCenter = options.center;
      center = animation.targetCenter;
    }

    if (options.zoom !== undefined) {
      animation.sourceResolution = resolution;
      animation.targetResolution = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_, 0);
      resolution = animation.targetResolution;
    } else if (options.resolution) {
      animation.sourceResolution = resolution;
      animation.targetResolution = options.resolution;
      resolution = animation.targetResolution;
    }

    if (options.rotation !== undefined) {
      animation.sourceRotation = rotation;
      var delta = _math2.default.modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
      animation.targetRotation = rotation + delta;
      rotation = animation.targetRotation;
    }

    animation.callback = callback; // check if animation is a no-op

    if (_ol_View_.isNoopAnimation(animation)) {
      animation.complete = true; // we still push it onto the series for callback handling
    } else {
      start += animation.duration;
    }

    series.push(animation);
  }

  this.animations_.push(series);
  this.setHint(_viewhint2.default.ANIMATING, 1);
  this.updateAnimations_();
};
/**
 * Determine if the view is being animated.
 * @return {boolean} The view is being animated.
 * @api
 */


_ol_View_.prototype.getAnimating = function () {
  return this.hints_[_viewhint2.default.ANIMATING] > 0;
};
/**
 * Determine if the user is interacting with the view, such as panning or zooming.
 * @return {boolean} The view is being interacted with.
 * @api
 */


_ol_View_.prototype.getInteracting = function () {
  return this.hints_[_viewhint2.default.INTERACTING] > 0;
};
/**
 * Cancel any ongoing animations.
 * @api
 */


_ol_View_.prototype.cancelAnimations = function () {
  this.setHint(_viewhint2.default.ANIMATING, -this.hints_[_viewhint2.default.ANIMATING]);

  for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
    var series = this.animations_[i];

    if (series[0].callback) {
      series[0].callback(false);
    }
  }

  this.animations_.length = 0;
};
/**
 * Update all animations.
 */


_ol_View_.prototype.updateAnimations_ = function () {
  if (this.updateAnimationKey_ !== undefined) {
    cancelAnimationFrame(this.updateAnimationKey_);
    this.updateAnimationKey_ = undefined;
  }

  if (!this.getAnimating()) {
    return;
  }

  var now = Date.now();
  var more = false;

  for (var i = this.animations_.length - 1; i >= 0; --i) {
    var series = this.animations_[i];
    var seriesComplete = true;

    for (var j = 0, jj = series.length; j < jj; ++j) {
      var animation = series[j];

      if (animation.complete) {
        continue;
      }

      var elapsed = now - animation.start;
      var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;

      if (fraction >= 1) {
        animation.complete = true;
        fraction = 1;
      } else {
        seriesComplete = false;
      }

      var progress = animation.easing(fraction);

      if (animation.sourceCenter) {
        var x0 = animation.sourceCenter[0];
        var y0 = animation.sourceCenter[1];
        var x1 = animation.targetCenter[0];
        var y1 = animation.targetCenter[1];
        var x = x0 + progress * (x1 - x0);
        var y = y0 + progress * (y1 - y0);
        this.set(_viewproperty2.default.CENTER, [x, y]);
      }

      if (animation.sourceResolution && animation.targetResolution) {
        var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);

        if (animation.anchor) {
          this.set(_viewproperty2.default.CENTER, this.calculateCenterZoom(resolution, animation.anchor));
        }

        this.set(_viewproperty2.default.RESOLUTION, resolution);
      }

      if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
        var rotation = progress === 1 ? _math2.default.modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);

        if (animation.anchor) {
          this.set(_viewproperty2.default.CENTER, this.calculateCenterRotate(rotation, animation.anchor));
        }

        this.set(_viewproperty2.default.ROTATION, rotation);
      }

      more = true;

      if (!animation.complete) {
        break;
      }
    }

    if (seriesComplete) {
      this.animations_[i] = null;
      this.setHint(_viewhint2.default.ANIMATING, -1);
      var callback = series[0].callback;

      if (callback) {
        callback(true);
      }
    }
  } // prune completed series


  this.animations_ = this.animations_.filter(Boolean);

  if (more && this.updateAnimationKey_ === undefined) {
    this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
  }
};
/**
 * @param {number} rotation Target rotation.
 * @param {ol.Coordinate} anchor Rotation anchor.
 * @return {ol.Coordinate|undefined} Center for rotation and anchor.
 */


_ol_View_.prototype.calculateCenterRotate = function (rotation, anchor) {
  var center;
  var currentCenter = this.getCenter();

  if (currentCenter !== undefined) {
    center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];

    _coordinate2.default.rotate(center, rotation - this.getRotation());

    _coordinate2.default.add(center, anchor);
  }

  return center;
};
/**
 * @param {number} resolution Target resolution.
 * @param {ol.Coordinate} anchor Zoom anchor.
 * @return {ol.Coordinate|undefined} Center for resolution and anchor.
 */


_ol_View_.prototype.calculateCenterZoom = function (resolution, anchor) {
  var center;
  var currentCenter = this.getCenter();
  var currentResolution = this.getResolution();

  if (currentCenter !== undefined && currentResolution !== undefined) {
    var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
    var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
    center = [x, y];
  }

  return center;
};
/**
 * @private
 * @return {ol.Size} Viewport size or `[100, 100]` when no viewport is found.
 */


_ol_View_.prototype.getSizeFromViewport_ = function () {
  var size = [100, 100];
  var selector = '.ol-viewport[data-view="' + _index2.default.getUid(this) + '"]';
  var element = document.querySelector(selector);

  if (element) {
    var metrics = getComputedStyle(element);
    size[0] = parseInt(metrics.width, 10);
    size[1] = parseInt(metrics.height, 10);
  }

  return size;
};
/**
 * Get the constrained center of this view.
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Constrained center.
 * @api
 */


_ol_View_.prototype.constrainCenter = function (center) {
  return this.constraints_.center(center);
};
/**
 * Get the constrained resolution of this view.
 * @param {number|undefined} resolution Resolution.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @param {number=} opt_direction Direction. Default is `0`.
 * @return {number|undefined} Constrained resolution.
 * @api
 */


_ol_View_.prototype.constrainResolution = function (resolution, opt_delta, opt_direction) {
  var delta = opt_delta || 0;
  var direction = opt_direction || 0;
  return this.constraints_.resolution(resolution, delta, direction);
};
/**
 * Get the constrained rotation of this view.
 * @param {number|undefined} rotation Rotation.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @return {number|undefined} Constrained rotation.
 * @api
 */


_ol_View_.prototype.constrainRotation = function (rotation, opt_delta) {
  var delta = opt_delta || 0;
  return this.constraints_.rotation(rotation, delta);
};
/**
 * Get the view center.
 * @return {ol.Coordinate|undefined} The center of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.getCenter = function () {
  return (
    /** @type {ol.Coordinate|undefined} */
    this.get(_viewproperty2.default.CENTER)
  );
};
/**
 * @return {ol.Constraints} Constraints.
 */


_ol_View_.prototype.getConstraints = function () {
  return this.constraints_;
};
/**
 * @param {Array.<number>=} opt_hints Destination array.
 * @return {Array.<number>} Hint.
 */


_ol_View_.prototype.getHints = function (opt_hints) {
  if (opt_hints !== undefined) {
    opt_hints[0] = this.hints_[0];
    opt_hints[1] = this.hints_[1];
    return opt_hints;
  } else {
    return this.hints_.slice();
  }
};
/**
 * Calculate the extent for the current view state and the passed size.
 * The size is the pixel dimensions of the box into which the calculated extent
 * should fit. In most cases you want to get the extent of the entire map,
 * that is `map.getSize()`.
 * @param {ol.Size=} opt_size Box pixel size. If not provided, the size of the
 * first map that uses this view will be used.
 * @return {ol.Extent} Extent.
 * @api
 */


_ol_View_.prototype.calculateExtent = function (opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var center =
  /** @type {!ol.Coordinate} */
  this.getCenter();

  _asserts2.default.assert(center, 1); // The view center is not defined


  var resolution =
  /** @type {!number} */
  this.getResolution();

  _asserts2.default.assert(resolution !== undefined, 2); // The view resolution is not defined


  var rotation =
  /** @type {!number} */
  this.getRotation();

  _asserts2.default.assert(rotation !== undefined, 3); // The view rotation is not defined


  return _extent2.default.getForViewAndSize(center, resolution, rotation, size);
};
/**
 * Get the maximum resolution of the view.
 * @return {number} The maximum resolution of the view.
 * @api
 */


_ol_View_.prototype.getMaxResolution = function () {
  return this.maxResolution_;
};
/**
 * Get the minimum resolution of the view.
 * @return {number} The minimum resolution of the view.
 * @api
 */


_ol_View_.prototype.getMinResolution = function () {
  return this.minResolution_;
};
/**
 * Get the maximum zoom level for the view.
 * @return {number} The maximum zoom level.
 * @api
 */


_ol_View_.prototype.getMaxZoom = function () {
  return (
    /** @type {number} */
    this.getZoomForResolution(this.minResolution_)
  );
};
/**
 * Set a new maximum zoom level for the view.
 * @param {number} zoom The maximum zoom level.
 * @api
 */


_ol_View_.prototype.setMaxZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({
    maxZoom: zoom
  }));
};
/**
 * Get the minimum zoom level for the view.
 * @return {number} The minimum zoom level.
 * @api
 */


_ol_View_.prototype.getMinZoom = function () {
  return (
    /** @type {number} */
    this.getZoomForResolution(this.maxResolution_)
  );
};
/**
 * Set a new minimum zoom level for the view.
 * @param {number} zoom The minimum zoom level.
 * @api
 */


_ol_View_.prototype.setMinZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({
    minZoom: zoom
  }));
};
/**
 * Get the view projection.
 * @return {ol.proj.Projection} The projection of the view.
 * @api
 */


_ol_View_.prototype.getProjection = function () {
  return this.projection_;
};
/**
 * Get the view resolution.
 * @return {number|undefined} The resolution of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.getResolution = function () {
  return (
    /** @type {number|undefined} */
    this.get(_viewproperty2.default.RESOLUTION)
  );
};
/**
 * Get the resolutions for the view. This returns the array of resolutions
 * passed to the constructor of the {ol.View}, or undefined if none were given.
 * @return {Array.<number>|undefined} The resolutions of the view.
 * @api
 */


_ol_View_.prototype.getResolutions = function () {
  return this.resolutions_;
};
/**
 * Get the resolution for a provided extent (in map units) and size (in pixels).
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size=} opt_size Box pixel size.
 * @return {number} The resolution at which the provided extent will render at
 *     the given size.
 * @api
 */


_ol_View_.prototype.getResolutionForExtent = function (extent, opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var xResolution = _extent2.default.getWidth(extent) / size[0];
  var yResolution = _extent2.default.getHeight(extent) / size[1];
  return Math.max(xResolution, yResolution);
};
/**
 * Return a function that returns a value between 0 and 1 for a
 * resolution. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Resolution for value function.
 */


_ol_View_.prototype.getResolutionForValueFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} value Value.
     * @return {number} Resolution.
     */
    function (value) {
      var resolution = maxResolution / Math.pow(power, value * max);
      return resolution;
    }
  );
};
/**
 * Get the view rotation.
 * @return {number} The rotation of the view in radians.
 * @observable
 * @api
 */


_ol_View_.prototype.getRotation = function () {
  return (
    /** @type {number} */
    this.get(_viewproperty2.default.ROTATION)
  );
};
/**
 * Return a function that returns a resolution for a value between
 * 0 and 1. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Value for resolution function.
 */


_ol_View_.prototype.getValueForResolutionFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} resolution Resolution.
     * @return {number} Value.
     */
    function (resolution) {
      var value = Math.log(maxResolution / resolution) / Math.log(power) / max;
      return value;
    }
  );
};
/**
 * @return {olx.ViewState} View state.
 */


_ol_View_.prototype.getState = function () {
  var center =
  /** @type {ol.Coordinate} */
  this.getCenter();
  var projection = this.getProjection();
  var resolution =
  /** @type {number} */
  this.getResolution();
  var rotation = this.getRotation();
  return (
    /** @type {olx.ViewState} */
    {
      center: center.slice(),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      rotation: rotation,
      zoom: this.getZoom()
    }
  );
};
/**
 * Get the current zoom level.  If you configured your view with a resolutions
 * array (this is rare), this method may return non-integer zoom levels (so
 * the zoom level is not safe to use as an index into a resolutions array).
 * @return {number|undefined} Zoom.
 * @api
 */


_ol_View_.prototype.getZoom = function () {
  var zoom;
  var resolution = this.getResolution();

  if (resolution !== undefined) {
    zoom = this.getZoomForResolution(resolution);
  }

  return zoom;
};
/**
 * Get the zoom level for a resolution.
 * @param {number} resolution The resolution.
 * @return {number|undefined} The zoom level for the provided resolution.
 * @api
 */


_ol_View_.prototype.getZoomForResolution = function (resolution) {
  var offset = this.minZoom_ || 0;
  var max, zoomFactor;

  if (this.resolutions_) {
    var nearest = _array2.default.linearFindNearest(this.resolutions_, resolution, 1);

    offset = nearest;
    max = this.resolutions_[nearest];

    if (nearest == this.resolutions_.length - 1) {
      zoomFactor = 2;
    } else {
      zoomFactor = max / this.resolutions_[nearest + 1];
    }
  } else {
    max = this.maxResolution_;
    zoomFactor = this.zoomFactor_;
  }

  return offset + Math.log(max / resolution) / Math.log(zoomFactor);
};
/**
 * Get the resolution for a zoom level.
 * @param {number} zoom Zoom level.
 * @return {number} The view resolution for the provided zoom level.
 * @api
 */


_ol_View_.prototype.getResolutionForZoom = function (zoom) {
  return (
    /** @type {number} */
    this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0)
  );
};
/**
 * Fit the given geometry or extent based on the given map size and border.
 * The size is pixel dimensions of the box to fit the extent into.
 * In most cases you will want to use the map size, that is `map.getSize()`.
 * Takes care of the map angle.
 * @param {ol.geom.SimpleGeometry|ol.Extent} geometryOrExtent The geometry or
 *     extent to fit the view to.
 * @param {olx.view.FitOptions=} opt_options Options.
 * @api
 */


_ol_View_.prototype.fit = function (geometryOrExtent, opt_options) {
  var options = opt_options || {};
  var size = options.size;

  if (!size) {
    size = this.getSizeFromViewport_();
  }
  /** @type {ol.geom.SimpleGeometry} */


  var geometry;

  if (!(geometryOrExtent instanceof _simplegeometry2.default)) {
    _asserts2.default.assert(Array.isArray(geometryOrExtent), 24); // Invalid extent or geometry provided as `geometry`


    _asserts2.default.assert(!_extent2.default.isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`


    geometry = _polygon2.default.fromExtent(geometryOrExtent);
  } else if (geometryOrExtent.getType() === _geometrytype2.default.CIRCLE) {
    geometryOrExtent = geometryOrExtent.getExtent();
    geometry = _polygon2.default.fromExtent(geometryOrExtent);
    geometry.rotate(this.getRotation(), _extent2.default.getCenter(geometryOrExtent));
  } else {
    geometry = geometryOrExtent;
  }

  var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
  var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;
  var nearest = options.nearest !== undefined ? options.nearest : false;
  var minResolution;

  if (options.minResolution !== undefined) {
    minResolution = options.minResolution;
  } else if (options.maxZoom !== undefined) {
    minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);
  } else {
    minResolution = 0;
  }

  var coords = geometry.getFlatCoordinates(); // calculate rotated extent

  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var minRotX = +Infinity;
  var minRotY = +Infinity;
  var maxRotX = -Infinity;
  var maxRotY = -Infinity;
  var stride = geometry.getStride();

  for (var i = 0, ii = coords.length; i < ii; i += stride) {
    var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
    var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
    minRotX = Math.min(minRotX, rotX);
    minRotY = Math.min(minRotY, rotY);
    maxRotX = Math.max(maxRotX, rotX);
    maxRotY = Math.max(maxRotY, rotY);
  } // calculate resolution


  var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
  resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);

  if (constrainResolution) {
    var constrainedResolution = this.constrainResolution(resolution, 0, 0);

    if (!nearest && constrainedResolution < resolution) {
      constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);
    }

    resolution = constrainedResolution;
  } // calculate center


  sinAngle = -sinAngle; // go back to original rotation

  var centerRotX = (minRotX + maxRotX) / 2;
  var centerRotY = (minRotY + maxRotY) / 2;
  centerRotX += (padding[1] - padding[3]) / 2 * resolution;
  centerRotY += (padding[0] - padding[2]) / 2 * resolution;
  var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
  var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
  var center = [centerX, centerY];
  var callback = options.callback ? options.callback : _index2.default.nullFunction;

  if (options.duration !== undefined) {
    this.animate({
      resolution: resolution,
      center: center,
      duration: options.duration,
      easing: options.easing
    }, callback);
  } else {
    this.setResolution(resolution);
    this.setCenter(center);
    setTimeout(callback.bind(undefined, true), 0);
  }
};
/**
 * Center on coordinate and view position.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Size} size Box pixel size.
 * @param {ol.Pixel} position Position on the view to center on.
 * @api
 */


_ol_View_.prototype.centerOn = function (coordinate, size, position) {
  // calculate rotated position
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  var resolution = this.getResolution();
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle

  sinAngle = -sinAngle; // go back to original rotation

  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  this.setCenter([centerX, centerY]);
};
/**
 * @return {boolean} Is defined.
 */


_ol_View_.prototype.isDef = function () {
  return !!this.getCenter() && this.getResolution() !== undefined;
};
/**
 * Rotate the view around a given coordinate.
 * @param {number} rotation New rotation value for the view.
 * @param {ol.Coordinate=} opt_anchor The rotation center.
 * @api
 */


_ol_View_.prototype.rotate = function (rotation, opt_anchor) {
  if (opt_anchor !== undefined) {
    var center = this.calculateCenterRotate(rotation, opt_anchor);
    this.setCenter(center);
  }

  this.setRotation(rotation);
};
/**
 * Set the center of the current view.
 * @param {ol.Coordinate|undefined} center The center of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.setCenter = function (center) {
  this.set(_viewproperty2.default.CENTER, center);

  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
/**
 * @param {ol.ViewHint} hint Hint.
 * @param {number} delta Delta.
 * @return {number} New value.
 */


_ol_View_.prototype.setHint = function (hint, delta) {
  this.hints_[hint] += delta;
  this.changed();
  return this.hints_[hint];
};
/**
 * Set the resolution for this view.
 * @param {number|undefined} resolution The resolution of the view.
 * @observable
 * @api
 */


_ol_View_.prototype.setResolution = function (resolution) {
  this.set(_viewproperty2.default.RESOLUTION, resolution);

  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
/**
 * Set the rotation for this view.
 * @param {number} rotation The rotation of the view in radians.
 * @observable
 * @api
 */


_ol_View_.prototype.setRotation = function (rotation) {
  this.set(_viewproperty2.default.ROTATION, rotation);

  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
/**
 * Zoom to a specific zoom level.
 * @param {number} zoom Zoom level.
 * @api
 */


_ol_View_.prototype.setZoom = function (zoom) {
  this.setResolution(this.getResolutionForZoom(zoom));
};
/**
 * @param {olx.ViewOptions} options View options.
 * @private
 * @return {ol.CenterConstraintType} The constraint.
 */


_ol_View_.createCenterConstraint_ = function (options) {
  if (options.extent !== undefined) {
    return _centerconstraint2.default.createExtent(options.extent);
  } else {
    return _centerconstraint2.default.none;
  }
};
/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {{constraint: ol.ResolutionConstraintType, maxResolution: number,
 *     minResolution: number, zoomFactor: number}} The constraint.
 */


_ol_View_.createResolutionConstraint_ = function (options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution; // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076

  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : _index2.default.DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    resolutionConstraint = _resolutionconstraint2.default.createSnapToResolutions(resolutions);
  } else {
    // calculate the default min and max resolution
    var projection = _proj2.default.createProjection(options.projection, 'EPSG:3857');

    var extent = projection.getExtent();
    var size = !extent ? // use an extent that can fit the whole world if need be
    360 * _proj2.default.METERS_PER_UNIT[_units2.default.DEGREES] / projection.getMetersPerUnit() : Math.max(_extent2.default.getWidth(extent), _extent2.default.getHeight(extent));
    var defaultMaxResolution = size / _index2.default.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, _index2.default.DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - _index2.default.DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence

    maxResolution = options.maxResolution;

    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    } // user provided minResolution takes precedence


    minResolution = options.minResolution;

    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    } // given discrete zoom levels, minResolution may be different than provided


    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    resolutionConstraint = _resolutionconstraint2.default.createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);
  }

  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor
  };
};
/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */


_ol_View_.createRotationConstraint_ = function (options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;

  if (enableRotation) {
    var constrainRotation = options.constrainRotation;

    if (constrainRotation === undefined || constrainRotation === true) {
      return _rotationconstraint2.default.createSnapToZero();
    } else if (constrainRotation === false) {
      return _rotationconstraint2.default.none;
    } else if (typeof constrainRotation === 'number') {
      return _rotationconstraint2.default.createSnapToN(constrainRotation);
    } else {
      return _rotationconstraint2.default.none;
    }
  } else {
    return _rotationconstraint2.default.disable;
  }
};
/**
 * Determine if an animation involves no view change.
 * @param {ol.ViewAnimation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */


_ol_View_.isNoopAnimation = function (animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!_coordinate2.default.equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }

  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }

  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }

  return true;
};

exports.default = _ol_View_;

},{"./array.js":30,"./asserts.js":32,"./centerconstraint.js":34,"./coordinate.js":44,"./easing.js":48,"./extent.js":55,"./geom/geometrytype.js":80,"./geom/polygon.js":83,"./geom/simplegeometry.js":84,"./index.js":90,"./math.js":124,"./obj.js":125,"./object.js":126,"./proj.js":142,"./proj/units.js":149,"./resolutionconstraint.js":207,"./rotationconstraint.js":208,"./viewhint.js":247,"./viewproperty.js":248}],247:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {number}
 */
var _ol_ViewHint_ = {
  ANIMATING: 0,
  INTERACTING: 1
};
exports.default = _ol_ViewHint_;

},{}],248:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_ViewProperty_ = {
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
};
exports.default = _ol_ViewProperty_;

},{}],249:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_webgl_ = {};
/**
 * Constants taken from goog.webgl
 */

/**
 * @const
 * @type {number}
 */

_ol_webgl_.ONE = 1;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.SRC_ALPHA = 0x0302;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.COLOR_ATTACHMENT0 = 0x8CE0;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.COLOR_BUFFER_BIT = 0x00004000;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TRIANGLES = 0x0004;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TRIANGLE_STRIP = 0x0005;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.ONE_MINUS_SRC_ALPHA = 0x0303;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.ARRAY_BUFFER = 0x8892;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.ELEMENT_ARRAY_BUFFER = 0x8893;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.STREAM_DRAW = 0x88E0;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.STATIC_DRAW = 0x88E4;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.DYNAMIC_DRAW = 0x88E8;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.CULL_FACE = 0x0B44;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.BLEND = 0x0BE2;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.STENCIL_TEST = 0x0B90;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.DEPTH_TEST = 0x0B71;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.SCISSOR_TEST = 0x0C11;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.UNSIGNED_BYTE = 0x1401;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.UNSIGNED_SHORT = 0x1403;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.UNSIGNED_INT = 0x1405;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.FLOAT = 0x1406;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.RGBA = 0x1908;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.FRAGMENT_SHADER = 0x8B30;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.VERTEX_SHADER = 0x8B31;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.LINK_STATUS = 0x8B82;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.LINEAR = 0x2601;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_MAG_FILTER = 0x2800;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_MIN_FILTER = 0x2801;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_WRAP_S = 0x2802;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_WRAP_T = 0x2803;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE_2D = 0x0DE1;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.TEXTURE0 = 0x84C0;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.CLAMP_TO_EDGE = 0x812F;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.COMPILE_STATUS = 0x8B81;
/**
 * @const
 * @type {number}
 */

_ol_webgl_.FRAMEBUFFER = 0x8D40;
/** end of goog.webgl constants
 */

/**
 * @const
 * @private
 * @type {Array.<string>}
 */

_ol_webgl_.CONTEXT_IDS_ = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];
/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */

_ol_webgl_.getContext = function (canvas, opt_attributes) {
  var context,
      i,
      ii = _ol_webgl_.CONTEXT_IDS_.length;

  for (i = 0; i < ii; ++i) {
    try {
      context = canvas.getContext(_ol_webgl_.CONTEXT_IDS_[i], opt_attributes);

      if (context) {
        return (
          /** @type {!WebGLRenderingContext} */
          context
        );
      }
    } catch (e) {// pass
    }
  }

  return null;
};

exports.default = _ol_webgl_;

},{}],250:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @param {Array.<number>=} opt_arr Array.
 * @param {number=} opt_usage Usage.
 * @struct
 */
var _ol_webgl_Buffer_ = function (opt_arr, opt_usage) {
  /**
   * @private
   * @type {Array.<number>}
   */
  this.arr_ = opt_arr !== undefined ? opt_arr : [];
  /**
   * @private
   * @type {number}
   */

  this.usage_ = opt_usage !== undefined ? opt_usage : _ol_webgl_Buffer_.Usage_.STATIC_DRAW;
};
/**
 * @return {Array.<number>} Array.
 */


_ol_webgl_Buffer_.prototype.getArray = function () {
  return this.arr_;
};
/**
 * @return {number} Usage.
 */


_ol_webgl_Buffer_.prototype.getUsage = function () {
  return this.usage_;
};
/**
 * @enum {number}
 * @private
 */


_ol_webgl_Buffer_.Usage_ = {
  STATIC_DRAW: _webgl2.default.STATIC_DRAW,
  STREAM_DRAW: _webgl2.default.STREAM_DRAW,
  DYNAMIC_DRAW: _webgl2.default.DYNAMIC_DRAW
};
exports.default = _ol_webgl_Buffer_;

},{"../webgl.js":249}],251:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _disposable = require("../disposable.js");

var _disposable2 = _interopRequireDefault(_disposable);

var _array = require("../array.js");

var _array2 = _interopRequireDefault(_array);

var _events = require("../events.js");

var _events2 = _interopRequireDefault(_events);

var _obj = require("../obj.js");

var _obj2 = _interopRequireDefault(_obj);

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _contexteventtype = require("../webgl/contexteventtype.js");

var _contexteventtype2 = _interopRequireDefault(_contexteventtype);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @classdesc
 * A WebGL context for accessing low-level WebGL capabilities.
 *
 * @constructor
 * @extends {ol.Disposable}
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {WebGLRenderingContext} gl GL.
 */
var _ol_webgl_Context_ = function (canvas, gl) {
  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = canvas;
  /**
   * @private
   * @type {WebGLRenderingContext}
   */

  this.gl_ = gl;
  /**
   * @private
   * @type {Object.<string, ol.WebglBufferCacheEntry>}
   */

  this.bufferCache_ = {};
  /**
   * @private
   * @type {Object.<string, WebGLShader>}
   */

  this.shaderCache_ = {};
  /**
   * @private
   * @type {Object.<string, WebGLProgram>}
   */

  this.programCache_ = {};
  /**
   * @private
   * @type {WebGLProgram}
   */

  this.currentProgram_ = null;
  /**
   * @private
   * @type {WebGLFramebuffer}
   */

  this.hitDetectionFramebuffer_ = null;
  /**
   * @private
   * @type {WebGLTexture}
   */

  this.hitDetectionTexture_ = null;
  /**
   * @private
   * @type {WebGLRenderbuffer}
   */

  this.hitDetectionRenderbuffer_ = null;
  /**
   * @type {boolean}
   */

  this.hasOESElementIndexUint = _array2.default.includes(_index2.default.WEBGL_EXTENSIONS, 'OES_element_index_uint'); // use the OES_element_index_uint extension if available

  if (this.hasOESElementIndexUint) {
    gl.getExtension('OES_element_index_uint');
  }

  _events2.default.listen(this.canvas_, _contexteventtype2.default.LOST, this.handleWebGLContextLost, this);

  _events2.default.listen(this.canvas_, _contexteventtype2.default.RESTORED, this.handleWebGLContextRestored, this);
};

_index2.default.inherits(_ol_webgl_Context_, _disposable2.default);
/**
 * Just bind the buffer if it's in the cache. Otherwise create
 * the WebGL buffer, bind it, populate it, and add an entry to
 * the cache.
 * @param {number} target Target.
 * @param {ol.webgl.Buffer} buf Buffer.
 */


_ol_webgl_Context_.prototype.bindBuffer = function (target, buf) {
  var gl = this.getGL();
  var arr = buf.getArray();
  var bufferKey = String(_index2.default.getUid(buf));

  if (bufferKey in this.bufferCache_) {
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    gl.bindBuffer(target, bufferCacheEntry.buffer);
  } else {
    var buffer = gl.createBuffer();
    gl.bindBuffer(target, buffer);
    var
    /** @type {ArrayBufferView} */
    arrayBuffer;

    if (target == _webgl2.default.ARRAY_BUFFER) {
      arrayBuffer = new Float32Array(arr);
    } else if (target == _webgl2.default.ELEMENT_ARRAY_BUFFER) {
      arrayBuffer = this.hasOESElementIndexUint ? new Uint32Array(arr) : new Uint16Array(arr);
    }

    gl.bufferData(target, arrayBuffer, buf.getUsage());
    this.bufferCache_[bufferKey] = {
      buf: buf,
      buffer: buffer
    };
  }
};
/**
 * @param {ol.webgl.Buffer} buf Buffer.
 */


_ol_webgl_Context_.prototype.deleteBuffer = function (buf) {
  var gl = this.getGL();
  var bufferKey = String(_index2.default.getUid(buf));
  var bufferCacheEntry = this.bufferCache_[bufferKey];

  if (!gl.isContextLost()) {
    gl.deleteBuffer(bufferCacheEntry.buffer);
  }

  delete this.bufferCache_[bufferKey];
};
/**
 * @inheritDoc
 */


_ol_webgl_Context_.prototype.disposeInternal = function () {
  _events2.default.unlistenAll(this.canvas_);

  var gl = this.getGL();

  if (!gl.isContextLost()) {
    var key;

    for (key in this.bufferCache_) {
      gl.deleteBuffer(this.bufferCache_[key].buffer);
    }

    for (key in this.programCache_) {
      gl.deleteProgram(this.programCache_[key]);
    }

    for (key in this.shaderCache_) {
      gl.deleteShader(this.shaderCache_[key]);
    } // delete objects for hit-detection


    gl.deleteFramebuffer(this.hitDetectionFramebuffer_);
    gl.deleteRenderbuffer(this.hitDetectionRenderbuffer_);
    gl.deleteTexture(this.hitDetectionTexture_);
  }
};
/**
 * @return {HTMLCanvasElement} Canvas.
 */


_ol_webgl_Context_.prototype.getCanvas = function () {
  return this.canvas_;
};
/**
 * Get the WebGL rendering context
 * @return {WebGLRenderingContext} The rendering context.
 * @api
 */


_ol_webgl_Context_.prototype.getGL = function () {
  return this.gl_;
};
/**
 * Get the frame buffer for hit detection.
 * @return {WebGLFramebuffer} The hit detection frame buffer.
 */


_ol_webgl_Context_.prototype.getHitDetectionFramebuffer = function () {
  if (!this.hitDetectionFramebuffer_) {
    this.initHitDetectionFramebuffer_();
  }

  return this.hitDetectionFramebuffer_;
};
/**
 * Get shader from the cache if it's in the cache. Otherwise, create
 * the WebGL shader, compile it, and add entry to cache.
 * @param {ol.webgl.Shader} shaderObject Shader object.
 * @return {WebGLShader} Shader.
 */


_ol_webgl_Context_.prototype.getShader = function (shaderObject) {
  var shaderKey = String(_index2.default.getUid(shaderObject));

  if (shaderKey in this.shaderCache_) {
    return this.shaderCache_[shaderKey];
  } else {
    var gl = this.getGL();
    var shader = gl.createShader(shaderObject.getType());
    gl.shaderSource(shader, shaderObject.getSource());
    gl.compileShader(shader);
    this.shaderCache_[shaderKey] = shader;
    return shader;
  }
};
/**
 * Get the program from the cache if it's in the cache. Otherwise create
 * the WebGL program, attach the shaders to it, and add an entry to the
 * cache.
 * @param {ol.webgl.Fragment} fragmentShaderObject Fragment shader.
 * @param {ol.webgl.Vertex} vertexShaderObject Vertex shader.
 * @return {WebGLProgram} Program.
 */


_ol_webgl_Context_.prototype.getProgram = function (fragmentShaderObject, vertexShaderObject) {
  var programKey = _index2.default.getUid(fragmentShaderObject) + '/' + _index2.default.getUid(vertexShaderObject);

  if (programKey in this.programCache_) {
    return this.programCache_[programKey];
  } else {
    var gl = this.getGL();
    var program = gl.createProgram();
    gl.attachShader(program, this.getShader(fragmentShaderObject));
    gl.attachShader(program, this.getShader(vertexShaderObject));
    gl.linkProgram(program);
    this.programCache_[programKey] = program;
    return program;
  }
};
/**
 * FIXME empy description for jsdoc
 */


_ol_webgl_Context_.prototype.handleWebGLContextLost = function () {
  _obj2.default.clear(this.bufferCache_);

  _obj2.default.clear(this.shaderCache_);

  _obj2.default.clear(this.programCache_);

  this.currentProgram_ = null;
  this.hitDetectionFramebuffer_ = null;
  this.hitDetectionTexture_ = null;
  this.hitDetectionRenderbuffer_ = null;
};
/**
 * FIXME empy description for jsdoc
 */


_ol_webgl_Context_.prototype.handleWebGLContextRestored = function () {};
/**
 * Creates a 1x1 pixel framebuffer for the hit-detection.
 * @private
 */


_ol_webgl_Context_.prototype.initHitDetectionFramebuffer_ = function () {
  var gl = this.gl_;
  var framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

  var texture = _ol_webgl_Context_.createEmptyTexture(gl, 1, 1);

  var renderbuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1, 1);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  this.hitDetectionFramebuffer_ = framebuffer;
  this.hitDetectionTexture_ = texture;
  this.hitDetectionRenderbuffer_ = renderbuffer;
};
/**
 * Use a program.  If the program is already in use, this will return `false`.
 * @param {WebGLProgram} program Program.
 * @return {boolean} Changed.
 * @api
 */


_ol_webgl_Context_.prototype.useProgram = function (program) {
  if (program == this.currentProgram_) {
    return false;
  } else {
    var gl = this.getGL();
    gl.useProgram(program);
    this.currentProgram_ = program;
    return true;
  }
};
/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 * @private
 */


_ol_webgl_Context_.createTexture_ = function (gl, opt_wrapS, opt_wrapT) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  if (opt_wrapS !== undefined) {
    gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_S, opt_wrapS);
  }

  if (opt_wrapT !== undefined) {
    gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_T, opt_wrapT);
  }

  return texture;
};
/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {number} width Width.
 * @param {number} height Height.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 */


_ol_webgl_Context_.createEmptyTexture = function (gl, width, height, opt_wrapS, opt_wrapT) {
  var texture = _ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  return texture;
};
/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 */


_ol_webgl_Context_.createTexture = function (gl, image, opt_wrapS, opt_wrapT) {
  var texture = _ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  return texture;
};

exports.default = _ol_webgl_Context_;

},{"../array.js":30,"../disposable.js":46,"../events.js":49,"../index.js":90,"../obj.js":125,"../webgl.js":249,"../webgl/contexteventtype.js":252}],252:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * @enum {string}
 */
var _ol_webgl_ContextEventType_ = {
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored'
};
exports.default = _ol_webgl_ContextEventType_;

},{}],253:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _shader = require("../webgl/shader.js");

var _shader2 = _interopRequireDefault(_shader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.webgl.Shader}
 * @param {string} source Source.
 * @struct
 */
var _ol_webgl_Fragment_ = function (source) {
  _shader2.default.call(this, source);
};

_index2.default.inherits(_ol_webgl_Fragment_, _shader2.default);
/**
 * @inheritDoc
 */


_ol_webgl_Fragment_.prototype.getType = function () {
  return _webgl2.default.FRAGMENT_SHADER;
};

exports.default = _ol_webgl_Fragment_;

},{"../index.js":90,"../webgl.js":249,"../webgl/shader.js":254}],254:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _functions = require("../functions.js");

var _functions2 = _interopRequireDefault(_functions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @abstract
 * @param {string} source Source.
 * @struct
 */
var _ol_webgl_Shader_ = function (source) {
  /**
   * @private
   * @type {string}
   */
  this.source_ = source;
};
/**
 * @abstract
 * @return {number} Type.
 */


_ol_webgl_Shader_.prototype.getType = function () {};
/**
 * @return {string} Source.
 */


_ol_webgl_Shader_.prototype.getSource = function () {
  return this.source_;
};
/**
 * @return {boolean} Is animated?
 */


_ol_webgl_Shader_.prototype.isAnimated = _functions2.default.FALSE;
exports.default = _ol_webgl_Shader_;

},{"../functions.js":61}],255:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../index.js");

var _index2 = _interopRequireDefault(_index);

var _webgl = require("../webgl.js");

var _webgl2 = _interopRequireDefault(_webgl);

var _shader = require("../webgl/shader.js");

var _shader2 = _interopRequireDefault(_shader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @constructor
 * @extends {ol.webgl.Shader}
 * @param {string} source Source.
 * @struct
 */
var _ol_webgl_Vertex_ = function (source) {
  _shader2.default.call(this, source);
};

_index2.default.inherits(_ol_webgl_Vertex_, _shader2.default);
/**
 * @inheritDoc
 */


_ol_webgl_Vertex_.prototype.getType = function () {
  return _webgl2.default.VERTEX_SHADER;
};

exports.default = _ol_webgl_Vertex_;

},{"../index.js":90,"../webgl.js":249,"../webgl/shader.js":254}],256:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _array = require("./array.js");

var _array2 = _interopRequireDefault(_array);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _ol_xml_ = {};
/**
 * This document should be used when creating nodes for XML serializations. This
 * document is also used by {@link ol.xml.createElementNS} and
 * {@link ol.xml.setAttributeNS}
 * @const
 * @type {Document}
 */

_ol_xml_.DOCUMENT = document.implementation.createDocument('', '', null);
/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Node} Node.
 */

_ol_xml_.createElementNS = function (namespaceURI, qualifiedName) {
  return _ol_xml_.DOCUMENT.createElementNS(namespaceURI, qualifiedName);
};
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */


_ol_xml_.getAllTextContent = function (node, normalizeWhitespace) {
  return _ol_xml_.getAllTextContent_(node, normalizeWhitespace, []).join('');
};
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array.<string>} accumulator Accumulator.
 * @private
 * @return {Array.<string>} Accumulator.
 */


_ol_xml_.getAllTextContent_ = function (node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n;

    for (n = node.firstChild; n; n = n.nextSibling) {
      _ol_xml_.getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }

  return accumulator;
};
/**
 * @param {?} value Value.
 * @return {boolean} Is document.
 */


_ol_xml_.isDocument = function (value) {
  return value instanceof Document;
};
/**
 * @param {?} value Value.
 * @return {boolean} Is node.
 */


_ol_xml_.isNode = function (value) {
  return value instanceof Node;
};
/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */


_ol_xml_.getAttributeNS = function (node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || '';
};
/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @param {string|number} value Value.
 */


_ol_xml_.setAttributeNS = function (node, namespaceURI, name, value) {
  node.setAttributeNS(namespaceURI, name, value);
};
/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */


_ol_xml_.parse = function (xml) {
  return new DOMParser().parseFromString(xml, 'application/xml');
};
/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): (Array.<*>|undefined)}
 *     valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeArrayExtender = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this, node, objectStack);

      if (value !== undefined) {
        var array =
        /** @type {Array.<*>} */
        objectStack[objectStack.length - 1];

        _array2.default.extend(array, value);
      }
    }
  );
};
/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeArrayPusher = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var array = objectStack[objectStack.length - 1];
        array.push(value);
      }
    }
  );
};
/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeReplacer = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        objectStack[objectStack.length - 1] = value;
      }
    }
  );
};
/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeObjectPropertyPusher = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var object =
        /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        var array;

        if (property in object) {
          array = object[property];
        } else {
          array = object[property] = [];
        }

        array.push(value);
      }
    }
  );
};
/**
 * Make an object property setter function.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */


_ol_xml_.makeObjectPropertySetter = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);

      if (value !== undefined) {
        var object =
        /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        object[property] = value;
      }
    }
  );
};
/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link ol.XmlNodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */


_ol_xml_.makeChildAppender = function (nodeWriter, opt_this) {
  return function (node, value, objectStack) {
    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);
    var parent = objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node);
  };
};
/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link ol.xml.serialize}. This can be used by the parent writer to have the
 * 'nodeWriter' called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */


_ol_xml_.makeArraySerializer = function (nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function (node, value, objectStack) {
    if (serializersNS === undefined) {
      serializersNS = {};
      var serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = _ol_xml_.makeSimpleNodeFactory(node.localName);
    }

    _ol_xml_.serialize(serializersNS, nodeFactory, value, objectStack);
  };
};
/**
 * Create a node factory which can use the `opt_keys` passed to
 * {@link ol.xml.serialize} or {@link ol.xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string=} opt_nodeName Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array.<*>, string=): (Node|undefined)} Node factory.
 */


_ol_xml_.makeSimpleNodeFactory = function (opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return (
    /**
     * @param {*} value Value.
     * @param {Array.<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node} Node.
     */
    function (value, objectStack, opt_nodeName) {
      var context = objectStack[objectStack.length - 1];
      var node = context.node;
      var nodeName = fixedNodeName;

      if (nodeName === undefined) {
        nodeName = opt_nodeName;
      }

      var namespaceURI = opt_namespaceURI;

      if (opt_namespaceURI === undefined) {
        namespaceURI = node.namespaceURI;
      }

      return _ol_xml_.createElementNS(namespaceURI,
      /** @type {string} */
      nodeName);
    }
  );
};
/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 */


_ol_xml_.OBJECT_PROPERTY_NODE_FACTORY = _ol_xml_.makeSimpleNodeFactory();
/**
 * Create an array of `values` to be used with {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `opt_key` argument.
 * @param {Object.<string, V>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array.<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array.<V>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 * @template V
 */

_ol_xml_.makeSequence = function (object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);

  for (var i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }

  return sequence;
};
/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.
 * @return {Object.<string, T>} Namespaced structure.
 * @template T
 */


_ol_xml_.makeStructureNS = function (namespaceURIs, structure, opt_structureNS) {
  /**
   * @type {Object.<string, *>}
   */
  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
  var i, ii;

  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }

  return structureNS;
};
/**
 * Parse a node using the parsers and object stack.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 */


_ol_xml_.parseNode = function (parsersNS, node, objectStack, opt_this) {
  var n;

  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var parsers = parsersNS[n.namespaceURI];

    if (parsers !== undefined) {
      var parser = parsers[n.localName];

      if (parser !== undefined) {
        parser.call(opt_this, n, objectStack);
      }
    }
  }
};
/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 * @return {T} Object.
 * @template T
 */


_ol_xml_.pushParseAndPop = function (object, parsersNS, node, objectStack, opt_this) {
  objectStack.push(object);

  _ol_xml_.parseNode(parsersNS, node, objectStack, opt_this);

  return objectStack.pop();
};
/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */


_ol_xml_.serialize = function (serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== undefined ? opt_keys : values).length;
  var value, node;

  for (var i = 0; i < length; ++i) {
    value = values[i];

    if (value !== undefined) {
      node = nodeFactory.call(opt_this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);

      if (node !== undefined) {
        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
      }
    }
  }
};
/**
 * @param {O} object Object.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */


_ol_xml_.pushSerializeAndPop = function (object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  objectStack.push(object);

  _ol_xml_.serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);

  return objectStack.pop();
};

exports.default = _ol_xml_;

},{"./array.js":30}],257:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.quickselect = factory());
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));

},{}],258:[function(require,module,exports){
'use strict';

module.exports = rbush;

var quickselect = require('quickselect');

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

},{"quickselect":257}]},{},[2]);
